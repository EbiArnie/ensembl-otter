#! /usr/bin/env perl
use strict;
use warnings;

use File::Slurp qw( slurp write_file );
use YAML 'Dump';
use Test::More;
use Test::Differences qw( eq_or_diff unified_diff );
use Test::Otter 'try_err';

use Bio::Otter::Server::Config;
our $BOSC = 'Bio::Otter::Server::Config';

use Test::MockObject;
BEGIN { $INC{'SangerWeb.pm'} = '/bogus/file' }
use Bio::Otter::Server::Support::Web;


=head1 DESCRIPTION

=head2 Re-create old file

Make an old-style C<users.txt+> file in your developer server-config,
from the new C<access.yaml>.  NB. different filename.

You will need a full checkout of C<dev> or C<live>, but don't commit
the file on that branch!

=head2 Diff to real old file

Self-tests to compare backwards compatibility.

=head2 Check per-user datasets match the old logic

It's a test, but when the old code is gone it won't matter.

=cut


sub make_legacy {
    # Get user sort order
    my @old_txt = split "\n", o_slurp('users.txt');
    my %usr_line; # key = email, value = line number
    for (my $i=1; $i<=@old_txt; $i++) {
        my $ln = $old_txt[$i-1];
        next if $ln =~ /^\s*(#|$)/;
        die "Bad users.txt:$i $ln" unless $ln =~ m{^(\S+)};
        my $u = $1;
        warn "Duplicate user $u: $i vs $usr_line{$u}" if exists $usr_line{$u};
        $usr_line{$u} = $i;
    }

    # Create sorters
    my $sort_u = sub {
        foreach my $n ($a, $b) {
            next if defined $usr_line{$n};
            if (my @got = grep { lc($n) eq lc($_) } keys %usr_line) {
                warn "Username $n othercased from @got";
            } else {
                warn "New username $n: unexpected, put at the end";
            }
            $usr_line{$n} = scalar keys %usr_line;
        }
        return $usr_line{$a} <=> $usr_line{$b};
    };
    my %ds;
    {
        my @ds = qw( human mouse zebrafish pig human_test human_dev mouse_test cat_dev alignment_test );
        @ds{@ds} = (1 .. @ds);
    }
    my $sort_ds = sub {
        ($ds{$a} || 1E6) <=> ($ds{$b} || 1E6) || $a cmp $b;
    };

    # Build new access.yaml into old format
    # preserving user order but not comments, blank lines or whitespace
    my $old_style = $BOSC->users_hash('samecase');
    my $legacy_txt = join '',
      map { my @u_species =  keys %{ $old_style->{$_} };
            if (@u_species) {
                sprintf "%-39s %s\n", $_,
                  (join ' ', sort $sort_ds @u_species);
            } else {
                "$_\n";
            }
        }
        sort $sort_u keys %$old_style;

    $legacy_txt = <<HEADER . $legacy_txt;
# Legacy users.txt for Otter Server below v85
# generated @{[ scalar localtime ]}
# from access.yaml by $0

HEADER
    return $legacy_txt;
}

sub o_slurp {
    my ($name) = @_;
    return slurp( $BOSC->data_filename($name) );
}


sub main {
    $ENV{ANACODE_SERVER_CONFIG} = "$ENV{HOME}/.otter/server-config/";

    # Re-create
    my $legacy_txt = make_legacy();
    my $fn = $BOSC->data_filename('users.txt');
    die "File $fn: does not exist" unless -f $fn;
    $fn .= '+'; # do not tromp (yet)
    write_file($fn, { atomic => 1 }, $legacy_txt);

    # Test
    plan tests => 3;
    my $old = $BOSC->users_hash__old;
    my $new = $BOSC->users_hash;
    unified_diff();
    eq_or_diff($new, $old, 'users_hash match')
      or diag explain { old => $old, new => $new };

    my $orig_utxt = o_slurp('users.txt');
    my $new_utxt = o_slurp('users.txt+');
    foreach ($orig_utxt, $new_utxt) {
        s{^(#.*)?\s*\n}{}mg; # remove comments, we don't try to keep them
    }
    eq_or_diff($new_utxt, $orig_utxt,
               'users.txt re-generated from new format');
    diag 'made legacy-style users.txt+ from access.yaml';

    subtest legacy_dataset_match => \&legacy_dataset_match_tt;

    return 0;
}

exit main();


# ugly but transient
my $EMAIL;
sub SangerWeb::new {
    # testing auth code in B:O:S:S:Web : need to insert our mock
    # SangerWeb into its ->new
    die "SangerWeb must not be loaded" if SangerWeb->can('handler');
    return Test::MockObject->new->mock(username => sub { $EMAIL });
}

# See that under access.yaml all users get the same access as under
# users.txt .
#
# Beware that B:O:S:S:Web uses B:O:Auth:SSO which takes the
# users_hash, but we already checked that matches exactly.
sub legacy_dataset_match_tt {
    my $users_new = $BOSC->Access->all_users;
    my @emails = map { $_->email } values %$users_new;
    foreach my $email ('staff', sort @emails) {
        $EMAIL = $email;
        note "BOSSW->new for $email";
        my $SSW = Bio::Otter::Server::Support::Web->new; # may call exit(1) !
        my $new = $SSW->allowed_datasets;
        my $old = $SSW->allowed_datasets__old;

        my @cmp = map { __datasets_hashified(@$_) } ($new, $old);
        is_deeply($cmp[0], $cmp[1], "allowed_datasets{,__old} for $email")
          or diag explain \@cmp;
    }

    $EMAIL = 'nonstaff@example.org';
    my $SSW_extern = try_err {
        no warnings 'redefine';
        local *Bio::Otter::Server::Support::Web::unauth_exit =
          sub {
              my ($obj, $reason) = @_;
              die "unauth_exit: $reason";
          };
        Bio::Otter::Server::Support::Web->new;
    };
    like($SSW_extern, qr{^ERR:unauth_exit: User not authorized},
         'external unknown user');

    done_testing();
}

sub __datasets_hashified {
    my @dataset = @_;
    my %out = map {( $_->name, $_ )} @dataset;
    return \%out;
}
