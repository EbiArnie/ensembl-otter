#! /usr/bin/env perl
use strict;
use warnings;

use File::Slurp qw( slurp write_file );
use YAML 'Dump';
use Test::More;
use Test::Differences qw( eq_or_diff unified_diff );

use Bio::Otter::Server::Config;
our $BOSC = 'Bio::Otter::Server::Config';

=head1 DESCRIPTION

=head2 Re-create old file

Make an old-style C<users.txt+> file in your developer server-config,
from the new C<access.yaml>.  NB. different filename.

You will need a full checkout of C<dev> or C<live>, but don't commit
the file on that branch!

=head2 Diff to real old file

Self-tests to compare backwards compatibility.

=cut


sub make_new {
    my $u_in = Bio::Otter::Server::Config->users_hash__old;
    my $sp_in = Bio::Otter::Server::Config->SpeciesDat;

    # Build new-format user permissions
    my %u_out;

    while (my ($user, $allow_h) = each %$u_in) {
        die Dump({ weird__allow_h => [ $user, $allow_h ] })
          if grep { $_ ne 1 } values %$allow_h;
        $u_out{$user} = { write => [ sort keys %$allow_h ] };
    }

    my $staff = qx{ ypmatch havana aliases };
    chomp $staff;
    my @staff = split ',', $staff;
    die Dump({ weird__staff_list => \@staff })
      unless @staff > 10 && grep { $_ eq $ENV{USER} } @staff;

    unshift @{ $u_out{$_}{write} }, ':main' foreach @staff;

    # Build species groups
    my %sp_grp =
      (dev => [ sort qw[ human_dev human_test cat_dev ]]);
    foreach my $ds (sort { $a->name cmp $b->name } @{ $sp_in->datasets }) {
        my $key = $ds->params->{RESTRICTED} ? 'restricted' : 'main';
        push @{ $sp_grp{$key} }, $ds->name;
    }

    my %out =
      (species_groups => \%sp_grp,
#       _raw => { 'users.txt' => $u_in, 'species.dat' => $sp_in },
       users => \%u_out);

    return \%out;
}

sub make_legacy {
    # Get user sort order
    my @old_txt = split "\n", o_slurp('users.txt');
    my %usr_line; # key = email, value = line number
    for (my $i=1; $i<=@old_txt; $i++) {
        my $ln = $old_txt[$i-1];
        next if $ln =~ /^\s*(#|$)/;
        die "Bad users.txt:$i $ln" unless $ln =~ m{^(\S+)};
        my $u = $1;
        warn "Duplicate user $u: $i vs $usr_line{$u}" if exists $usr_line{$u};
        $usr_line{$u} = $i;
    }

    # Create sorters
    my $sort_u = sub {
        foreach my $n ($a, $b) {
            next if defined $usr_line{$n};
            if (my @got = grep { lc($n) eq lc($_) } keys %usr_line) {
                warn "Username $n othercased from @got";
            } else {
                warn "New username $n: unexpected, put at the end";
            }
            $usr_line{$n} = scalar keys %usr_line;
        }
        return $usr_line{$a} <=> $usr_line{$b};
    };
    my %ds;
    {
        my @ds = qw( human mouse zebrafish pig human_test human_dev mouse_test cat_dev alignment_test );
        @ds{@ds} = (1 .. @ds);
    }
    my $sort_ds = sub {
        ($ds{$a} || 1E6) <=> ($ds{$b} || 1E6) || $a cmp $b;
    };

    # Build new access.yaml into old format
    # preserving user order but not comments, blank lines or whitespace
    my $old_style = $BOSC->users_hash('samecase');
    my $legacy_txt = join '',
      map { my @u_species =  keys %{ $old_style->{$_} };
            if (@u_species) {
                sprintf "%-39s %s\n", $_,
                  (join ' ', sort $sort_ds @u_species);
            } else {
                "$_\n";
            }
        }
        sort $sort_u keys %$old_style;

    return $legacy_txt;
}

sub o_slurp {
    my ($name) = @_;
    return slurp( $BOSC->data_filename($name) );
}


sub main {
    $ENV{ANACODE_SERVER_CONFIG} = "$ENV{HOME}/.otter/server-config/";

    # Create
    if (0) {
        my $new_style = make_new();
        my $fn = Bio::Otter::Server::Config->data_filename('access.yaml');
        die "File $fn: exists" if -e $fn;
        write_file($fn, { atomic => 1 }, Dump($new_style));
    }

    # Re-create
    my $legacy_txt = make_legacy();
    my $fn = $BOSC->data_filename('users.txt');
    die "File $fn: does not exist" unless -f $fn;
    $fn .= '+'; # do not tromp (yet)
    write_file($fn, { atomic => 1 }, $legacy_txt);

    # Test
    plan tests => 2;
    my $old = Bio::Otter::Server::Config->users_hash__old;
    my $new = Bio::Otter::Server::Config->users_hash;
    unified_diff();
    eq_or_diff($new, $old, 'users_hash match')
      or diag explain { old => $old, new => $new };

    my $orig_utxt = o_slurp('users.txt');
    $orig_utxt =~ s{^(#.*)?\s*\n}{}mg; # remove comments, we don't try to keep them
    eq_or_diff(scalar o_slurp('users.txt+'),
               $orig_utxt,
               'users.txt re-generated from new format');

    return 0;
}

exit main();
