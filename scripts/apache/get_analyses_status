#!/usr/local/bin/perl -Tw

# Author:        jgrg
# Group:         anacode
# Maintainer:    jgrg

use strict;
use warnings;

use SangerPaths qw{ core bioperl123 ensembl57 otter53 };

use Bio::Otter::ServerScriptSupport;

my $ana_root = 'SubmitContig';

sub get_possible_analyses {
    my ($pdbc) = @_;

    my %rule = ();
    my $rule_sth = $pdbc->prepare(qq{
        SELECT rc.rule_condition
             , a.logic_name
        FROM analysis a
           , rule_goal rg
           , rule_conditions rc
        WHERE a.analysis_id = rg.goal
          AND rg.rule_id = rc.rule_id
        });
    $rule_sth->execute;
    while (my ($condition, $logic_name) = $rule_sth->fetchrow) {
        push @{$rule{$condition}}, $logic_name;
    }

    # saturate the dependency relation:
    my @possible_analyses = ();
    my $current_rules = [ $ana_root ];
    while (scalar(@$current_rules)) {
        my @dependent_rules = ();
        foreach my $curr (@$current_rules) {
            push @dependent_rules, @{$rule{$curr} || []};
        }
        push @possible_analyses, @dependent_rules;
        $current_rules = \@dependent_rules;
    }

    return @possible_analyses;
}


my $server = Bio::Otter::ServerScriptSupport->new;

my $assembly = $server->require_argument('type');
my $component_cs = $server->param('component_cs') || 'contig';

my $pdbc = $server->satellite_dba( '' )->dbc();  # pipeline dbc

my @input_ids = ();

my $cmp_sth = $pdbc->prepare(qq{
    SELECT cmp.name, cs.version
    FROM coord_system cs
      , seq_region cmp
      , assembly a
      , seq_region asm
    WHERE asm.name = '$assembly'
      AND asm.seq_region_id = a.asm_seq_region_id
      AND a.cmp_seq_region_id = cmp.seq_region_id
      AND cmp.coord_system_id = cs.coord_system_id
      AND cs.name = '$component_cs'
});
$cmp_sth->execute();

while (my ($cmp_name, $cs_version) = $cmp_sth->fetchrow) {
    my @syll = split(/\./, $cmp_name);
    my $to = pop @syll;
    my $from = pop @syll;
    if(!defined($cs_version)) { $cs_version = ''; }
    push @input_ids, join(':', $component_cs, $cs_version, $cmp_name, $from, $to, 1);
}

my %skeleton_hash = map { ($_ => []) } get_possible_analyses($pdbc);
my %result_hash   = ();

# If there are no input IDs - just peacefully return an empty list:
if(! @input_ids) {
    $server->log('No input IDs');
    $server->return_emptyhanded();
}

my $input_id_str = join(', ', map { "'$_'" } @input_ids);
my $sql_statement = qq{
        SELECT i.input_id
          , a.logic_name
          , i.created
          , i.db_version
        FROM analysis a
          , input_id_analysis i
        WHERE a.analysis_id = i.analysis_id
          AND i.input_id IN ($input_id_str)
        };
my $input_sth = $pdbc->prepare($sql_statement);
$input_sth->execute();

while(my ($input_id, $logic_name, $created, $db_version) = $input_sth->fetchrow_array) {
    $input_id=~s/^$component_cs:[^:]*:([^:]+):.*$/$1/;

    if(!exists($result_hash{$input_id})) {
        %{$result_hash{$input_id}} = %skeleton_hash;
    }
    $result_hash{$input_id}{$logic_name} = [$created, $db_version];
}

    # output the results:
my $output_string = '';
for my $input_id (sort keys %result_hash) {
    for my $logic_name (sort {
            ($a eq $ana_root) ? -1 : ($b eq $ana_root) ? 1 : ($a cmp $b)
        } keys %{$result_hash{$input_id}}) {
            $output_string .= join("\t", $input_id, $logic_name, @{$result_hash{$input_id}{$logic_name}})."\n";
    }
}

$server->send_response($output_string, 1);

1;

