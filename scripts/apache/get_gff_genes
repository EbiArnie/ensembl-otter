#!/usr/local/bin/perl -Tw

# Author:        gr5
# Group:         anacode
# Maintainer:    gr5

use strict;
use warnings;

use SangerPaths qw{ core bioperl123 ensembl57 otter53 };

use Bio::Otter::ServerScriptSupport;
use Bio::Otter::ToXML;
use Bio::Vega::Utils::EnsEMBL2GFF;


sub Bio::EnsEMBL::Gene::propagate_slice {
    my ($gene, $slice) = @_;

    foreach my $exon (@{ $gene->get_all_Exons }) {
        $exon->slice($slice);
    }
    foreach my $transcript (@{ $gene->get_all_Transcripts }) {
        $transcript->slice($slice);
    }
    $gene->slice($slice);

    return;
}

my $server = Bio::Otter::ServerScriptSupport->new;

my $gff_string = '';

eval {
    my @analysis_names = $server->param('analysis') ? split(/,/, $server->param('analysis')) :
                                                      ( undef );
    my $transcript_analyses  = $server->param('transcript_analyses')  || '';
    my $translation_xref_dbs = $server->param('translation_xref_dbs') || '';
    my $rebase               = $server->param('rebase');
    my $gff_source           = $server->param('gff_source');
    my $gff_seqname          = $server->param('gff_seqname');

    my $allowed_transcript_analyses_hash = $transcript_analyses
        ? { map { $_ => 1 } split(/,/, $transcript_analyses) }
        : '';
    my $allowed_translation_xref_db_hash = $translation_xref_dbs
        ? { map { $_ => 1 } split(/,/, $translation_xref_dbs) }
        : '';

    foreach my $analysis_name (@analysis_names) {
        # third parameter of $slice->get_all_Genes() helps preventing lazy-loading of transcripts
        my $genes = $server->fetch_mapped_features('gene', 'get_all_Genes', [$analysis_name, undef, 1],
            map { defined($server->param($_)) ? $server->param($_) : '' } qw(cs name type start end metakey csver csver_remote)
        );
        
        $gff_string ||= $genes->[0]->slice->gff_header(rebase => $rebase, gff_seqname => $gff_seqname) if @$genes;

        foreach my $gene (@$genes) {

            # filter the transcripts according to the transcript_analyses & translation_xref_db params

            for my $tsct (@{ $gene->get_all_Transcripts } ) {
                
                if (!$allowed_transcript_analyses_hash || 
                    $allowed_transcript_analyses_hash->{$tsct->analysis->logic_name}) {
                    
                    my $allowed = ! $allowed_translation_xref_db_hash;
                    
                    if (!$allowed) { 
                        if (my $trl = $tsct->translation) {
                            for my $xr (@{ $trl->get_all_DBEntries }) {
                                if($allowed_translation_xref_db_hash->{$xr->dbname}) {
                                    $allowed = 1;
                                    last;
                                }
                            }
                        }
                    }
                    
                    if ($allowed) {
                        
                        $gff_string .= $tsct->to_gff(
                            rebase      => $rebase, 
                            gff_source  => $gff_source, 
                            gff_seqname => $gff_seqname,
                            extra_attrs => { Locus => '"' . $gene->display_id . '"' },
                        )."\n";
                        
                    }
                }
            }
            
            #$gff_string .= $gene->to_gff(rebase => $rebase, gff_source => $gff_source, gff_seqname => $gff_seqname)."\n";
        }
    }
    
    unless ($gff_string) {
        $gff_string = $server->empty_gff_header;
    }
};

if ($@) {
    $server->error_exit("Error fetching genes:\n" . $@);
} else {
    $server->send_response($gff_string, 0, 1);
}

1;

