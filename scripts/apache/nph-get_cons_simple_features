#!/usr/local/bin/perl -Tw

# Author:        jgrg
# Group:         anacode
# Maintainer:    jgrg
# Last modified: $Date: 2008-02-22 14:29:37 $
# Id:            $Id: nph-get_cons_simple_features,v 1.10 2008-02-22 14:29:37 jgrg Exp $
# Source:        $Source: /tmp/ENSCOPY-ENSEMBL-OTTER/scripts/apache/Attic/nph-get_cons_simple_features,v $

use strict;
use SangerPaths qw{ core bioperl123 ensembl46 otter48 };

#use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Compara::DBSQL::DBAdaptor;
use Bio::EnsEMBL::SimpleFeature;
use Bio::Otter::ServerScriptSupport;
use Bio::Otter::Lace::ViaText ('%OrderOfOptions');

sub Bio::EnsEMBL::Slice::get_all_ConsFeatures {
    my ($slice, $server, $cutoff) = @_;

#    my $compara_dba = Bio::EnsEMBL::Compara::DBSQL::DBAdaptor->new(
#        -host   => 'ensembldb.ensembl.org',
#        -user   => 'anonymous',
#        -dbname => 'ensembl_compara_42',
#    );
#
#    my $mlssa = $compara_dba->get_MethodLinkSpeciesSetAdaptor();
#    my $csa   = $compara_dba->get_ConservationScoreAdaptor();

    my $reg = "Bio::EnsEMBL::Registry";
    $reg->load_registry_from_db(
        -host => "ensembldb.ensembl.org",
        -user => "anonymous"
    );

    # Get all the MethodLinkSpeciesSet for the 9 way GERP_CONSERVATION_SCORE
    my $mlssa = $reg->get_adaptor(
        "Multi", "compara", "MethodLinkSpeciesSet");

    unless($mlssa) {
        $server->error_exit("Could not fetch MethodLinkSpeciesSetAdaptor");
    }

    my $cons_score_mlss = $mlssa->
        fetch_by_method_link_type_registry_aliases(
            "GERP_CONSERVATION_SCORE", ["Homo sapiens", "Pan troglodytes",
            "Macaca mulatta", "Mus musculus", "Rattus norvegicus", 
            "Canis familiaris", "Bos taurus", "Gallus gallus", 
            "Monodelphis domestica"]);

    my $csa = $reg->get_adaptor(
        "Multi", "compara", "ConservationScore");

    my $conservation_scores = $csa->
        fetch_all_by_MethodLinkSpeciesSet_Slice($cons_score_mlss, $slice,
            $slice->length-1, 'AVERAGE', 1, 'NCBI36');

    my @csfs   = ();
    my $strand = $slice->strand();
    foreach my $cons_score (@$conservation_scores) {
        my $score = $cons_score->observed_score;
        next if($score<=$cutoff);

        my $simple_feature = Bio::EnsEMBL::SimpleFeature->new();
        my $position = $cons_score->position();
        my $printable_score = sprintf("%.6f", $score);
        $simple_feature->slice(  $slice );
        $simple_feature->start(  $position );
        $simple_feature->end(    $position );
        $simple_feature->strand( $strand );
        $simple_feature->score(  $printable_score );
        $simple_feature->display_label( 'ConsScore='.$printable_score );

        push @csfs, $simple_feature;
    }

    return \@csfs;
}

my $server = Bio::Otter::ServerScriptSupport->new;

if(!$server->running_headcode()) {
    $server->error_exit("This kind of data can only be fetched in pipehead==1 mode");
}

my $cutoff = $server->param('cutoff') || 0;

my $csfs = $server->fetch_mapped_features('cons_feature', 'get_all_ConsFeatures', [$server, $cutoff],
    map { defined($server->param($_)) ? $server->param($_) : '' } qw(cs name type start end metakey csver csver_remote)
);

my @sf_optnames = @{ $OrderOfOptions{SimpleFeature} };
my $output_string = '';

foreach my $sf (@$csfs) {
        # output a SimpleFeature line
    my @sf_optvalues = ('SimpleFeature');
    for my $opt (@sf_optnames) {
        push @sf_optvalues, $sf->$opt();
    }

    $output_string .= join("\t", @sf_optvalues)."\n";
}

$server->send_response($output_string, 1);

1;

