#!/usr/local/bin/perl -Tw

# Author:        lg4
# Group:         anacode
# Maintainer:    jgrg
# Last modified: $Date: 2008-07-29 11:06:05 $
# Id:            $Id: nph-get_das_features,v 1.3 2008-07-29 11:06:05 lg4 Exp $
# Source:        $Source: /tmp/ENSCOPY-ENSEMBL-OTTER/scripts/apache/Attic/nph-get_das_features,v $

use strict;
use SangerPaths qw{ core bioperl123 ensembl49 otter50 };

my $http_proxy = $ENV{http_proxy};

use Data::Dumper;
use Bio::Das::Lite;
use Bio::EnsEMBL::SimpleFeature;
use Bio::EnsEMBL::PredictionExon;
use Bio::EnsEMBL::PredictionTranscript;
use Bio::Otter::ServerScriptSupport;
use Bio::Otter::Lace::ViaText qw( &GenerateFeatures %LangDesc );

sub struct_traverse_path {
    my ($struct, $path) = @_;

    if(ref($path->[0]) eq 'ARRAY') { # recoursive application of self to the parts
        my $join = join(';', map { my $foo = struct_traverse_path($struct, $_); defined($foo) ? $foo : 'UnDeF' } @$path );
        return ($join=~/UnDeF/) ? undef : $join;
    }

    foreach my $step (@$path) {
        if(ref($struct) eq 'HASH') {
            $struct = $struct->{$step};
        } elsif(ref($struct) eq 'ARRAY') {
            $struct = $struct->[$step];
        } else {
            return;
        }
    }
    return $struct;
}

sub struct_show_path {
    my ($struct, $path) = @_;

    if(ref($path->[0]) eq 'ARRAY') { # recoursive application of self to the parts
        return join('.', map { struct_show_path($struct, $_) } @$path );
    }

    my $output = '$feature->';

    foreach my $step (@$path) {
        if(ref($struct) eq 'HASH') {
            $output .= '{'.$step.'}';
            $struct = $struct->{$step};
        } elsif(ref($struct) eq 'ARRAY') {
            $output .= '['.$step.']';
            $struct = $struct->[$step];
        } else {
            $output .= '?'.$step.'?';
        }
    }
    return $output;
}

sub Bio::EnsEMBL::Slice::get_all_features_via_DAS { # $kind = 'SimpleFeature' || 'PredictionExon'
    my ($slice, $server, $das, $chr_name, $analysis_name, $kind, $sieve, $grouplabel, $dump) = @_;

    my $feature_subhash     = $LangDesc{$kind};
    my $feature_constructor = $feature_subhash->{-constructor};
    my ($parent_constructor, $add_sub);

    if(my $cmp_uplink = $feature_subhash->{-add_one_cmp}) {  # component link is two-way (parent keeps a list of its components)
        my $parent_feature_type;
        ($parent_feature_type, $add_sub) = @$cmp_uplink;
        $parent_constructor = $LangDesc{$parent_feature_type}{-constructor};
    }

    my @paths_to_try = $parent_constructor
        ? ( ['group',0,'group_label'], ['group',0,'group_id'], ['feature_label'], ['feature_id'] )
        : ( [['group',0,'group_label'], ['type']], [['group',0,'group_id'], ['type']], ['type'], ['type_id'], ['feature_label'], ['feature_id'] );

    my $chr_start = $slice->start();
    my $chr_end   = $slice->end();
    my $segment_name  = "$chr_name:$chr_start,$chr_end";

    my ($sieve_field_path, $sieve_sign, $sieve_value) = split(/(--CONTAINS--|--LACKS--)/, $sieve);
    $sieve_field_path &&= [ split(/--THEN--/,$sieve_field_path) ];

    my $grouplabel_field_path = $grouplabel ? [ map { [ split(/--THEN--/,$_) ] } split(/--JOIN--/,$grouplabel) ] : '';

    # DAS servers will give all features if a "type=" argument is not present
    if ($analysis_name and $analysis_name eq 'all') {
        $analysis_name = undef;
    }

    $server->log( sprintf ("GET  %s/features?segment=%s%s\n",
                            $das->dsn->[0],
                            $segment_name,
                            $analysis_name ? ";type=$analysis_name" : '') );

    my $response = $das->features({
        'segment' => $segment_name,
        $analysis_name ? ('type' => $analysis_name) : (),
    });

    ## This is VERY useful for finding out some protocol pecularities/discrepancies:
    #
    if($dump) {
        die "The whole structure of the response is: '".Dumper($response)."'\n";
    }

    my $feature_coll; # collection(hash/array) of top-level features (prediction_transcripts | simple_features)

    foreach my $das_features (values %$response) {
        if(!$das_features || ref($das_features) ne 'ARRAY') {
            next;
        }

        FEATURE: while(my $das_feature = shift @$das_features) {

                # Filter out introns and other features that may be sent by the server but irrelevant for us:
            if($sieve) {
                my $sieve_field = struct_traverse_path($das_feature, $sieve_field_path);
                if( (($sieve_sign eq '--CONTAINS--') && ($sieve_field!~/$sieve_value/i)) # wanted to include it, but it's not here
                 || (($sieve_sign eq '--LACKS--') && ($sieve_field=~/$sieve_value/i)) # wanted to exclude it, but it's here
                ) {
                    next FEATURE;
                }
            }

            # warn "DAS_feature = ".Dumper($das_feature)."\n";

            my $pt_label;

            if($grouplabel_field_path) {
                $pt_label = struct_traverse_path($das_feature, $grouplabel_field_path) || 'NONAME?';
            } else {
                warn "Trying to guess a fitting group/label path:\n";
                my $show_path;
                CANDIDATE: foreach my $path (@paths_to_try) {
                    $show_path = struct_show_path($das_feature, $path);
                    if(defined($pt_label = struct_traverse_path($das_feature, $path))) {
                        $grouplabel_field_path = $path; # by doing this we also ensure we only run this experiment once
                        warn "Trying $show_path - seems suitable\n";
                        last CANDIDATE;
                    } else {
                        warn "Trying $show_path - not suitable\n";
                    }
                }
                if(defined $pt_label) {
                    warn "After much deliberation the following group/label path was selected: $show_path\n";
                } else {
                    die "Could not guess a fitting group/label path, please specify it in the 'grouplabel=' parameter of the filter";
                }
            }

            my $feature = $feature_constructor->new();

            $feature->slice(   $slice );
            $feature->start(   $das_feature->{'start'} - $chr_start + 1 );
            $feature->end(     $das_feature->{'end'}   - $chr_start + 1 );
            $feature->strand( ($das_feature->{'orientation'} =~ /^-/ ) ? -1 : 1 );
            if($feature->can('score')) {
                    ## should we fake the value when it is not available? :
                my $score = $das_feature->{'score'} || '-';
                $feature->score(  ($score eq '-') ? 100 : $score );
            }

            if($parent_constructor) {
                my $parent_feature = $feature_coll->{$pt_label} ||= $parent_constructor->new( -dbID => $pt_label, -slice => $slice );

                eval {
                    warn "adding feature with start=".$feature->start()." and end=".$feature->end()."\n";
                    $parent_feature->$add_sub($feature);
                };
                ## there may be a collision of exons - just ignore it for the moment
                if($@) {
                    warn "Could not group feature: $@\n";
                }
            } else {
                $feature->display_label( $pt_label );
                push @$feature_coll, $feature;
            }
        }
    }

    return (ref($feature_coll) eq 'HASH') ? [ values %$feature_coll ] : $feature_coll;
}


my $server = Bio::Otter::ServerScriptSupport->new;

my $output_string = '';

eval {
    my $chr_name      = $server->param('name');  ## Since in our new schema name is substituted for type,
                                                 ## we need it clean for outer sources

    my $source        = $server->param('source'); # let's slowly phase it out
    my $dsn           = $server->require_argument('dsn');
    my $analysis_name = $server->param('analysis'); # defaults to *everything*
    my $kind          = $server->param('kind')  || 'SimpleFeature';
    my $sieve         = $server->param('sieve') || '';
    my $grouplabel    = $server->param('grouplabel') || '';
    my $dump          = $server->param('dump') || 0;

    my $das = Bio::Das::Lite->new({
        'dsn' => $source ? $source.'/'.$dsn : $dsn,
        $http_proxy ? ('http_proxy' => $http_proxy) : (),
    });

    my $feature_array = $server->fetch_mapped_features('das_'.$kind, 'get_all_features_via_DAS', [$server, $das, $chr_name, $analysis_name, $kind, $sieve, $grouplabel, $dump],
        (map { defined($server->param($_)) ? $server->param($_) : '' } qw(cs name type start end metakey csver csver_remote)),
        1, # do the short version of mapping, without the target database
    );

    $output_string = GenerateFeatures($feature_array, $analysis_name);
};

if ($@) {
    $server->error_exit($@);
} else {
    $server->send_response($output_string, 1);
}

1;

