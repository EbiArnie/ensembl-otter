#!/usr/local/bin/perl -Tw

# Author:        lg4
# Group:         anacode
# Maintainer:    jgrg
# Last modified: $Date: 2008-07-11 11:20:57 $
# Id:            $Id: nph-get_das_prediction_transcripts,v 1.6 2008-07-11 11:20:57 lg4 Exp $
# Source:        $Source: /tmp/ENSCOPY-ENSEMBL-OTTER/scripts/apache/Attic/nph-get_das_prediction_transcripts,v $

use strict;
use SangerPaths qw{ core bioperl123 ensembl49 otter50 };

my $http_proxy = $ENV{http_proxy};

use Data::Dumper;
use Bio::Das::Lite;
use Bio::EnsEMBL::PredictionExon;
use Bio::EnsEMBL::PredictionTranscript;
use Bio::Otter::ServerScriptSupport;
use Bio::Otter::Lace::ViaText ('&GenerateFeatures');

sub Bio::EnsEMBL::Slice::get_all_PredictionTranscripts_via_DAS {
    my ($slice, $server, $das, $chr_name, $analysis_name) = @_;

    my $chr_start = $slice->start();
    my $chr_end   = $slice->end();
    my $segment_name  = "$chr_name:$chr_start,$chr_end";

    # DAS servers will give all features if a "type=" argument is not present
    if ($analysis_name and $analysis_name eq 'all') {
        $analysis_name = undef;
    }

    $server->log( sprintf ("GET  %s/features?segment=%s%s\n",
                            #$das->default_url,
                            $das->dsn->[0],
                            $segment_name,
                            $analysis_name ? ";type=$analysis_name" : '') );

    my $response = $das->features({
        'segment' => $segment_name,
        $analysis_name ? ('type' => $analysis_name) : (),
    });

    ## This is VERY useful for finding out some protocol discrepancies:
    #
    # die "The whole structure of the response is: '".Dumper($response)."'\n";

    my %dpts = (); # hash of prediction_transcripts

    foreach my $das_features (values %$response) {
        if(!$das_features || ref($das_features) ne 'ARRAY') {
            next;
        }

        FEATURE: while(my $das_feature = shift @$das_features) {

                # Filter out introns and other irrelevant features HERE!
                # maybe we should leave this as an option (as a property of misbehaving DAS sources)?
            next FEATURE unless($das_feature->{'type_id'} =~ /exon/i);

            my $prediction_exon = Bio::EnsEMBL::PredictionExon->new();
            $prediction_exon->slice(   $slice );

            $prediction_exon->start(   $das_feature->{'start'} - $chr_start + 1 );
            $prediction_exon->end(     $das_feature->{'end'}   - $chr_start + 1 );
            $prediction_exon->strand( ($das_feature->{'orientation'} =~ /^-/ ) ? -1 : 1 );
            $prediction_exon->score(  ($das_feature->{'score'} eq '-') ? 100 : $das_feature->{'score'} );
                ## should we fake it if it's not available anyway?

                # the field used for grouping exons together in the order of preference:
                #
            my $pt_label = 
                           ($das_feature->{'group'} && $das_feature->{'group'}[0]
                                   && (  $das_feature->{'group'}[0]{'group_label'}
                                      || $das_feature->{'group'}[0]{'group_id'} ) )
                         || $das_feature->{'feature_label'}
                         || $das_feature->{'feature_id'};

            #               $das_feature->group_label()
            #            || $das_feature->group()
            #            || $das_feature->label()
            #            || $das_feature->id();

            warn "DAS_feature = ".join(',', map { " '$_' => '".$das_feature->{$_}."' " } keys %$das_feature)."\n";
            my $pt_label =     $das_feature->{'feature_label'};

            my $pt = $dpts{$pt_label} ||= Bio::EnsEMBL::PredictionTranscript->new( -dbID => $pt_label );

            $pt->add_Exon($prediction_exon);
        }
    }

    return [ values %dpts ];
}


my $server = Bio::Otter::ServerScriptSupport->new;

my $output_string = '';

eval {
    my $chr_name      = $server->param('name');  ## Since in our new schema name is substituted for type,
                                                 ## we need it clean for outer sources

    my $source        = $server->require_argument('source');
    my $dsn           = $server->require_argument('dsn');
    my $analysis_name = $server->param('analysis'); # defaults to *everything*

    my $das = Bio::Das::Lite->new({
        'dsn' => $source.'/'.$dsn,
        # $http_proxy ? ('http_proxy' => '$http_proxy') : (),
    });

    my $dpts = $server->fetch_mapped_features('das_prediction_transcript', 'get_all_PredictionTranscripts_via_DAS', [$server, $das, $chr_name, $analysis_name],
        (map { defined($server->param($_)) ? $server->param($_) : '' } qw(cs name type start end metakey csver csver_remote)),
        1, # do the short version of mapping, without the target database
    );

    $output_string = GenerateFeatures($dpts, $analysis_name);
};

if ($@) {
    $server->error_exit($@);
} else {
    $server->send_response($output_string, 1);
}

1;

