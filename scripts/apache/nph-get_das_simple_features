#!/usr/local/bin/perl -Tw

# Author:        jgrg
# Group:         anacode
# Maintainer:    jgrg
# Last modified: $Date: 2008-05-28 17:21:11 $
# Id:            $Id: nph-get_das_simple_features,v 1.19 2008-05-28 17:21:11 lg4 Exp $
# Source:        $Source: /tmp/ENSCOPY-ENSEMBL-OTTER/scripts/apache/Attic/nph-get_das_simple_features,v $

my $http_proxy = $ENV{http_proxy};

use strict;
use SangerPaths qw{ core bioperl123 ensembl49 otter49 };

use Bio::Das;
use Bio::EnsEMBL::SimpleFeature;
use Bio::Otter::ServerScriptSupport;
use Bio::Otter::Lace::ViaText::ToText ('&GenerateSimpleFeatures');

sub Bio::EnsEMBL::Slice::get_all_DasFeatures {
    my ($slice, $server, $das, $chr_name, $analysis_name) = @_;

    my $chr_start = $slice->start();
    my $chr_end   = $slice->end();
    my $segment_name  = "$chr_name:$chr_start,$chr_end";

    # DAS servers will give all features if a "type=" argument is not present
    if ($analysis_name and $analysis_name eq 'all') {
        $analysis_name = undef;
    }

    $server->log( sprintf ("GET  %s/features?segment=%s%s\n",
                            $das->default_url, $segment_name,
                            $analysis_name ? ";type=$analysis_name" : '') );

    my $segment = $das->segment($chr_name, $chr_start, $chr_end);
    unless($segment) {
        $server->log( "DAS source refused to serve the segment={$segment_name}");
        return [];
    }  

    my @feature_type  = $analysis_name ? ('-type' => $analysis_name) : ();
    my $iterator = $segment->features(-iterator => 1, @feature_type);

    my @dsfs = ();
    while (my $das_feature = $iterator->next_seq) {
        my $simple_feature = Bio::EnsEMBL::SimpleFeature->new();
        $simple_feature->slice(   $slice );
        $simple_feature->start(   $das_feature->start() - $chr_start + 1 );
        $simple_feature->end(     $das_feature->stop()  - $chr_start + 1 );
        $simple_feature->strand( ($das_feature->orientation() eq '-') ? -1 : 1 );
        $simple_feature->score(  ($das_feature->score() eq '-') ? 100 : $das_feature->score() );
        $simple_feature->display_label( $das_feature->id() );

        push @dsfs, $simple_feature;
    }

    return \@dsfs;
}


my $server = Bio::Otter::ServerScriptSupport->new;

my $chr_name = $server->param('name');  ## Since in our new schema name is substituted for type,
                                     ## we need it clean for outer sources

my $source        = $server->require_argument('source');
my $dsn           = $server->require_argument('dsn');
my $analysis_name = $server->param('analysis'); # defaults to *everything*

my $das = Bio::Das->new(
    -source => $source,
    -dsn    => $dsn,
);
$das->proxy($http_proxy) if $http_proxy;

my $dsfs = $server->fetch_mapped_features('das_simple_feature', 'get_all_DasFeatures', [$server, $das, $chr_name, $analysis_name],
    (map { defined($server->param($_)) ? $server->param($_) : '' } qw(cs name type start end metakey csver csver_remote)),
    1, # do the short version of mapping, without the target database
);

my $output_string = GenerateSimpleFeatures($dsfs, $analysis_name);

$server->send_response($output_string, 1);

1;

