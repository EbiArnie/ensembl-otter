#!/usr/local/bin/perl -Tw

# Author:        gr5
# Group:         anacode
# Maintainer:    gr5

use strict;
use SangerPaths qw{ core bioperl123 ensembl51 otter52 };

use Bio::Otter::ServerScriptSupport;
use Bio::Otter::DBSQL::SimpleBindingAdaptor;
use Bio::Otter::Lace::ViaText qw( %LangDesc &GenerateFeatures );

use CGI::Carp 'fatalsToBrowser';

my $server       = Bio::Otter::ServerScriptSupport->new;

sub enrich {
    my ($afs, $enriched_class) = @_;

        # Put the names into the hit_description hash:
    my %hd_hash = ();
    foreach my $af (@$afs) {
        $hd_hash{$af->hseqname()} = '';
    }

        # Fetch the hit descriptions from the pipeline
    my $pdbc = $server->satellite_dba( '' )->dbc();
    my $hd_adaptor = Bio::Otter::DBSQL::SimpleBindingAdaptor->new( $pdbc );
    $hd_adaptor->fetch_into_hash(
        'hit_description',
        'hit_name',
        { qw(
            hit_name _hit_name
            hit_length _hit_length
            hit_description _description
            hit_taxon _taxon_id
            hit_db _db_name
        )},
        'Bio::Otter::HitDescription',
        \%hd_hash,
    );

    foreach my $af (@$afs) {
        if(my $hd = $hd_hash{$af->hseqname()}) {
            bless $af, $enriched_class;
            $af->{'_hit_description'} = $hd;
        }
    }

    return $afs;
}

    # It is a coincidence that these two classed need to be enriched
    # and their fetching methods in Bio::EnsEMBL::Slice are differently named.
    # We are making use of this coincidence by enriching the methods without subclassing Bio::EnsEMBL::Slice :
    #
sub Bio::EnsEMBL::Slice::get_all_DnaDnaAlignFeatures {
    my $self = shift @_;
    my $naked_features = $self->get_all_DnaAlignFeatures(@_);
    return enrich($naked_features, 'Bio::Otter::DnaDnaAlignFeature');
}

sub Bio::EnsEMBL::Slice::get_all_DnaPepAlignFeatures {
    my $self = shift @_;
    my $naked_features = $self->get_all_ProteinAlignFeatures(@_);
    return enrich($naked_features, 'Bio::Otter::DnaPepAlignFeature');
}

# insert some to_gff methods into the necessary feature classes

sub Bio::EnsEMBL::FeaturePair::to_gff {
	
	my $self = shift;
	
	my @fps = $self->ungapped_features;
	
	my $gap_string = '';
	
	if (@fps > 1) {
		my @gaps = map { join(' ', $_->hstart, $_->hend, $_->start, $_->end) } @fps;
		$gap_string = join(',', @gaps);
	}
	
	my $gff = join (
		' ',
		$self->slice->seq_region_name,
		$self->analysis->logic_name,
		'similarity',
		$self->start,
		$self->end,
		$self->percent_id,
		($self->strand ? '+' : '-'),
		'.',
		'Target "'.$self->hseqname.'"',
		$self->hstart,
		$self->hend,
		';',
		'Clone "'.$self->seqname.'"',
		';',
		($gap_string ? 'Gaps "'.$gap_string.'" ; ' : ''),
		'Length',
		$self->get_HitDescription->hit_length,
	);
	
	return $gff;
}

sub Bio::EnsEMBL::SimpleFeature::to_gff {
	my $self = shift;
	
	my $gff = join (
		' ',
		$self->slice->seq_region_name,
		$self->analysis->logic_name,
		'misc_feature',
		$self->start,
		$self->end,
		$self->score,
		($self->strand ? '+' : '-'),
		'.',
	);
	
	return $gff;
}

sub get_features {
	
}

my $gff_string = '';

eval {
    my @feature_kinds  = split(/,/, $server->require_argument('kind'));
    my $analysis_list = $server->param('analysis');
    my @analysis_names = $analysis_list ? split /,/ , $analysis_list : ( undef );

	foreach my $analysis_name (@analysis_names) {
	    foreach my $feature_kind (@feature_kinds) {
	        my $param_descs = $LangDesc{$feature_kind}{-call_args};
	        my $getter_method = "get_all_${feature_kind}s";

	        my @param_list = ();
	        foreach my $param_desc (@$param_descs) {
	            my ($param_name, $param_def_value, $param_separator) = @$param_desc;

	            my $param_value = (scalar(@$param_desc)==1)
	                ? $server->require_argument($param_name)
	                : defined($server->param($param_name))
	                    ? $server->param($param_name)
	                    : $param_def_value;
	            if($param_value && $param_separator) {
	                $param_value = [split(/$param_separator/,$param_value)];
	            }
				$param_value = $analysis_name if $param_value =~ /$analysis_name/;
	            push @param_list, $param_value;
	        }

	        my $features = $server->fetch_mapped_features($feature_kind, $getter_method, \@param_list,
	            map { defined($server->param($_)) ? $server->param($_) : '' }
	                qw(cs name type start end metakey csver csver_remote)
	        );
			
			if (!$gff_string) {
				# we need to add the gff header
				
				# build the date string in the correct format
				
				my ($sec, $min, $hr, $mday, $mon, $year) = localtime;
				$year += 1900; # correct the year
				$mon++; # months start at 0
				my $date = "$year-$mon-$mday";
				
				# use the first feature's slice as the sequence-region
				
				my $slice = $features->[0]->slice;
				
				$gff_string = "##gff-version 2\n".
							  "##source-version nph-get_gff_features 1.0\n".
							  "##date $date\n".
							  "##sequence-region ".$slice->seq_region_name." ".
							  $slice->start." ".$slice->end."\n";
			}
		
			for my $feature (@$features) {
				if ($feature->can('to_gff')) {
					$gff_string .= $feature->to_gff."\n";
				}
			}
	    }
	}
};

if ($@) {
    $server->error_exit($@);
} else {
    $server->send_response($gff_string);
}

1;

