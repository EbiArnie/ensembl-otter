#!/usr/local/bin/perl -Tw

# Author:        jgrg
# Group:         anacode
# Maintainer:    jgrg
# Last modified: $Date: 2008-02-05 17:35:29 $
# Id:            $Id: nph-get_tiling_and_seq,v 1.6 2008-02-05 17:35:29 jgrg Exp $
# Source:        $Source: /tmp/ENSCOPY-ENSEMBL-OTTER/scripts/apache/Attic/nph-get_tiling_and_seq,v $

use strict;
use SangerPaths qw{ core bioperl123 ensembl46 otter49 };

use Bio::Otter::ServerScriptSupport;

my $server = Bio::Otter::ServerScriptSupport->new;

my $cs         = $server->param('cs')     || 'chromosome';
my $csver      = $server->param('csver')  || (($cs eq 'chromosome') ? 'Otter' : undef);
my $name       = $server->require_argument('name');
my $type       = $server->require_argument('type');
my $start      = $server->param('start');
my $end        = $server->param('end');
my $strand     = $server->param('strand') || undef;

my $metakey    = $server->param('metakey')   || ''; # defaults to pipeline, but can be '.' or something else
my $dna_wanted = $server->param('dnawanted') || 0;

my $sdba  = $server->satellite_dba( $metakey );
my $slice = $server->get_slice($sdba, $cs, $name, $type, $start, $end, $strand, $csver);

my $output_string = '';

if($server->running_headcode()) {

    my $attribute_adaptor = $sdba->get_AttributeAdaptor();

    foreach my $tile (@{ $slice->project('clone') }) {

        my $proj_slice = $tile->to_Slice();
        my $clone = $proj_slice->seq_region_Slice();

        my ($embl_acc, $embl_version, $intl_clone_name);

        for my $attrib (@{ $attribute_adaptor->fetch_all_by_Slice( $clone ) }) {
            my ($code, $value) = ($attrib->code(), $attrib->value());
            if($code eq 'embl_acc') {
                $embl_acc  = $value;
            } elsif($code eq 'embl_version') {
                $embl_version  = $value;
            } elsif($code eq 'intl_clone_name') {
                $intl_clone_name  = $value;
            }
        }

        my $clone_name   = $clone->seq_region_name();
        my $clone_length = $clone->length();
        my $contig_name  = $clone_name.'.1.'.$clone_length; # assuming it always has the same structure

        $intl_clone_name ||= $clone_name; # if not defined

        $output_string .= join("\t",
            $embl_acc,
            $embl_version,
            $intl_clone_name,
            $contig_name,

            $name,
            $type,

            $tile->from_start(),
            $tile->from_end(),

            $proj_slice->start(),
            $proj_slice->end(),
            $proj_slice->strand(),

            $clone->length(),

            $dna_wanted ? ($clone->seq()) : (),
            "\n"
        );
    }
} else {
    foreach my $tile (@{ $slice->get_tiling_path }) {
        if(my $clone = $tile->component_Seq->clone) {
            $output_string .= join("\t",
                $clone->embl_id(),
                $clone->embl_version(),
                $clone->id(), # international clone name
                $tile->component_Seq()->name(), # contig name

                $tile->assembled_Seq()->chr_name(),
                $tile->assembled_Seq()->assembly_type(),
                $tile->assembled_start(),
                $tile->assembled_end(),

                $tile->component_start(),
                $tile->component_end(),
                $tile->component_ori(),
                length($tile->component_Seq()->seq()),

                $dna_wanted ? ($tile->component_Seq()->seq()) : (),
                "\n"
            );
        }
    } # foreach $tile
} # if($running_headcode) else...

$server->send_response($output_string, 1);

1;

