#!/usr/bin/perl -Tw

# Author:        jgrg
# Group:         anacode
# Maintainer:    jgrg

use strict;
use warnings;

BEGIN { use lib ($ENV{OTTER_PERL_INC} || q{}) =~ m{([^:]+)}g }
use SangerPaths qw{ core bioperl123 ensembl65 otter67 humpub };

use DBI;
use YAML 'Dump';
use File::Find;

use Bio::Otter::ServerScriptSupport;


# keep the align-to-centre layout, it's easier to read than YAML
sub hash2table {
    my ($hashref) = @_;
    my $out;
    foreach my $var (sort keys %$hashref) {
        $out .= sprintf "%35s  %s\n", $var,
          defined $hashref->{$var} ? $hashref->{$var} : '(undef)';
    }
    return $out;
}

# load all our modules, and their deps
sub require_all {
    my $dir = $INC{'Bio/Otter/ServerScriptSupport.pm'};
    $dir =~ s{Otter/\w+\.pm$}{};

    # some modules need a clean PATH
    $ENV{PATH} = '/bin:/usr/bin';

    my @mods;
    my $wanted = sub {
        if (-f && m{.*/(modules|\d+)/(Bio/.*)\.pm$}) {
            my $modfn = $2; # untainted
            $modfn =~ s{/}{::}g;
            push @mods, $modfn;
        }
        return ();
    };
    find({ wanted => $wanted, no_chdir => 1 }, $dir);

    my %out;
    foreach my $mod (@mods) {
        if (eval "require $mod;") { ## no critic(BuiltinFunctions::ProhibitStringyEval)
            push @{ $out{loaded} }, $mod;
        } else {
            my $err = $@;
            $err =~ s{ \(\@INC contains: [^()]+\) at }{... at };
            $out{error}->{$mod} = $err;
        }
    }

    return \%out;
}

sub _is_SangerWeb_real {
    my $src = $INC{'SangerWeb.pm'};
    if (!defined $src) {
        return 'None (?!)';
    } elsif (SangerWeb->can('is_dev') && $SangerWeb::VERSION) {
        return "Genuine $SangerWeb::VERSION from $src";
    } else {
        return "Bogus from $src";
    }
}


sub test {
    my ($server) = @_;

    my $web = $server->sangerweb;

    my $user = $web->username;

    my %out = (ENV => hash2table(\%ENV),
               CGI_param => '');

    foreach my $var ($server->param) {
        $out{CGI_param} .= sprintf "%24s  %s\n", $var, $server->param($var);
    }

    # avoiding exposing internals (private or verbose)
    my $cgi = $web->cgi;
    $out{SangerWeb} = { cgi => "$cgi",
                        origin => _is_SangerWeb_real(),
                        HTTP_CLIENTREALM => $ENV{HTTP_CLIENTREALM},
                        username =>  $web->username };
    $out{ServerScriptSupport} =
      { local_user => $server->local_user,
#        BOSSS => $server, # would leak users config & CGI internals
        internal_user => $server->internal_user };

    my $dbh = eval {
        DBI->connect("DBI:mysql:database=pipe_human;host=otp1slave;port=3322",
                     "ottro", undef,
                     { RaiseError => 1 });
    };
    $out{DBI} = $dbh ? { connected => "$dbh" } : { error => $@ };


    if ($server->param('load')) {
        $out{load_modules} = require_all();
    }

    if ($server->param('more')) {
        $out{Perl} =
          { '$^X' => $^X, '$]' => $], '${^TAINT}' => ${^TAINT},
            '@INC' => \@INC, '%INC' => hash2table(\%INC),
          };
    }

    return $server->local_user ? Dump(\%out) : "You are an external user\n";
}

Bio::Otter::ServerScriptSupport->send_response(\&test);
