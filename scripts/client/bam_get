#!/usr/bin/env perl

use strict;
use warnings;

package Bio::Otter::GetScript::BAM;

use base 'Bio::Otter::Utils::GetScript';

sub version      { return 'bam_get 0.6'; }
sub log_filename { return 'gff_log.txt'; }

my $LOG = 1;

use Bio::Otter::Log::Log4perl qw(:easy);
use URI::Escape qw(uri_unescape);

use Bio::DB::Sam;
use Bio::DB::Sam::Constants qw(RFLAGS);

use Bio::Otter::Lace::Defaults;
use Bio::Otter::Fetch::BAM;
use Bio::Otter::Mapping;
use Bio::Vega::Utils::GFF;

# variables used by _print_feature()
my ($gff_seqname, $gff_source, $gff_format, $fasta);

sub do_it {
    my ($self) = @_;

    my $args = $self->args;
    $gff_seqname = $args->{'gff_seqname'} || $args->{'chr'};
    $gff_source  = $args->{'zmap_style'} || $args->{'gff_source'};
    my $gff_version = $args->{'gff_version'} || 3;
    $gff_format = Bio::Vega::Utils::GFF::gff_format($gff_version);

    my ($file, $dataset, $csver_remote, $chr, $start, $end) =
        $self->read_args(qw{ file dataset csver chr start end });

    my $sam = Bio::DB::Sam->new(
        -bam        => $file,
        -autoindex  => 0,   # Does setting this to zero trigger an error on calling bam_index if there is no .bai?
    );

    # Get list of chromosomes so that a failure is triggered before GFF header is printed.
    $sam->bam_index;
    # print STDERR "Header: ", $sam->header->text, "\n";

    my $bam_fetch = Bio::Otter::Fetch::BAM->new(-sam => $sam);
    my $mapping = $self->get_mapping;

    # map and print the features
    print "##gff-version $gff_version\n";
    $mapping->do_features($bam_fetch, $start, $end, \&_print_feature);
    if ($fasta) {
        print "##FASTA\n", $fasta;
        $fasta = '';
    }
}

# CIGAR commands
my %clip_command  = map { $_ => 1 } qw( H S ); # these clip
my %query_command = map { $_ => 1 } qw( M I ); # these contribute to the query sequence of the match
my $paired_flag = RFLAGS->{'PAIRED'};

sub _print_feature {
    my ($feature, $fstart, $fend) = @_;

    my $source = $gff_source || $feature->source_tag;
    my ($score) = $feature->get_tag_values('AS');

    my $strand = '+';

    # $feature->query->{start,end} are buggy when there is hard
    # clipping (CIGAR command 'H'), see
    # https://github.com/GMOD/GBrowse-Adaptors/issues/4 , so we
    # calculate $start and $end from the CIGAR ourselves

    my @cigar = @{$feature->cigar_array};
    while ($cigar[0][0] eq 'H') { shift @cigar } # skip hard clipping
    my $soft_clip = 0;
    while ($cigar[0][0] eq 'S') { $soft_clip += $cigar[0][1]; shift @cigar }
    my $q_start = $soft_clip + 1;
    my $q_end = $soft_clip;
    for (@cigar) {
        my ($command, $arg) = @{$_};
        last if $clip_command{$command};
        $q_end += $arg if $query_command{$command};
    }

    my @target_fields = ( $feature->name, $q_start, $q_end, $strand );

    my $flags = join ' ', $feature->get_tag_values('FLAGS');

    my $attribute_hash = {
        Name       => $feature->name,
        length     => $feature->l_qseq,
        cigar_bam  => $feature->cigar_str,
        bam_flags  => $flags,
        Target     => \ @target_fields,
        sequence   => $feature->qseq,
    };
    if ($feature->flag & $paired_flag) {
       $attribute_hash->{'ID'} = $feature->display_name;
    }

    my $phase = $feature->phase;

    print $gff_format->gff_line(
        $gff_seqname, $source, 'nucleotide_match',
        $fstart, $fend, $score, $strand, $phase,
        $attribute_hash);

    # if (my $seq = $feature->qseq) {
    #     $fasta .= '>' . $feature->name . "\n";
    #     while ($seq =~ /(.{1,60})/g) {
    #         $fasta .= $1 . "\n";
    #     }
    # }

    return;
}

## no critic (Modules::ProhibitMultiplePackages)

package main;

use Log::Log4perl::Level;

Bio::Otter::GetScript::BAM
    ->new(log4perl => $DEBUG)
    ->run;

exit;


__END__

=head1 AUTHOR

Ana Code B<email> anacode@sanger.ac.uk

