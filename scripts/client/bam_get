#!/usr/bin/env perl

use strict;
use warnings;

use Log::Log4perl qw(:easy);
use URI::Escape qw(uri_unescape);

use Bio::DB::Sam;
use Bio::DB::Sam::Constants qw(RFLAGS);

use Bio::Otter::Lace::Defaults;
use Bio::Otter::Fetch::BAM;
use Bio::Otter::Mapping;
use Bio::Vega::Utils::GFF;

my $paired_flag = RFLAGS->{'PAIRED'};

# parse the command line

my $options = {
    gff_version => 3,
};

my @options_specs = qw(
    gff_version=s
    file=s
    csver_remote=s
    dataset=s
    chr=s
    start=i
    end=i
    gff_source=s
    gff_seqname=s
    version
    );

my @options_required = qw(
    file
    chr
    start
    end
    );

sub _key {
    my ($key) = m(^(.*?)(?:=|$));
    return $key;
}
sub _option {
    return ( $_, \$options->{_key()} );
}

sub show_version {
    print "bam_get 0.5\n";
    exit 0;
}

print STDERR "$0", ( map { " '$_'" } @ARGV ), "\n";

my @keys    = map { _key()    } @options_specs;
my @options = map { _option() } @options_specs;

Bio::Otter::Lace::Defaults::do_getopt(@options);
show_version() if $options->{version};

Log::Log4perl->easy_init({ level => $DEBUG,
                           layout => 'bam_get.%c %p: %m%n'
                         });

my @options_missing = grep { ! defined $options->{$_} } @options_required;
die sprintf "missing options: %s\n",
    join ', ', sort @options_missing
    if @options_missing;
$options->{$_} = uri_unescape($options->{$_}) for keys %{$options};
my (
    $gff_version,
    $file,
    $csver_remote,
    $dataset,
    $chr,
    $start,
    $end,
    $gff_source,
    $gff_seqname
    ) = @{$options}{@keys};

my $sam = Bio::DB::Sam->new
    (
     -bam   => $file,
     # -fasta => $fasta_path,
    );

my $bam_fetch = Bio::Otter::Fetch::BAM->new( -sam => $sam );
my $gff_format = Bio::Vega::Utils::GFF::gff_format($gff_version);

sub _print_header {
    print
        <<"GFF",
##gff-version $gff_version
GFF
;
    return;
}

# CIGAR commands
my %clip_command  = map { $_ => 1 } qw( H S ); # these clip
my %query_command = map { $_ => 1 } qw( M I ); # these contribute to the query sequence of the match

sub _print_feature {
    my ($feature, $fstart, $fend) = @_;

    my $seq_id = $gff_seqname || $chr;
    my $source = $gff_source || $feature->source_tag;
    my ($score) = $feature->get_tag_values('AS');

    my $strand = '+';

    # $feature->query->{start,end} are buggy when there is hard
    # clipping (CIGAR command 'H'), see
    # https://github.com/GMOD/GBrowse-Adaptors/issues/4 , so we
    # calculate $start and $end from the CIGAR ourselves

    my @cigar = @{$feature->cigar_array};
    while ($cigar[0][0] eq 'H') { shift @cigar } # skip hard clipping
    my $soft_clip = 0;
    while ($cigar[0][0] eq 'S') { $soft_clip += $cigar[0][1]; shift @cigar }
    my $q_start = $soft_clip + 1;
    my $q_end = $soft_clip;
    for (@cigar) {
        my ($command, $arg) = @{$_};
        last if $clip_command{$command};
        $q_end += $arg if $query_command{$command};
    }

    my @target_fields = ( $feature->name, $q_start, $q_end, $strand );

    my $flags = join ' ', $feature->get_tag_values('FLAGS');

    my $attribute_hash = {
        Name       => $feature->name,
        length     => $feature->l_qseq,
        cigar_bam  => $feature->cigar_str,
        bam_flags  => $flags,
        Target     => \ @target_fields,
        sequence   => $feature->qseq,
    };
    if ($feature->flag & $paired_flag) {
       $attribute_hash->{'ID'} = $feature->display_name;
    }

    my $phase = $feature->phase;

    print $gff_format->gff_line(
        $seq_id, $source, 'read',
        $fstart, $fend, $score, $strand, $phase,
        $attribute_hash);

    return;
}

my $mapping =
    Bio::Otter::Mapping->new_from_otter(
        $dataset, $csver_remote, $chr, $start, $end);

# map and print the features
_print_header;
$mapping->do_features($bam_fetch, $start, $end, \&_print_feature);

exit;

__END__

=head1 AUTHOR

Ana Code B<email> anacode@sanger.ac.uk

