#!/usr/bin/env perl

use strict;
use warnings;

use XML::Simple;
use URI::Escape qw(uri_unescape);

use Data::Dumper;

use Bio::Tools::GFF;
use Bio::DB::Sam;
use Bio::Otter::Lace::Defaults;

# my $fasta_path = q(/lustre/scratch102/projects/mouse/ref/NCBIM37_um.fa);

print STDERR "$0", ( map { " '$_'" } @ARGV ), "\n";

# parse the command line

my $options = {
    gff_version => 3,
};

my @options_specs = qw(
    gff_version=s
    bam_path=s
    bam_cs=s
    dataset=s
    chr=s
    start=i
    end=i
    gff_feature_source=s
    chr_prefix=s
    gff_seqname=s
    );

sub _key {
    my ($key) = m(^(.*?)=);
    return $key;
}
sub _option {
    return ( $_, \$options->{_key()} );
}

my @keys    = map { _key()    } @options_specs;
my @options = map { _option() } @options_specs;

Bio::Otter::Lace::Defaults::do_getopt(@options);
$options->{$_} = uri_unescape($options->{$_}) for keys %{$options};
my (
    $gff_version,
    $bam_path,
    $bam_cs,
    $dataset,
    $chr_local,
    $start_local,
    $end_local,
    $gff_feature_source,
    $chr_prefix,
    $gff_seqname
    ) = @{$options}{@keys};

sub get_features {
    my ($chr, $start, $end) = @_;

    my $sam = Bio::DB::Sam->new
        (
         -bam   => $bam_path,
         # -fasta => $fasta_path,
        );

    $chr = "${chr_prefix}${chr}" if defined $chr_prefix;
    my @read_pairs = $sam->get_features_by_location(
        -type   => 'read_pair',
        -seq_id => $chr,
        -start  => $start,
        -end    => $end,
        );
    warn sprintf "found %d read pairs\n", scalar @read_pairs;

    my $features = [ map { $_->get_SeqFeatures } @read_pairs ];

    return $features;
}

=pod

    my $sub_feature_counts = { };
for (@read_pairs) {

    # feature
    die "oof\n" unless ref eq "Bio::SeqFeature::Lite";
die "no sequence" unless defined $_->seq;
die sprintf "sequence: '%s'\n", $_->seq unless $_->seq eq '';
die "strand\n" if $_->strand;
die "phase\n" if $_->phase;

# subfeatures
my @sub_features = $_->get_SeqFeatures;
$sub_feature_counts->{scalar @sub_features}++;
for (@sub_features) {
    die "splat\n" unless ref eq "Bio::DB::Bam::AlignWrapper";
die "no sequence\n" unless defined $_->seq;
die sprintf "invalid sequence type: '%s'\n", ref $_->seq
    unless ref $_->seq eq "Bio::PrimarySeq";
die "no strand\n" unless $_->strand;
die "phase\n" if defined $_->phase;
}
}

for (sort { $a <=> $b } keys %{$sub_feature_counts}) {
    warn sprintf "%3d: %6d\n", $_, $sub_feature_counts->{$_};
}

=cut

sub gff_escape {
    # escapes a minimal set of characters
    s/([\t\r\n[:cntrl:];=%&])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_seqid {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_?|])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_source {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_? ])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_attribute {
    # like gff_escape, but escapes commas too
    s/([\t\r\n[:cntrl:];=%&,])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_target {
    # like gff_escape, but escapes commas and spaces too
    s/([\t\r\n[:cntrl:];=%&, ])/sprintf "%%%02X", ord($1)/eg;
    return;
}

my $chr_local_field = $chr_local;
gff_escape_seqid for $chr_local_field;

sub print_header {
    print
        <<"GFF",
##gff-version $gff_version
##sequence-region $chr_local $start_local $end_local
GFF
;
    return;
}

my $strands = {
    1  => '+',
    -1 => '-',
};

my $attributes_format = $gff_version == 3 ? '%s=%s' : '%s "%s"';

sub do_feature {

    my $name = $_->name;

    # the -gff_feature_source flag overrides the source from the BAM file
    my $source = $gff_feature_source || $_->source_tag;

    my ($score) = $_->get_tag_values('AS');

    my @fields =
        (
         'read',
         (sprintf "%d", $_->start),
         (sprintf "%d", $_->end),
         (defined $score ? (sprintf "%f", $score) : '.'),
         $strands->{$_->strand},
         $_->phase || '.',
        );

    # $_->cigar_str has the wrong format for the Gap tag
    # (eg. 76M instead of M76) so we have to build it from
    # $_->cigar_array (which, strangely, has the operator
    # and count arguments in the right order for the Gap tag even
    # though $_->cigar_str has them in the wrong order)

    my $gap = join ' ', map {
        ($_->[0] eq 'S') ? ( ) : ( join '', @{$_} );
    } @{$_->cigar_array};

    # the Target tag - escaping this requires special handling of
    # spaces in the query name

    my $query = $_->query;
    my $query_name = $query->name;
    gff_escape_target for $query_name;
    my $query_strand = $strands->{$query->strand};
    my @target_fields = ( $query->start, $query->end );
    push @target_fields, $query_strand if $query_strand;
    my $target .= join ' ', $query_name, @target_fields;

    my $dna = $query->dna;

    my @attributes = (
        Name     => [ $name   ],
        Gap      => [ $gap    ],
        Target   => [ $target ],
        sequence => [ $dna    ],
        );

    my @attribute_strings = ();
    while ( my ($key, $values) = splice(@attributes, 0, 2) ) {
        unless ($key eq 'Target') { # the Target tag is already escaped
            gff_escape_attribute for @{$values};
        }
        gff_escape_attribute for $key;
        push @attribute_strings, sprintf $attributes_format, $key, join ",", @{$values};
    }
    my $attributes_string = join ";", @attribute_strings;

    gff_escape_source for $source;
    gff_escape for @fields;
    printf "%s\n", join "\t"
        , $chr_local_field, $source, @fields, $attributes_string;

    return;
}

# get the mapping from the Otter server
my $client = Bio::Otter::Lace::Defaults::make_Client();
my $mapping_xml = $client->otter_response_content(
    'GET', 'get_mapping', {
        dataset => $dataset,
        chr     => $chr_local,
        cs      => $bam_cs,
    });
my $mapping =
    XMLin($mapping_xml,
          ForceArray => [ qw(
                      ) ],
          KeyAttr => {
          },
    );
die "failed to fetch a mapping" unless $mapping;
# warn Dumper($mapping);

# unpack the mapping
my $type = $mapping->{type};
die "missing mapping type" unless $type;

if ($type eq 'none') {
    die "there is no mapping";
}
elsif ($type eq 'equiv') {
    my $chr_remote = $mapping->{equiv_chr};
    die "missing equivalent chr" unless $chr_remote;
    print_header;
    do_feature for @{get_features($chr_remote, $start_local, $end_local)};
}
else {
    die "invalid mapping type '${type}'";
}
