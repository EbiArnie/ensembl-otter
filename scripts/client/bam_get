#!/usr/bin/env perl

use strict;
use warnings;

use URI::Escape qw(uri_unescape);

use Bio::DB::Sam;
use Bio::Otter::Lace::Defaults;
use Bio::Otter::Fetch::BAM;
use Bio::Otter::Mapping;
use Bio::Vega::Utils::GFF;

# parse the command line

my $options = {
    gff_version => 3,
};

my @options_specs = qw(
    gff_version=s
    file=s
    csver=s
    dataset=s
    chr=s
    start=i
    end=i
    gff_feature_source=s
    gff_seqname=s
    version
    );

my @options_required = qw(
    file
    csver
    dataset
    chr
    start
    end
    );

sub _key {
    my ($key) = m(^(.*?)(?:=|$));
    return $key;
}
sub _option {
    return ( $_, \$options->{_key()} );
}

sub show_version {
    print "bam_get 0.5\n";
    exit 0;
}

my @keys    = map { _key()    } @options_specs;
my @options = map { _option() } @options_specs;

my @old_ARGV = @ARGV;
Bio::Otter::Lace::Defaults::do_getopt(@options);
show_version() if $options->{version};
print STDERR "$0", ( map { " '$_'" } @old_ARGV ), "\n";

my @options_missing = grep { ! defined $options->{$_} } @options_required;
die sprintf "missing options: %s\n",
    join ', ', sort @options_missing
    if @options_missing;
$options->{$_} = uri_unescape($options->{$_}) for keys %{$options};
my (
    $gff_version,
    $file,
    $csver,
    $dataset,
    $chr,
    $start,
    $end,
    $gff_feature_source,
    $gff_seqname
    ) = @{$options}{@keys};

my $sam = Bio::DB::Sam->new
    (
     -bam   => $file,
     # -fasta => $fasta_path,
    );

my $bam_fetch = Bio::Otter::Fetch::BAM->new( -sam => $sam );
my $gff_format = Bio::Vega::Utils::GFF::gff_format($gff_version);

sub _print_header {
    print
        <<"GFF",
##gff-version $gff_version
##sequence-region $chr $start $end
GFF
;
    return;
}

sub _print_feature {
    my ($feature, $start, $end) = @_;

    # the -gff_feature_source flag overrides the source from the BAM file
    my $source = $gff_feature_source || $feature->source_tag;
    my ($score) = $feature->get_tag_values('AS');
    my $query = $feature->query;

    my $strand = '+';
    my @align_fields = ( $query->start, $query->end, $strand );
    my @target_fields = ( $query->name, $query->start, $query->end, $strand );

    # $feature->cigar_str has the wrong format for the Gap tag
    # (eg. 76M instead of M76) so we have to build it from
    # $feature->cigar_array (which, strangely, has the operator
    # and count arguments in the right order for the Gap tag even
    # though $feature->cigar_str has them in the wrong order)

    my @gap = map {
        ($_->[0] eq 'S') ? ( ) : ( join '', @{$_} );
    } @{$feature->cigar_array};

    my $attribute_hash = {
        Class      => 'Sequence',
        Name       => $feature->name,
        Align      => \ @align_fields,
        Length     => $feature->l_qseq,
        Gap        => join(' ', @gap),
        Target     => \ @target_fields,
        sequence   => $query->seq->seq,
    };

    # only add "cigar_bam" if the alignment is gapped
    my $cigar_bam = $feature->cigar_str;
    $attribute_hash->{'cigar_bam'} = $cigar_bam
        if $cigar_bam =~ /M.*M/;

    my $phase = $feature->phase;

    print $gff_format->gff_line(
        $chr, $source, 'read',
        $start, $end, $score, $strand, $phase,
        $attribute_hash);

    return;
}

# get the mapping from the Otter server
my $client = Bio::Otter::Lace::Defaults::make_Client();
my $mapping_xml = $client->otter_response_content(
    'GET', 'get_mapping', {
        dataset => $dataset,
        cs      => $csver,
        chr     => $chr,
        start   => $start,
        end     => $end,
    });
my $mapping = Bio::Otter::Mapping->new_from_xml($mapping_xml);

# map and print the features
_print_header;
$mapping->do_features($bam_fetch, $start, $end, \&_print_feature);
