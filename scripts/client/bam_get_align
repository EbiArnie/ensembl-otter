#!/usr/bin/env perl

use strict;
use warnings;

use URI::Escape qw(uri_unescape);

use Bio::DB::Sam;
use Bio::Otter::Lace::Defaults;
use Bio::Otter::Fetch::BAM;
use Bio::Otter::Mapping;

print STDERR "$0", ( map { " '$_'" } @ARGV ), "\n";

# parse the command line

my $options = {
    gff_version => 3,
};

my @options_specs = qw(
    gff_version=s
    file=s
    csver=s
    dataset=s
    chr=s
    start=i
    end=i
    gff_feature_source=s
    gff_seqname=s
    );

my @options_required = qw(
    file
    csver
    dataset
    chr
    start
    end
    );

sub _key {
    my ($key) = m(^(.*?)=);
    return $key;
}
sub _option {
    return ( $_, \$options->{_key()} );
}

my @keys    = map { _key()    } @options_specs;
my @options = map { _option() } @options_specs;

Bio::Otter::Lace::Defaults::do_getopt(@options);
my @options_missing = grep { ! defined $options->{$_} } @options_required;
die sprintf "missing options: %s\n",
    join ', ', sort @options_missing
    if @options_missing;
$options->{$_} = uri_unescape($options->{$_}) for keys %{$options};
my (
    $gff_version,
    $file,
    $csver,
    $dataset,
    $chr,
    $start,
    $end,
    $gff_feature_source,
    $gff_seqname
    ) = @{$options}{@keys};

my $sam = Bio::DB::Sam->new
    (
     -bam   => $file,
     # -fasta => $fasta_path,
    );

my $bam_fetch = Bio::Otter::Fetch::BAM->new( -sam => $sam );

sub gff_escape {
    # escapes a minimal set of characters
    s/([\t\r\n[:cntrl:];=%&])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_seqid {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_?|])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_source {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_? ])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_attribute {
    # like gff_escape, but escapes commas too
    s/([\t\r\n[:cntrl:];=%&,])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_target {
    # like gff_escape, but escapes commas and spaces too
    s/([\t\r\n[:cntrl:];=%&, ])/sprintf "%%%02X", ord($1)/eg;
    return;
}

my $chr_field = $chr;
gff_escape_seqid for $chr_field;

sub _print_header {
    print
        <<"GFF",
##gff-version $gff_version
##sequence-region $chr $start $end
GFF
;
    return;
}

my $strands = {
    1  => '+',
    -1 => '-',
};

my    ($attributes_format, $attributes_quote, $attributes_escape) = ($gff_version == 3)
    ? ('%s=%s',            0,                 1                 )
    : ('%s %s',            1,                 0                 )
    ;

my @attributes_quotable = qw( Name Class cigar_bam );
my $attributes_quotable = { map { $_ => 1 } @attributes_quotable };

sub _print_feature {
    my ($feature, $start, $end) = @_;

    # See Bio::DB::Bam::Alignment for documentation of available methods on $feature
    my $name = $feature->name;
    gff_escape_target for $name;

    # the -gff_feature_source flag overrides the source from the BAM file
    my $source = $gff_feature_source || $feature->source_tag;

    my ($score) = $feature->get_tag_values('AS');

    my @fields =
        (
         'read',
         (sprintf "%d", $start),
         (sprintf "%d", $end),
         (defined $score ? (sprintf "%f", $score) : '.'),
         '+', # strand
         $feature->phase || '.',
        );

    # $feature->cigar_str has the wrong format for the Gap tag
    # (eg. 76M instead of M76) so we have to build it from
    # $feature->cigar_array (which, strangely, has the operator
    # and count arguments in the right order for the Gap tag even
    # though $feature->cigar_str has them in the wrong order)

    # the Target tag - escaping this requires special handling of
    # spaces in the query name

    my $query = $feature->query;

    my @align_fields = ($query->start, $query->end);
    my $query_strand = $strands->{$query->strand};
    push @align_fields, $query_strand if $query_strand;

    my $q_length = $feature->l_qseq;

    my @attributes = (
        Class       => 'Sequence',
        Name        => $name,
        Align       => join(' ', @align_fields),
        Length      => $feature->l_qseq,
        percentID   => 100,
        sequence    => $query->dna,
        );

    my $cigar = $feature->cigar_str;
    $cigar =~ s/\d+S//g;    # Remove BAM "S" clipping strings from CIGAR
    if ($cigar !~ /^\d+M$/) {
        # It isn't a simple match string, so we do need CIGAR
        push(@attributes, cigar_bam => $cigar);
    }

    my @attribute_strings = ();
    while ( my ($key, $value) = splice(@attributes, 0, 2) ) {
        if ($attributes_quote && $attributes_quotable->{$key}) {
            $value = qq{"$value"};
        }
        if ($attributes_escape) {
            unless ($key eq 'Target') { # the Target tag is already escaped
                gff_escape_attribute for $value;
            }
            gff_escape_attribute for $key;
        }
        push @attribute_strings, sprintf $attributes_format, $key, $value;
    }
    my $attributes_string = join ";", @attribute_strings;

    gff_escape_source for $source;
    gff_escape for @fields;
    printf "%s\n", join "\t"
        , $chr_field, $source, @fields, $attributes_string;

    return;
}

# get the mapping from the Otter server
my $client = Bio::Otter::Lace::Defaults::make_Client();
my $mapping_xml = $client->otter_response_content(
    'GET', 'get_mapping', {
        dataset => $dataset,
        cs      => $csver,
        chr     => $chr,
        start   => $start,
        end     => $end,
    });
my $mapping = Bio::Otter::Mapping->new_from_xml($mapping_xml);

# map and print the features
_print_header;
$mapping->do_features($bam_fetch, $start, $end, \&_print_feature);
