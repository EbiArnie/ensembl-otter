#!/usr/bin/env perl

use strict;
use warnings;

use feature 'switch';

use AnyEvent::Impl::Perl;       # (try to) ensure pure-perl loop is used
use AnyEvent;

use Zircon::Context::ZMQ::AnyEvent;
use Zircon::Protocol;

package Bio::Otter::GetScript::ProcessHits;

use base qw(
    Bio::Otter::Utils::GetScript::LocalDB
    Zircon::Protocol::Server
);

sub version { return 'process_hits 0.1'; };
sub log_filename { return 'process_hits.txt'; }

sub do_it {
    my ($self) = @_;

    $self->do_requires;

    $self->log_message('starting zircon');
    $self->_setup_zircon;

    my $args = $self->args;
    AnyEvent::Impl::Perl::loop;

    return;
}

# GetScript objects are singletons, hence these class members are simple variables.
my $_protocol;

sub _setup_zircon {
    my ($self) = @_;

    my $peer_socket = $self->require_arg('peer_socket');

    my $context = Zircon::Context::ZMQ::AnyEvent->new(-trace_prefix => 'PHP');
    $_protocol   = Zircon::Protocol->new(
        -app_id     => 'process_hits',
        -app_tag    => 'otter_hits',
        -serialiser => 'JSON',
        -context    => $context,
        -server     => $self,
        );

    $_protocol->send_handshake(
        $peer_socket,
        sub {
            my ($result) = @_;
            $self->log_message(sprintf 'handshake: %s', _zircon_message($result));
        },
        );

    return;
}

# FIXME: code dup with zircon/utterloss/bin/zapmop
#
sub _zircon_message {
    my ($result) = @_;
    for ($result) {
        when ($_->isa('Zircon::Protocol::Result::Reply')) {
            return $result->success ? 'succeeded' : 'failed';
        }
        when ($_->isa('Zircon::Protocol::Result::Timeout')) {
            return 'timeout';
        }
        when (ref) {
            return sprintf 'unknown result: class: %s', ref;
        }
    }
    return 'unknown result';
}

sub zircon_server_protocol_command {
    my ($self, $command, $view_id, $request_body) = @_;

    # FIXME: dup with B:O:Zircon::ProcessHits, Zircon::ZMap (and below, in process())
    my $tag_entity_hash = { };
    $tag_entity_hash->{$_->[0]} = $_ for @{$request_body};

    for ($command) {

        when ('process') {
            return $self->process($tag_entity_hash);
        }

        default {
            my $reason = "Unknown process_hits command: '${command}'";
            return $_protocol->message_command_unknown($reason);
        }
    }
    return;
}

my %_cb_handle;

sub process {
    my ($self, $tag_entity_hash) = @_;

    my $columns_entity = $tag_entity_hash->{'columns'};
    $columns_entity or die "missing columns entity";
    my (undef, undef, @columns) = @{$columns_entity};
    @columns = grep { $_ } @columns;

    unless (@columns) {
        $self->log_message('No columns so nothing to do');
        return $_protocol->message_ok('no columns', [ data => { busy => 0 } ]);
    }

    foreach my $column (@columns) {
        $self->log_message("Scheduling process_hits for '$column'");
        $_cb_handle{$column} = AnyEvent->idle( cb => sub { $self->_process_hits($column); } );
    }
    return $_protocol->message_ok('processing', [ data => { busy => 1 } ]);
}

sub _process_hits {
    my ($self, $column) = @_;
    delete $_cb_handle{$column};

    $self->log_message("_process_hits for '$column'");

    # Do some stuff!!!

    $_protocol->send_command('processed', undef, [ columns => {}, $column ]);
    return;
}

sub log_context {
    return 'process_hits';
}

sub DESTROY {
    my ($self) = @_;
    $self->log_message(      'DESTROY()');
    $self->zircon_server_log('DESTROY()');
    $_protocol = undef;
    return;
}

## no critic (Modules::ProhibitMultiplePackages)

package main;

use Log::Log4perl::Level;

Bio::Otter::GetScript::ProcessHits
    ->new(log4perl => $DEBUG)
    ->run;

exit;

__END__

=head1 AUTHOR

Ana Code B<email> anacode@sanger.ac.uk

