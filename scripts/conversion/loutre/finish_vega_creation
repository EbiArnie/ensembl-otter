#!/usr/local/bin/perl

=head1 NAME

finish_vega_creation - script to tweak newly created vega database for attaching to a website

=head1 SYNOPSIS

finish_vega_creation [options]

Options:

    --conffile, --conf=FILE             read script parameters from FILE
                                        (default: conf/Conversion.ini)

    --dbname=NAME                       use Vega database NAME
    --host=HOST                         use Vega database host HOST
    --port=PORT                         use Vega database port PORT
    --user=USER                         use Vega database username USER
    --pass=PASS                         use Vega database password PASS

    --vega_release=NUM                  vega release number
    --release_type=STRING               type of release, ie External
    --no_feature=BOOLEAN                choose to dump *align_features or not

    --prune

    --logfile, --log=FILE               log to FILE (default: *STDOUT)
    --logpath=PATH                      write logfile to PATH (default: .)
    -v, --verbose                       verbose logging (default: false)
    -i, --interactive=0|1               run script interactively (default: true)
    -n, --dry_run, --dry=0|1            don't write results to database
    -h, --help, -?                      print help (this message)


=head1 DESCRIPTION

This script does a number of jobs:
- updates gene.analysis_id and transcript.analysis_id depending on gene.source
- adds attributes for gene / transcript author and author_email according to source (hard coded)
- deletes transcript synonym attrib types
- sets seq_region.name for chromosomes to that defined by the seq_region_attrib 'vega_name'
- tidies up coord_system and related tables (meta), removes NCBI types [code can probably be removed -
  need to test in mouse],  sets the default assembly version to 'Vega' from 'Otter' and patches meta
- tidies up meta table
- patches coord_system.version for contigs to NULL
- synchronises attribute table with ensembl/misc-scripts/attribute_types/attrib_types.txt
- synchronises external_db table with ensembl/misc-scripts/external_db/external_dbs.txt
- populates exon_stable_id_pool with max value (might be needed for removing duplicate stable IDS

The first time it is run it creates backup copies of the original tables; then when run
subsequently with the -prune 1 option it restores these tables to their original state. Can
therefore completely reset the database using a combination of -prune 1 -dry-run 1 options

Does a number of data checks which can be seen by running in -dry_run mode and looking for 'WARNING'
in the log file. The script will prompt you to run in dry_run mode if this is the first time it's
been run on a particular database.

=head1 LICENCE

This code is distributed under an Apache style licence:
Please see http://www.ensembl.org/code_licence.html for details

=head1 AUTHOR

Steve Trevanion <st3@sanger.ac.uk>

=head1 CONTACT

Post questions to the EnsEMBL development list ensembl-dev@ebi.ac.uk

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use FindBin qw($Bin);
use vars qw($SERVERROOT);

BEGIN {
    $SERVERROOT = "$Bin/../../../..";
    unshift(@INC, "$SERVERROOT/ensembl-otter/modules");
    unshift(@INC, "$SERVERROOT/ensembl/modules");
    unshift(@INC, "$SERVERROOT/bioperl-live");
}

use Getopt::Long;
use Pod::Usage;
use Data::Dumper;
use Bio::EnsEMBL::Utils::ConversionSupport;
use POSIX qw(strftime);
use Bio::EnsEMBL::Gene;
use Bio::EnsEMBL::Transcript;
use Bio::EnsEMBL::Exon;

$| = 1;

my $support = new Bio::EnsEMBL::Utils::ConversionSupport($SERVERROOT);

# parse options
$support->parse_common_options(@_);
$support->parse_extra_options(
	'prune=s',
);
$support->allowed_params(
	'prune',
	$support->get_common_params,
);

$support->check_required_params(
	'dbname',
);
if ($support->param('help') or $support->error) {
    warn $support->error if $support->error;
    pod2usage(1);
}

# ask user to confirm parameters to proceed
$support->confirm_params;

# get log filehandle and print heading and parameters to logfile
$support->init_log;

# connect to vega database and get adaptors
my $vdba = $support->get_database('ensembl');
my $vsa  = $vdba->get_SliceAdaptor();
my $vaa  = $vdba->get_AnalysisAdaptor();
my $vata = $vdba->get_AttributeAdaptor();
my $vdbh = $vdba->dbc->db_handle;

#get tables from database
# - if there are no backups of the originals make them
# - if this is the first time the script has been run then offer to run in 'dry_run' mode
my @tables = qw(coord_system
		meta
		seq_region
		analysis
		gene
		transcript
		gene_attrib
		transcript_attrib
		seq_region_attrib
                exon_stable_id_pool
                simple_feature);
my (%tabs);
my $dbname = $support->param('dbname');
map { $_ =~ s/`//g; $_ =~ s/$dbname.//g; $tabs{$_} += 1; } $vdbh->tables;

my $ask = 1;
foreach my $name (@tables) {
    my $backup_name = 'backup_original_'.$name;
    if (! exists($tabs{$backup_name})) {
	if (! $support->param('dry_run') && $ask) {
	    if ($support->user_proceed("It seems as though this is the first time you've run this script so I'd advise running it in \'dry_run\' mode. Shall I set this for you (select 'N' to proceed anyway?)\n")) {
		$support->param('dry_run',1);
		$support->log("Set to dry_run mode\n");
	    }
	    else {
		$ask = 0;
	    }
	    $vdbh->do("CREATE table $backup_name SELECT * from $name");
	}
	else {
	    $vdbh->do("CREATE table $backup_name SELECT * from $name");
	}
    }
}

# undo changes from previous runs of this script
if ($support->param('prune') && $support->user_proceed("\nDo you want to undo all changes from previous runs of this script?")) {
	foreach my $name (@tables) {
		my $backup_name = 'backup_original_'.$name;
		if (exists($tabs{$backup_name})) {
			$support->log_verbose("Resetting values for table $name\n");
			$vdbh->do("DELETE from $name");
			$vdbh->do("INSERT into $name SELECT * from $backup_name");	
		}
	}
}

##########################################################################
# delete unwanted loutre-derived simple_features                         #
##########################################################################
my %lns_to_stay = map {$_,1} qw(CpG
				Eponine
				polyA_signal
				polyA_site
				pseudo_polyA
				RSS
				tRNAscan
				EUCOMM );
my %lns_to_go = map {$_,1}	 qw(TATA_box EUCOMM_AUTO);

my $s = $vdbh->prepare(qq(
                SELECT a.logic_name, a.analysis_id, count(*)
                FROM analysis a, simple_feature sf
                WHERE a.analysis_id = sf.analysis_id
                GROUP BY a.logic_name
));
$s->execute;
my %sf_features;
while (my ($logic_name,$analysis_id,$c) = $s->fetchrow) {
    $sf_features{$logic_name} = $c;
}
my $problem = 0;
foreach my $ln (keys %sf_features) {
    if (! exists($lns_to_stay{$ln}) ) {
	if (! exists($lns_to_go{$ln}) ) {
	    $support->log_warning("I don't know what to do with $ln simple features, please help me out\n");
	    $problem = 1;
	}
	else {
	    $support->log("Will delete $ln simple_features\n");
	}
    }
    else {
	$support->log("Keeping $ln simple_features\n");
    }
}

if ($problem) {
    if (! $support->user_proceed("There are features with logic names that I don't know what to do with, please look at the logs. Do you really want to proceed?\n")) {
	exit;
    }
    $support->log_warning("There are logic_names that will be kept even though this is not specifically defined\n");
}

if (! $support->param('dry_run')) {
	$support->log("Deleting from simple_feature by analysis_id\n");
	my $c = 0;
	foreach my $ln (keys %lns_to_go) {
		$c += $vdbh->do(qq(DELETE sf
                             FROM simple_feature sf, analysis a
                            WHERE a.analysis_id = sf.analysis_id
                              AND a.logic_name = \'$ln\'));
	}
	$support->log("Removed $c simple_features\n");
}


##########################################################################
# - patch analysis_ids of genes and transcripts according to gene.source #
# - update the chromosome names to match the attrib_type                 #
# - add attributes for author and author_email for genes and transcripts #
##########################################################################

#may well not need to patch analysis_ids if jgrg will do it loutre...

if (! $support->param('dry_run')) {
	#make sure a case difference doesn't ever come back to haunt us later
	$vdbh->do("UPDATE analysis SET logic_name = \'otter\' WHERE logic_name = \'Otter\'");
}

$support->log("\nChecking sources of genes...\n");

#define the logic_name and the display name to use for each gene.source
#also define author name and email - the latter could come out of author_group table ?
#(note that in the final Vega db, GD and KO will use multiple analysis_ids)
my %all_logic_names = (
	'havana' => ['otter',          'Havana',    'vega@sanger.ac.uk'],
	'WU'     => ['otter_external', 'Washu',     'jspieth@watson.wust'],
	'JGI'    => ['otter_external', 'JGI',       'UHellsten@lbl.gov'],
	'GC'     => ['otter_external', 'Genoscope', 'ralph@genoscope.cns.fr'],
	'SK'     => ['otter_external', 'Sick_Kids', 'jmacdonald@sickkids.ca'],
	'BCM'    => ['otter_external', 'BCM',       'sabo@bcm.tmc.edu'],
	'MIT'    => ['otter_external', 'Broad',     'daved@broad.mit.edu'],
	'C22'    => ['otter_external', 'Sanger',    'chr22@sanger.ac.uk'],
	'GD'     => ['otter_external', 'EGAG',      'egag@sanger.ac.uk'],
	'KO'     => ['otter_eucomm',   'Havana',    'vega@sanger.ac.uk'],
);

#get all the logic names that are used
my %used_logic_names;
my $sth = $vdbh->prepare(qq(
              SELECT distinct(source)
              FROM gene));
$sth->execute;
while (my ($source) = $sth->fetchrow_array) {
	if (! exists($all_logic_names{$source})) {
		$support->log_error("You haven't defined the analysis.logic_name to use with genes of source $source, please fix.\n");
	}
	else {
		$used_logic_names{$source} = $all_logic_names{$source}[0];
	}
}

#add entries to analysis table
my @logic_names;
foreach my $source (keys %used_logic_names) {
	my $ln =  $used_logic_names{$source};
	if (! grep{ $ln eq $_ } @logic_names ) {
		push @logic_names, $ln;
		my $analysis = new Bio::EnsEMBL::Analysis (
			-program     => "finish_vega_creation",
			-logic_name  => $ln,
		);
		if (! $support->param('dry_run')) {
			if (my $analysis_id = $vaa->store($analysis)) {
				$support->log("...adding analysis object for source $ln\n",1);
			}
			else {
				$support->log_warning("Couldn't store analysis $ln\n");
			}
		}
	}
}

#SQL to update chromosome name
$sth = $vdbh->prepare(qq(
           UPDATE seq_region 
           SET    name = ?
           WHERE  seq_region_id = ?
));

#loop through chromosomes and do the patches
foreach my $chrom (@{$vsa->fetch_all('chromosome','Otter')}) {
	my $loutre_name = $chrom->seq_region_name;
	my $sr_id = $chrom->get_seq_region_id;
	my $vega_name;
    $support->log("\nRetrieving chromosome $loutre_name...\n");
	my @vega_names = @{$chrom->get_all_Attributes('vega_name')};
	if (scalar(@vega_names) > 1) {
		$support->log_warning("Multiple vega_name attributes for loutre chromosome $loutre_name - ".(join ' ',@vega_names)." - not setting\n",1);
	}
	elsif (! @vega_names) {
		$support->log_warning("No vega_name attribute for loutre chromosome $loutre_name\n",1);
	}
	else {
		my $att = pop @vega_names;
		$vega_name = $att->value;
		if (! $support->param('dry_run')) {
			$support->log("...patching name to $vega_name\n",1);
			$sth->execute($vega_name,$sr_id);
		}
	}

	if (! $support->param('dry_run')) {
		$support->log("\nPatching analysis_ids for genes and transcripts...\n",1);

		#SQL to update gene analysis_id
		my $gsth = $vdbh->prepare(qq(
                   UPDATE gene g, analysis a
                   SET    g.analysis_id = a.analysis_id
                   WHERE  g.gene_id = ?
                   AND    a.logic_name = ?
        ));
		
		#SQL to update transcript analysis_id
		my $tsth = $vdbh->prepare(qq(
                   UPDATE transcript t, gene g
                   SET    t.analysis_id = g.analysis_id
                   WHERE  t.gene_id = g.gene_id
                   AND    t.transcript_id = ?
        ));	

		#SQL to update source case mismatch
		my $ssth = $vdbh->prepare(qq(
                   UPDATE gene
                   SET    source = ?
                   WHERE  g.gene_id = ?
        ));	

		#loop through genes
		foreach my $gene (@{$chrom->get_all_Genes()}) {
			my $gsid = $gene->stable_id;
			my $gid  = $gene->dbID;
			my $gname = $gene->get_all_Attributes('name')->[0]->value;
			my $source = $gene->source;
			if ($source ne 'havana') {
				$source = uc($source);
				if ($gene->source ne $source) {
					$support->log_warning("Gene $gsid ($gname) has a source of \'".$gene->source."\', patching, but you might want to check the name\n",2);
					$ssth->execute($source,$gid);
				}
			}
			my $old_gln = $gene->analysis->logic_name;
			my $new_ln = $used_logic_names{$source};
					
			#patch analysis_ids
			if ($new_ln ne $old_gln) {
				if ($gsth->execute($gid,$new_ln)) {
					$support->log("\nGene $gsid ($gname) logic_name patched from $old_gln to $new_ln\n",2);
				}
			}
			else {
				$support->log_verbose("\nGene $gsid ($gname) logic name not changed\n",2);
			}
			
			# create attributes for author info
			my $gene_attribs = [];

			# author and author_email
			push @{ $gene_attribs }, Bio::EnsEMBL::Attribute->new(
				-CODE => 'author',
				-NAME => 'Author',
				-DESCRIPTION => 'Group responsible for Vega annotation',
				-VALUE => $all_logic_names{$source}[1],
			);
			push @{ $gene_attribs }, Bio::EnsEMBL::Attribute->new(
				-CODE => 'author_email',
				-NAME => 'Author email address',
				-DESCRIPTION => 'Author\'s email address',
				-VALUE => $all_logic_names{$source}[2],
			);
			
			$support->log_verbose("Storing gene attributes for author and author_email.\n", 3);
			$vata->store_on_Gene($gid, $gene_attribs);

			#loop through transcripts
			foreach my $trans (@{$gene->get_all_Transcripts()}){
				my $tsid = $trans->stable_id;
				my $tid  = $trans->dbID;
				my $tname = '';

				#identify any transcripts without names
				eval { $tname = $trans->get_all_Attributes('name')->[0]->value; };
				if ($@) {
					$support->log_warning("Transcript $tsid from gene $gsid ($gname) has no \'name\' transcript_attrib\n");
				}

				my $old_tln = $trans->analysis->logic_name;
				#patch analysis_ids
				if ($new_ln ne $old_tln) {
					if ($tsth->execute($tid)) {
						$support->log("Transcript $tsid ($tname) logic_name patched from $old_tln to $new_ln\n",2);
					}
				}
				else {
					$support->log_verbose("Transcript $tsid ($tname) logic name not changed\n",2);
				}
				
				# create attributes for author info
				my $trans_attribs = [];
				
				# author and author_email
				push @{ $trans_attribs }, Bio::EnsEMBL::Attribute->new(
					-CODE => 'author',
					-NAME => 'Author',
					-DESCRIPTION => 'Group responsible for Vega annotation',
					-VALUE => $all_logic_names{$source}[1],
				);
				push @{ $trans_attribs }, Bio::EnsEMBL::Attribute->new(
					-CODE => 'author_email',
					-NAME => 'Author email address',
					-DESCRIPTION => 'Author\'s email address',
					-VALUE => $all_logic_names{$source}[2],
				);
				
				$support->log_verbose("Storing transcript attributes for author and author_email.\n", 3);
				$vata->store_on_Transcript($tid, $trans_attribs);
			}
		}		
	}
}

#####################
# attribs to delete #
#####################

#define tables and attrib codes to delete
my %attribs_to_go = (
	'seq_region_attrib' => [],
	'gene_attrib'       => [],
	'transcript_attrib' => ['synonym'],
);
#do the deletions
foreach my $table (keys %attribs_to_go) {
	foreach my $code (@{$attribs_to_go{$table}}) {
		if (! $support->param('dry_run')) {
			my $r = $vdbh->do(qq(
                             DELETE t
                             FROM   attrib_type at, $table t
                             WHERE  at.attrib_type_id = t.attrib_type_id
                             AND    at.code = \'$code\'
                            ));
			$support->log("\nRemoved $r attribs of type $code from table $table\n");
		}
	}
}


#######################
# exon_stable_id_pool #
#######################

my ($max_id) = $vdbh->selectrow_array(qq(select max(stable_id) from exon_stable_id));
(my ($prefix,$number)) = $max_id =~ /(\w{7})(\d+)/;
if ( ! $support->param('dry_run')) {
	$vdbh->do(qq(INSERT into exon_stable_id_pool values ($number)));
}

##############
# misc fixes #
##############
		
my @sql_fixes;

#check the coord_system table
my $count = $vdbh->selectrow_array(qq(
                SELECT count(*)
				FROM   coord_system
				WHERE  name = 'chromosome'));

if ($count > 2) {
	$support->log_warning("There is an unexpected number ($count) of chromosome coordinate systems - you need to investigate\n");
	exit;
}
# remove NCBI* coordinates as long as they're not in the seq_region table (which would represent a mistake)
elsif ($count == 2) {
	my ($other_coord_version,$other_coord_id) = $vdbh->selectrow_array(qq(
                                                    SELECT version, coord_system_id
					                        		FROM   coord_system
                      							    WHERE  name = 'chromosome'
                                                      AND  version NOT IN ('Otter')));
	if ($other_coord_version =~ /NCBI/) {
		my $ncbi_used =  $vdbh->selectrow_array(qq(
                             SELECT count(*) 
                             FROM   seq_region
                             WHERE  coord_system_id = $other_coord_id));
		if (! $ncbi_used) {
			$support->log("\nDeleting $other_coord_version coordinate system\n");			
			push @sql_fixes, "DELETE from coord_system WHERE coord_system_id = $other_coord_id;\n";
		}
		else {
			$support->log_error("Slices with a coord_system.version of $other_coord_version are present in the seq_region table. This should not happen, please investigate\n");
		}
	}
	elsif ($other_coord_version) {
		$support->log_error("There is an unexpected coord_system ($other_coord_version) - you need to investigate\n");
	}
}

#sanity check - if the Otter coord_system is actually used for the (longest) chromosome then rename it to Vega
#also patch contig.version in coord_system
my $chr_coord_id   = $vdbh->selectrow_array(qq(
                         SELECT coord_system_id 
				         FROM   seq_region 
					     ORDER  by length desc 
					     LIMIT  1));
my $otter_coord_id = $vdbh->selectrow_array(qq(
                         SELECT coord_system_id
					     FROM   coord_system
						 WHERE  version = 'Otter'));
if ($chr_coord_id == $otter_coord_id) {
	push @sql_fixes, "UPDATE coord_system set version = \'VEGA\' WHERE version = \'Otter\';\n";
	push @sql_fixes, "UPDATE coord_system set attrib = \'default_version\' WHERE version = \'VEGA\';\n";
	push @sql_fixes, "UPDATE coord_system set rank = 1 WHERE version = \'VEGA\' and name = \'chromosome\';\n";
	push @sql_fixes, "UPDATE coord_system set version = NULL WHERE version = \'none\' and name = \'contig\';\n";
	push @sql_fixes, "INSERT into meta (meta_key,meta_value) VALUES (\'assembly.default\',\'VEGA\');\n";
	push @sql_fixes, "UPDATE meta set meta_value = \'chromosome:VEGA|contig\' WHERE meta_value = \'chromosome:Otter|contig\';\n";
	push @sql_fixes, "UPDATE meta set meta_value = \'chromosome:VEGA|contig|clone\' WHERE meta_value = \'chromosome:Otter|contig|clone\';\n";	
}
else {
	$support->log_error("Otter assembly not used for longest chromosome in seq_region table - check what\'s going on\n");
}

#add misc info to meta table
my $date = strftime "%Y-%m", localtime;
my $gene_build = $date.'-vega';
push @sql_fixes, "INSERT ignore into meta (meta_key,meta_value) VALUES (\'genebuild.version\',\'$gene_build\');\n";
push @sql_fixes, "INSERT into meta (meta_key,meta_value) VALUES ('genebuild.level','toplevel'),('transcriptbuild.level','toplevel'),('exonbuild.level','toplevel');\n";

#delete patch script entries
push @sql_fixes, "DELETE from meta WHERE meta_key = \'patch\';\n";

#update biotypes of some genes/transcripts for website display purposes
push @sql_fixes, "UPDATE gene SET biotype = 'IG_gene' WHERE biotype = 'ig_gene';\n";
push @sql_fixes, "UPDATE gene SET biotype = 'IG_pseudogene' WHERE biotype = 'ig_pseudogene';\n";
push @sql_fixes, "UPDATE gene SET biotype = 'TEC' WHERE biotype = 'tec';\n";
push @sql_fixes, "UPDATE transcript SET biotype = 'IG_gene' WHERE biotype = 'ig_gene';\n";
push @sql_fixes, "UPDATE transcript SET biotype = 'IG_pseudogene' WHERE biotype = 'ig_pseudogene';\n";
push @sql_fixes, "UPDATE transcript SET biotype = 'TEC' WHERE biotype = 'tec';\n";
push @sql_fixes, "UPDATE gene SET biotype = 'processed_transcript' WHERE biotype = 'novel_transcript';\n";
push @sql_fixes, "UPDATE gene SET biotype = 'transcribed_pseudogene' WHERE biotype = 'expressed_pseudogene';\n";
push @sql_fixes, "UPDATE gene SET biotype = 'polymorphic_pseudogene' WHERE biotype = 'polymorphic';\n";
push @sql_fixes, "UPDATE gene SET status = 'NOVEL' WHERE status = 'UNKNOWN';\n";
push @sql_fixes, "UPDATE transcript SET biotype = 'transcribed_pseudogene' WHERE biotype = 'expressed_pseudogene';\n";
push @sql_fixes, "UPDATE transcript SET biotype = 'IG_gene' WHERE biotype = 'ig_gene';\n";
push @sql_fixes, "UPDATE transcript SET biotype = 'processed_transcript', status  = 'PUTATIVE' WHERE biotype = 'putative' AND status  = 'UNKNOWN';\n";


if (! $support->param('dry_run')) {
	$support->log("\nFixing meta table, updating gene / transcript types\n");
	foreach my $fix (@sql_fixes) {
		if (my $r = $vdbh->do("$fix")) {
			if ($r eq '0E0') {
				$support->log("No rows affected for $fix");
			}
			else {
				$support->log("Updated $r rows for $fix");
			}
		}
		else {
			$support->log_warning("Failed fix: $fix") if (!$r);
		}
	}
}

if ($support->param('dry_run')) {
	$support->log("\nNo changes made to database since this is a dry run\n");
}

if (! $support->param('dry_run')) {
	#update attribute table
	my $options = $support->create_commandline_options({
		'allowed_params' => 1,
		'exclude' => ['prune'],
		'replace' => {
			'interactive' => 0,	
			'logfile'     => 'finish_vega_creation_update_attributes.log',
		}
	});
	$support->log("\nUpdating attrib_type table for ".$support->param('dbname')."...\n");
	system("../update_attributes.pl $options") == 0
		or $support->throw("Error running update_attributes.pl: $!");
	
	$options = $support->create_commandline_options({
		'allowed_params' => 1,
		'exclude' => ['prune'],
		'replace' => {
			'interactive' => 0,	
			'logfile'     => 'finish_vega_creation_update_external_dbs.log',
		}
	});
	$support->log("\nUpdating external_db table on ".$support->param('dbname')."...\n");
	system("../xref/update_external_dbs.pl $options") == 0
		or $support->throw("Error running update_external_dbs.pl: $!");
}	
$support->finish_log;
