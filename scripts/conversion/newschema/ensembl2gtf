#!/usr/local/bin/perl

use strict;

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::SeqFeature;
use Getopt::Long;
use Carp;
use FileHandle;

my $host   = 'ecs2';
my $user   = 'ensro';
my $pass   = '';
my $port   = 3365;
my $dbname = 'homo_sapiens_core_33_35f';

my @chromosomes;
my $path = 'NCBI35';
my $gtf_file = undef;
my $fix_phases = 0;
my $ccds;
my $chr_start;
my $chr_end;
my $include_stops;

$| = 1;

&GetOptions(
  'host:s'        => \$host,
  'user:s'        => \$user,
  'dbname:s'      => \$dbname,
  'pass:s'        => \$pass,
  'path:s'        => \$path,
  'port:n'        => \$port,
  'chromosomes:s' => \@chromosomes,
  'chrstart:s'    => \$chr_start,
  'chrend:s'      => \$chr_end,
  'gtffile:s'     => \$gtf_file,
  'fixphases'     => \$fix_phases,
  'ccds'          => \$ccds,
  'include_stops' => \$include_stops,
);

if (scalar(@chromosomes)) {
  @chromosomes = split (/,/, join (',', @chromosomes));
}

my $db = new Bio::EnsEMBL::DBSQL::DBAdaptor(
  -host   => $host,
  -user   => $user,
  -port   => $port,
  -pass   => $pass,
  -dbname => $dbname
);

my $sa  = $db->get_SliceAdaptor();
my $aga = $db->get_GeneAdaptor();
my $adx = $db->get_DBEntryAdaptor();
my $csa = $db->get_CoordSystemAdaptor();

# new style for setting assembly type
$csa->fetch_all->[0]->version($path);

my $cs = $csa->fetch_by_name('chromosome');

my $chrhash = get_chrlengths($db,$path);

#filter to specified chromosome names only
if (scalar(@chromosomes)) {
  foreach my $chr (@chromosomes) {
    my $found = 0;
    foreach my $chr_from_hash (keys %$chrhash) {
      if ($chr_from_hash =~ /^${chr}$/) {
        $found = 1;
        last;
      }
    }
    if (!$found) {
      print "Didn't find chromosome named $chr in database $dbname\n";
    }
  }
  HASH: foreach my $chr_from_hash (keys %$chrhash) {
    foreach my $chr (@chromosomes) {
      if ($chr_from_hash =~ /^${chr}$/) { next HASH; }
    }
    delete($chrhash->{$chr_from_hash});
  }
}

my $gtffp = new FileHandle;
$gtffp->open(">$gtf_file") or croak "Unable to open $gtf_file for write";
$gtffp->autoflush(1);

# ensp should be unique (output should be 1 translation not 1 transcript)
my %ccdssi;

foreach my $chr (reverse sort bychrnum keys %$chrhash) {
  print STDERR "Chr $chr from 1 to " . $chrhash->{$chr} . " on " . $path . "\n"; 
  my $chrstart = 1;
  my $chrend   = $chrhash->{$chr};
  # option to allow region to be dumped
  if($chr_start){$chrstart=$chr_start;}
  if($chr_end){$chrend=$chr_end;}
  #$chrend = 1000000;

  my $slice = $sa->fetch_by_region('chromosome',$chr, $chrstart, $chrend);

  print "Fetching genes\n";
  my $genes = $aga->fetch_all_by_Slice($slice);
  print "Done fetching genes\n";
 
  my $nt=0;
  my $nccdst=0;
  foreach my $gene (@$genes) {
    foreach my $trans (@{$gene->get_all_Transcripts}) {
      my $flag_ccds;

      # if ccds, only dump transcripts marked ccds
      if($ccds){
	foreach my $dbentry (@{$trans->get_all_DBLinks()}){
	  if($dbentry->dbname eq 'CCDS'){
	    my $ccdssi=$dbentry->display_id;
	    if(!$ccdssi{$ccdssi}){
	      $ccdssi{$ccdssi}=1;
	      $flag_ccds=1;
	    }
	    last;
	  }
	}
      }else{
	$flag_ccds=1;
      }
      $nt++;
      if($flag_ccds){
	$nccdst++;
	write_transcript_gtf($gtffp,$slice,$gene,$trans);
      }
    }
  }
  print "$nccdst transcripts are ccds out of $nt\n" if $ccds;
}

sub get_chrlengths{
  my $db = shift;
  my $type = shift;

  if (!$db->isa('Bio::EnsEMBL::DBSQL::DBAdaptor')) {
    die "get_chrlengths should be passed a Bio::EnsEMBL::DBSQL::DBAdaptor\n";
  }

  my %chrhash;

  my $q = qq( SELECT sr.name,sr.length FROM seq_region sr, coord_system cs
              WHERE sr.coord_system_id=cs.coord_system_id 
	        AND cs.name = 'chromosome' and cs.version = '$type'
            );

  my $sth = $db->prepare($q) || $db->throw("can't prepare: $q");
  my $res = $sth->execute || $db->throw("can't execute: $q");

  while( my ($chr, $length) = $sth->fetchrow_array) {
    $chrhash{$chr} = $length;
  }
  return \%chrhash;
}


sub bychrnum {

  my @awords = split /_/, $a;
  my @bwords = split /_/, $b;

  my $anum = $awords[0];
  my $bnum = $bwords[0];

  #  if ($anum !~ /^chr/ || $bnum !~ /^chr/) {
  #    die "Chr name doesn't begin with chr for $a or $b";
  #  }

  $anum =~ s/chr//;
  $bnum =~ s/chr//;

  if ($anum !~ /^[0-9]*$/) {
    if ($bnum !~ /^[0-9]*$/) {
      return $anum cmp $bnum;
    } else {
      return 1;
    }
  }
  if ($bnum !~ /^[0-9]*$/) {
    return -1;
  }

  if ($anum <=> $bnum) {
    return $anum <=> $bnum;
  } else {
    if ($#awords == 0) {
      return -1;
    } elsif ($#bwords == 0) {
      return 1;
    } else {
      return $awords[1] cmp $bwords[1];
    }
  }
}

sub make_start_codon_features {
  my ($trans,$id) = @_;


  if (!$trans->translation) {
    return (());
  }

  my @translateable = @{$trans->get_all_translateable_Exons};

  my @pepgencoords = $trans->pep2genomic(1,1);

  if(scalar(@pepgencoords) > 2) {
    die("pep start does not map cleanly\n");
    next;
  } elsif (scalar(@pepgencoords) == 2) {
    print "WOW got a 2 feature start codon for " . $trans->stable_id . " strand " . $translateable[0]->strand . "\n";
  }

  unless($pepgencoords[0]->isa('Bio::EnsEMBL::Mapper::Coordinate')) {
    die("pep start maps to gap\n");
    next;
  }
  unless($pepgencoords[$#pepgencoords]->isa('Bio::EnsEMBL::Mapper::Coordinate')) {
    die("pep start (end of) maps to gap\n");
    next;
  }

  my @translateable = @{$trans->get_all_translateable_Exons};
  my @startc_feat;
  my $phase = 0;
  foreach my $pepgencoord (@pepgencoords) {
    push @startc_feat, new Bio::EnsEMBL::SeqFeature(
                             -seqname => $id,
                             -source_tag => 'starttrans',
                             -primary_tag => 'similarity',
                             -start => $pepgencoord->start,
                             -end   => $pepgencoord->end,
                             -phase => $phase,
                             -strand => $translateable[0]->strand);
    $phase = 3 - ($pepgencoord->end - $pepgencoord->start + 1);
    # print "New phase = $phase given " . $pepgencoord->start . " " . $pepgencoord->end . " " . ( $pepgencoord->end - $pepgencoord->start+1) . "\n";
  }
  if ($translateable[0]->strand == 1) {
    @startc_feat = sort {$a->start <=> $b->start } @startc_feat;
  } else {
    @startc_feat = sort {$b->start <=> $a->start } @startc_feat;
  }
  return @startc_feat;

}

sub make_stop_codon_features {
  my ($trans,$id) = @_;

  if (!$trans->translation) {
    return (());
  }
  my @translateable = @{$trans->get_all_translateable_Exons};

  my $cdna_endpos = $trans->cdna_coding_end;

  my @pepgencoords = $trans->cdna2genomic($cdna_endpos-2,$cdna_endpos);

  if(scalar(@pepgencoords) > 2) {
    die("pep end does not map cleanly\n");
    next;
  } elsif (scalar(@pepgencoords) == 2) {
    print "WOW got a 2 feature stop codon for " . $trans->stable_id . " strand " . $translateable[0]->strand . "\n";
  }

  unless($pepgencoords[0]->isa('Bio::EnsEMBL::Mapper::Coordinate')) {
    die("pep end maps to gap\n");
    next;
  }
  unless($pepgencoords[$#pepgencoords]->isa('Bio::EnsEMBL::Mapper::Coordinate')) {
    die("pep end (end of) maps to gap\n");
    next;
  }

  my @stopc_feat;
  my $phase = 0;
  foreach my $pepgencoord (@pepgencoords) {
    push @stopc_feat, new Bio::EnsEMBL::SeqFeature(
                             -seqname => $id,
                             -source_tag => 'endtrans',
                             -primary_tag => 'similarity',
                             -start => $pepgencoord->start,
                             -end   => $pepgencoord->end,
                             -phase => $phase,
                             -strand => $translateable[0]->strand);
    $phase = 3 - ($pepgencoord->end-$pepgencoord->start+1);
    # print "New phase = $phase given " . $pepgencoord->start . " " . $pepgencoord->end . " " . ($pepgencoord->end-$pepgencoord->start+1) . "\n";
  }

  if ($translateable[0]->strand == 1) {
    @stopc_feat = sort {$a->start <=> $b->start } @stopc_feat;
  } else {
    @stopc_feat = sort {$b->start <=> $a->start } @stopc_feat;
  }
  if(scalar(@stopc_feat)!=1){
    print "Ended with " . scalar(@stopc_feat) . " stop codon features\n";
  }
  return @stopc_feat;
}


sub write_transcript_gtf {
  my ($fh,$slice,$gene,$transcript) = @_;

  my @startcs =  make_start_codon_features($transcript,$transcript->stable_id);
  my @endcs   =  make_stop_codon_features($transcript,$transcript->stable_id);

  my $sliceoffset = $slice->start-1;
  my $chrname;
  $chrname = $slice->seq_region_name;

  my $idstr = $chrname;

  # all ccds should have this
  my ($hasstart,$hasend) = check_start_and_stop($slice,$transcript);
  # test if ccds
  if($ccds){
    if(!$hasstart){
      print "CCDS error: ".$transcript->stable_id." has no start ATG\n";
    }
    if(!$hasend){
      print "CCDS error: ".$transcript->stable_id." has no stop codon\n";
    }
  }

  my @translateable_exons = @{$transcript->get_all_translateable_Exons} if $transcript->translation;

  if ($fix_phases) {
    my $phase = 0;
    foreach my $exon (@translateable_exons) {
      $exon->phase($phase);
      $exon->end_phase(($exon->length + $exon->phase) % 3);
      $phase = $exon->end_phase;
    }
  }

  my $count=1;
  my $intrans = 0;
  my $instop = 0;
  foreach my $exon (@{$transcript->get_all_Exons}) {
    my $strand = $exon->strand;
    if ($exon->strand == -1) {
        $strand = "-";
    } elsif ($exon->strand == 1) {
        $strand = "+";
    } elsif ($exon->strand == 0) {
        $strand = ".";
    }

    if ($transcript->translation && $exon == $transcript->translation->start_Exon) {
      $intrans = 1;
    }
    if($ccds){
      # in CCDS mode, only dump CDS region, so write both exon, CDS from CDS
    }else{
      print $fh $idstr . "\t" . 
	  $gene->type . "\t" . 
	  'exon' . "\t" . 
	  ($exon->start+$sliceoffset) . "\t". 
	  ($exon->end+$sliceoffset) . "\t". 
	  "." . "\t". 
	  $strand . "\t". 
	  "." . "\t";
      print_attribs($fh,$gene,$transcript,$count,'exon');
    }

    # remarks don't seem to exist in the ensembl schema as they do in otter
    # gene_description is used for something else, so is not appropriate
    #if ($count == 1) { print_description_attribs($fh,$gene,$transcript,$count); }

    print $fh "\n";

    if ($intrans) {

      my $cdsexon = shift @translateable_exons;
      my $phase = $cdsexon->phase;
      if ($cdsexon->phase == 1) {
        $phase = 2;
      } elsif ($cdsexon->phase == 2) {
        $phase = 1;
      } elsif ($cdsexon->phase == -1) {
        $phase = 0;
      }

      my $exon_start = $cdsexon->start;
      my $exon_end   = $cdsexon->end;
      if ($transcript->translation && 
          # $exon == $transcript->translation->end_Exon &&
          $hasend && 
          $exon->overlaps($endcs[0]) &&
	  !$include_stops) {

	if ($cdsexon->strand == 1) {
	  $exon_end = $cdsexon->end - $endcs[0]->length;
	} else {
	  $exon_start = $cdsexon->start + $endcs[0]->length;
	}
      }

      if ($exon_start <= $cdsexon->end &&
          $exon_end >= $cdsexon->start &&
          !$instop) {
	if($ccds){
	  # in CCDS mode, dump only CDS region, so write each as both exon and CDS
	  print $fh $idstr . "\t" . 
	      $gene->type . "\t" . 
	      'exon' . "\t" . 
	      ($exon_start+$sliceoffset) . "\t". 
	      ($exon_end+$sliceoffset) . "\t". 
	      "." . "\t". 
	      $strand . "\t". 
	      "." . "\t";
	  print_ccds_attribs($fh,$gene,$transcript);
	  print $fh "\n";
	}
        print $fh $idstr . "\t" . 
                 $gene->type . "\t" . 
                 'CDS' . "\t" . 
                 ($exon_start+$sliceoffset) . "\t". 
                 ($exon_end+$sliceoffset) . "\t". 
                 "." . "\t". 
                 $strand . "\t". 
                 $phase . "\t";
	# for ccds, only dump description on first exon of transcript
	if($ccds){
	  print_ccds_attribs($fh,$gene,$transcript);
	}else{
	  print_attribs($fh,$gene,$transcript,$count,'CDS');
	}
        print $fh "\n";
      }
    }

    if ($transcript->translation && 
	$exon == $transcript->translation->start_Exon && $hasstart) {
      my $tmpcnt = $count;
      foreach my $startc (@startcs) {
	print $fh $idstr . "\t" . 
	    $gene->type . "\t" . 
	    'start_codon' . "\t" . 
	    ($startc->start+$sliceoffset) . "\t". 
	    ($startc->end+$sliceoffset) . "\t". 
	    "." . "\t". 
	    $strand . "\t". 
	    $startc->phase . "\t";
	if($ccds){
	  print_ccds_attribs($fh,$gene,$transcript);
	}else{
	  print_attribs($fh,$gene,$transcript,$tmpcnt++,'start_codon');
	}
	print $fh "\n";
      }
    }
    if ($transcript->translation && 
	($exon == $transcript->translation->end_Exon)) {
      if ($hasend) {
	my $tmpcnt = $count - $#endcs;
	foreach my $endc (@endcs) {
	  print $fh $idstr . "\t" . 
	      $gene->type . "\t" . 
		'stop_codon' . "\t" . 
		($endc->start+$sliceoffset) . "\t". 
		($endc->end+$sliceoffset) . "\t". 
		"." . "\t". 
		$strand . "\t". 
		$endc->phase . "\t";
	  if($ccds){
	    print_ccds_attribs($fh,$gene,$transcript);
	  }else{
	    print_attribs($fh,$gene,$transcript,$tmpcnt++,'stop_codon');
	  }
	  print $fh "\n";
	}
      }
      $intrans = 0;
    }

    if($include_stops){
      if (scalar(@endcs) && $exon->overlaps($endcs[scalar(@endcs)-1])) {
	$instop = 1;
      }
    }else{
      if (scalar(@endcs) && $exon->overlaps($endcs[0])) {
	$instop = 1;
      }
    }

    $count++;
  }
}

sub print_description_attribs {
  my ($fh,$gene,$transcript,$count) = @_;
  my $gene_description = undef;
  foreach my $remark ($gene->gene_info->remark) {
    $gene_description .= $remark->remark . " ";
  }
  if ($gene_description) {
    chop $gene_description;
    if ($gene_description eq "undef") {
      $gene_description = undef;
    }
  }
  my $trans_description = undef;
  foreach my $remark ($transcript->transcript_info->remark) {
    $trans_description .= $remark->remark . " ";
  }
  if ($trans_description) {
    chop $trans_description;
  }
  print $fh ($gene_description ? "gene_description \"$gene_description\"; " : "") .
            ($trans_description ? "trans_description \"$trans_description\"; " : "");
}

sub print_attribs {
  my ($fh,$gene,$transcript,$count,$type) = @_;


  my $gene_name;
  $gene_name = $gene->external_name;

  my $trans_name;
  $trans_name = $transcript->external_name;

  print $fh "gene_id \"" .  $gene->stable_id . "\"; " .
            "transcript_id \"" . $transcript->stable_id . "\"; ";
  print $fh "exon_number \"$count\"; ";
  print $fh "gene_name \"" . $gene_name . "\"; " if ($gene_name);
  print $fh "transcript_name \"" . $trans_name . "\"; " if ($trans_name);
  if ($type eq 'exon') {
    print $fh 'gbkey "mRNA";';
  } elsif ($type eq 'CDS') {
    print $fh 'protein_id "' . $transcript->translation->stable_id . '";';
  }
}

sub print_ccds_attribs {
  my ($fh,$gene,$transcript) = @_;

  my $gene_name = $gene->external_name;

  my $trans_name = $transcript->external_name;

  my $ccds_name;
  foreach my $dbentry (@{$transcript->get_all_DBLinks()}){
    if($dbentry->dbname eq 'CCDS'){
      $ccds_name=$dbentry->display_id;
    }
  }

  my $gsi=$gene->stable_id;
  my $tsi=$transcript->stable_id;
  my $psi=$transcript->translation->stable_id;

  # for labelling, use gene_name else ens_gene
  my $ccds_gname;
  if($gene_name){
    $ccds_gname=$gene_name;
  }else{
    $ccds_gname=$gsi;
  }

  print $fh "gene_id \"" .         $ccds_gname . "\"; " .
            "gene_category \"Novel_CDS\"; " .
            "transcript_id \"" .   $ccds_name . "\"; ";
  print $fh "transcript_name \"" . $ccds_name . "\"; ";
  print $fh "ens_prot \"" .        $psi . "\"; ";
  print $fh "ens_trans \"" .       $tsi . "\"; ";
  print $fh "ens_gene \"" .        $gsi . "\";";
}

sub check_start_and_stop {
  my ($slice,$trans) = @_;

  return (0,0) if (!defined($trans->translation));

  my $tln = $trans->translation;

  my $coding_start = $trans->cdna_coding_start;
  my $coding_end   = $trans->cdna_coding_end;
  my $cdna_seq     = uc($trans->spliced_seq);

  my $startseq     = substr($cdna_seq,$coding_start-1,3);
  my $endseq       = substr($cdna_seq,$coding_end-3,3);

  # print "Codons: " . $startseq . " " . $endseq . "\n";

  my $has_start = 1;
  my $has_end = 1;

  $has_start = 0  if ($startseq ne "ATG");
  $has_end = 0 if ($endseq ne "TAG" && $endseq ne "TGA" && $endseq ne "TAA");

  return ($has_start, $has_end);
}
