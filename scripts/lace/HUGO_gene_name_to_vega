#!/usr/bin/env perl

use warnings;


### HUGO_gene_name_to_vega

use strict;
use Bio::Otter::Lace::Defaults;
use Bio::Vega::DBSQL::DBAdaptor;
use GeneHist::DataUtils qw (process_query);
use Date::Calc qw(Date_to_Days);
use Hum::Chromoview::Utils qw(unixtime2YYYYMMDD);

# not doing gene type update anymore,
# as HGNC no longer assign gene type and takes the data from Otter

my %updated_gsid;

{
  my ($dataset_name);
  my $test = 1; # default is doing test

  Bio::Otter::Lace::Defaults::do_getopt(
                                        'ds|dataset=s'  => \$dataset_name,
                                        'test!'         => \$test,
                                       );
  Bio::Otter::Lace::Defaults::show_help() unless $dataset_name;

  print STDERR $test ? "Running in TEST mode ...\n\n" : "Running in LIVE mode ...\n\n";

  my $hugo_data = parse_hugo_input();

  my $cl         = Bio::Otter::Lace::Defaults::make_Client();
  my $ds         = $cl->get_DataSet_by_name($dataset_name);
  my $loutre_dba = $ds->make_Vega_DBAdaptor;

  $loutre_dba->begin_work;
  eval{
    update_otter($loutre_dba, $hugo_data, $test);
  };
  if ($@) {
    $loutre_dba->rollback;
    die $@, "\nNo changes saved to otter db\n";
  } else {
    $loutre_dba->commit;
  }
}

sub update_otter {
  my ($loutre_dba, $hugo_data, $test) = @_;

  my $counter = 0;
  my $geneAd = $loutre_dba->get_GeneAdaptor;
  foreach my $hugo (@$hugo_data) {

    my $hgnc_vegaID = $hugo->{'otter_gene_sid'};
    my $hgnc_id     = $hugo->{'hgnc_id'};
    my $hgnc_name   = $hugo->{'locus_symbol'};

    $counter++;

    print STDERR  "Working on hgncId $counter: $hgnc_vegaID\n";
    my $gene = $geneAd->fetch_by_stable_id($hgnc_vegaID);

    # human intervention for obsolete genes
    # send genes found here to HGNC for update
    unless ( $gene ){
      print STDERR "$hgnc_vegaID is OBSOLETE\n";
      next;
    }

    next if $gene->source ne 'havana';

    if (unexpected_gene_type($gene)) {
      printf STDERR "#Unexpected gene type '%s' in gene '%s' from HUGO: %s\n",
        $gene->biotype, $gene->stable_id, $hugo->{'original_line'};
      next;
    }

    #----------- IMPORTANT -------------------------------------
    # check this in the test mode and send it to annotator:
    # this will spot HGNC symbols that clash with existing
    # loutre symbols, as otherwise they will cause duplicate
    # gene name problem
    # check this in the test mode and send it to annotator
    # before doing Live update
    #-----------------------------------------------------------

    my $hgncSymbol_2_vegaIDs;
    if ( $test ){
      check_HUGO_symbol_is_unique_in_loutre($loutre_dba, $hgnc_name, $gene);
      push(@{$hgncSymbol_2_vegaIDs->{$hgnc_name}}, $hgnc_vegaID);
    }

    my $chr;
    if ( $gene->seq_region_name =~ /chr(\d+).*/ ){
      $chr = $1;
    }
    elsif ( $gene->seq_region_name =~ /^MHC/) {
      $chr = 6;
    }
    elsif ( $gene->seq_region_name =~ /^LRC/ ){
      $chr = 19;
    }

    update_gene_name_and_description($loutre_dba, $geneAd, $chr, $gene,
                                     $hgnc_name, $hugo->{'locus_description'},
                                     $hgnc_id, $test);
  }
}

sub check_HUGO_symbol_is_unique_in_loutre {
  my ($loutre_dba, $hgnc_name, $curr_gene) = @_;

  my $seq_region_name = $curr_gene->slice->seq_region_name;
  my $curr_gsid = $curr_gene->stable_id;

  print STDERR "DUP_SYMBOL_CHK for HUGO symbol $hgnc_name ($curr_gsid) --- ";

  my $dup = $loutre_dba->dbc->prepare(qq{
                                         SELECT gsi.stable_id, sr.name
                                         FROM gene_stable_id gsi, gene g, gene_attrib ga, attrib_type at, seq_region sr
                                         WHERE g.is_current = 1
                                         AND sr.seq_region_id=g.seq_region_id
                                         AND gsi.gene_id=g.gene_id
                                         AND g.gene_id=ga.gene_id
                                         AND ga.attrib_type_id=at.attrib_type_id
                                         AND at.code='name'
                                         AND ga.value=?
                                       });
  $dup->execute($hgnc_name);

  if ( $dup->rows != 0 ){
    my $failed = 0;
    while(my ($gsid, $seqRname)= $dup->fetchrow){
      if ( $gsid ne $curr_gsid and $seqRname eq $seq_region_name ){
        $failed = 1;
        print STDERR "symbol also used for $gsid in loutre db\n";
      }
    }
    print STDERR "PASSED\n" unless $failed;
  }
  else {
    print STDERR "PASSED\n";
  }
}

sub unexpected_gene_type {
  my( $gene ) = @_;

  my $type = $gene->biotype;
  if ($type =~ /:/ or $type eq 'obsolete') {
    return 1;
  } else {
    return 0;
  }
}
sub parse_hugo_input {
  my @field_names = qw{
                       locus_symbol locus_description hgnc_id otter_gene_sid locus_type
                     };

    my $hugo_data = [];
    while (<>) {
        next if /^\s*#/;                # Allow for hashed comment lines
        next if /^\s*$/;                # Skip empty lines
        next if /^Approved Symbol/;     # The header
        chomp;

        my @fields = split /\t/, $_;    # Fields should be tab separated
        my $original_line = $_;

        # There's something wrong with the line if we
        # don't have the right number of fields.
        unless (@fields == @field_names) {
            die 'Bad line: ', fmt_list(@fields);
        }

        my $parsed_line = {};
        for (my $i = 0 ; $i < @field_names ; $i++) {
            my $field_name = $field_names[$i];
            my $data = $fields[$i];
            $data =~ s/(^\s+)|(\s+$)//g;    # Trim leading and trailing whitespace
            unless ($data) {
                die 'Bad data element: ', fmt_list(@fields);
            }
            next if $data eq 'NULL';
            $parsed_line->{$field_name} = $data;
        }
        $parsed_line->{'original_line'} = $original_line;
        push(@$hugo_data, $parsed_line);
    }
    return $hugo_data;
}

sub fmt_list {
    return join(', ', map "'$_'", @_);
}

sub update_gene_name_and_description {
  my ( $loutre_dba, $geneAd, $chr, $gene, $hgnc_name, $hugo_desc, $hgnc_id, $test ) = @_;

  my $name_attr    = $gene->get_all_Attributes('name')->[0];
  my $current_name = $name_attr->value;
  my $current_desc = $gene->description;
  my $flag = 0;
  my $gsid = $gene->stable_id;
  my $curr_gene_id = $gene->dbID;
  my $biotype = $gene->biotype;
  my $status  = $gene->status;
  my $info = '';
  my $last_modified_date = unixtime2YYYYMMDD($gene->modified_date);

  if ( $updated_gsid{$gsid} ){
    print STDERR "SKIP $gsid ($curr_gene_id): already updated\n";
    next;
  }

  my $cmp = $hgnc_name eq $current_name ? 'SAME' : 'DIFF';
  print STDERR "$cmp - $hgnc_name (H) vs $current_name (V)\n";
  my $gids;

  print STDERR "SEARCHING for gene_names via prefixed_names and haplotype by $hgnc_name ... \n";
  $gids = find_genes_with_gene_names_from_prefixed_names_and_haplotype($loutre_dba, $geneAd, $hgnc_name, $chr);

  if ( ! $gids->[0] ) {
    print STDERR "NO matching gene_name found via prefixed_names and haplotypes by $hgnc_name\n";
    store_update($loutre_dba, $geneAd, $gene, $hgnc_name, $hugo_desc, $hgnc_id, $test);
    print STDERR "\n";
  } else {
    my $num = @$gids;

    my $search_name = $hgnc_name;
    if ( $hgnc_name =~ /:(\w+)/ ) {
      $search_name = $1;
    }
    print STDERR "MULTIPLE OCCURRENCE for $search_name: $num [@$gids]\n" if $num > 1;

    foreach my $gene_id ( @$gids ) {

      my $curr_gene  = $geneAd->fetch_by_dbID($gene_id);
      my $gsid       = $curr_gene->stable_id;

      # reason see store_gene() below
      if ( $updated_gsid{$gsid} ) {
        print STDERR "SKIP $gsid ($gene_id): already updated\n";
        next;
      }
      store_update($loutre_dba, $geneAd, $curr_gene, $hgnc_name, $hugo_desc, $hgnc_id, $test);
    }
    print STDERR "\n";
  }
}

sub store_geneId_consortiumID_mapping {
  my ($loutre_dba, $geneID, $hgncID) = @_;

  my $curdate = "now()";
  my $params = sprintf("%d, %s, %s", $geneID, "'".$hgncID."'", $curdate);
  my $sql = qq{REPLACE INTO gene_name_update (gene_id, consortium_id, update_date) VALUES($params)};
  my $update = $loutre_dba->dbc->prepare($sql);
  $update->execute;

}

sub find_genes_with_gene_names_from_prefixed_names_and_haplotype {
  my ($loutre_dba, $geneAd, $hgnc_name, $chr) = @_;

  my $search_name = $hgnc_name;
  if ( $hgnc_name =~ /\w+:(\w+)/ ){
    $search_name = $1;
  }

  my $mapping = get_expected_haplotype_from_chr($chr);

  my $sql = qq{SELECT sr.name, g.gene_id, gsi.stable_id, g.source
               FROM gene_attrib ga, gene_stable_id gsi, gene g, seq_region sr, attrib_type at
               WHERE sr.seq_region_id=g.seq_region_id
               AND g.gene_id=ga.gene_id
               AND g.gene_id=gsi.gene_id
               AND ga.attrib_type_id=at.attrib_type_id
               AND at.code='name'
               AND g.is_current = 1
             };

  my $prefix_match = qq{ AND ga.value like "%:$search_name"}; # look for prefixed gene names
  my $name_match   = qq{ AND ga.value = "$search_name"};      # look for identical gene names

  my $qryA = $loutre_dba->dbc->prepare($sql.$name_match);
  my $qryB = $loutre_dba->dbc->prepare($sql.$prefix_match);

  my $gids = get_gids($geneAd, $qryA, $qryB, $chr, $hgnc_name, $mapping);

  return $gids;
}

sub get_gids {
  my ($geneAd, $qryA, $qryB, $chr, $hgnc_name, $mapping) = @_;

  my $gids = [];

  print STDERR "SEARCHING for HAPLOTYPE(s) in ", join(', ', @$mapping), "\n" if $mapping && $mapping->[0];

  foreach my $qry ($qryA, $qryB) {
    $qry->execute;

    while ( my ( $seq_region_name, $gid, $gsid, $source ) = $qry->fetchrow ){
      my $gene = $geneAd->fetch_by_dbID($gid);
      next if $gene->source ne 'havana';

      # prefix : not yet happening for human as in mouse
      # just to have the code here for future use
      #if ( $source !~ /KO|WU|havana/ ){
      #  print STDERR "ERROR: FOUND unexpected $gsid in $seq_region_name, gid: $gid, source: $source\n";
      #  next;
      #}
      if ( ($mapping && $mapping->[0]) and $seq_region_name !~ /^chr/i  ){
        push(@$gids, $gid) if find_from_expected_haplotype($chr, $seq_region_name, $hgnc_name, $mapping, $gsid, $gid, $source);
      }
      else {
        print STDERR "FOUND $gsid (gene_id: $gid, source: $source) in ASSEMBLY $seq_region_name\n";
        push(@$gids, $gid);
      }
    }
  }
  return $gids;
}

sub find_from_expected_haplotype {

  my ($chr, $seq_region_name, $hgnc_name, $mapping, $gsid, $gid, $source) = @_;

  my $match;
  foreach ( @$mapping ) {
    #warn "$_ vs $seq_region --------\n";
    if ( index($seq_region_name, $_) == 0 ){
      $match = 1;
      print STDERR "FOUND $gsid (gene_id: $gid, source: $source) in HAPLOTYPE $seq_region_name\n";
    }
  }
  if ( $match ){
    return 1;
  }
  else {
    print STDERR "ERROR: $seq_region_name as haplotype unexpected for VEGA symbol $hgnc_name, source: $source\n";
    return 0;
  }
}

sub get_expected_haplotype_from_chr {

  my $chr = shift;

  my $map = {6  => [qw(MHC_APD MHC_COX MHC_DBB MHC_MANN MHC_MCF MHC_NCBI34 MHC_QBL MHC_SSTO MHC_PGF)],
             19 => [qw(LRC_COX LRC_DM1 LRC_MC1 LRC_PGF)]
            };

  return $map->{$chr} || undef;
}

sub store_update {

  my ($loutre_dba, $geneAd, $gene, $hgnc_symbol, $hgnc_desc, $hgnc_id, $test) = @_;

  my $name_attr  = $gene->get_all_Attributes('name')->[0];
  my $curr_name  = $name_attr->value;
  my $curr_desc  = $gene->description || 'NA';
  my $curr_stable_id = $gene->stable_id;
  my $source     = $gene->source;
  my $status     = $gene->status;
  my $biotype    = $gene->biotype;
  my $assembly   = $gene->slice->seq_region_name;
  my $prefixed_hugo_symbol = $source . ":" . $hgnc_symbol;
  my $need_update = 0;

  # code can be used in the future
  #if ( $source =~ /KO|WU/  ){
#    if ( $curr_name ne $prefixed_hugo_symbol ){
#      $need_update = 1;
#      $name_attr->value($prefixed_hugo_symbol);  # also update WashU and KO genes
#      print STDERR "NAME CHANGE from $curr_name ($curr_stable_id) to $prefixed_hugo_symbol ($biotype : $status) (non-havana)\n";
#    }
#    else {
#      print STDERR "NAME UP-TO-DATE: $source gene: $curr_name ($curr_stable_id)\n";
#    }
#  }

  if ( $hgnc_symbol and $hgnc_symbol ne $curr_name ){
    $need_update = 1;
    $name_attr->value($hgnc_symbol);
    print STDERR "NAME CHANGE from $curr_name ($curr_stable_id) to $hgnc_symbol => $assembly\n";
  }
  else {
    print STDERR "NAME UP-TO-DATE: $source gene: $curr_name ($curr_stable_id) => $assembly\n";
  }

  if ( $hgnc_desc and $hgnc_desc ne $curr_desc ){
    $need_update = 1;
    $gene->description($hgnc_desc);
    print STDERR "DESC CHANGE from '$curr_desc' to '$hgnc_desc' => $assembly\n";
  }
  else {
    print STDERR "DESC UP-TO-DATE: $source gene: $curr_name ($curr_stable_id) => $assembly\n";
  }

  # see subroutine for rules applied to status change
  if ( $need_update ) {
    $gene = change_gene_trans_status($loutre_dba, $geneAd, $gene, $hgnc_symbol);

    # store gene if not already locked on contig
    store_gene($loutre_dba, $geneAd, $gene, $hgnc_id, $curr_name) unless $test;
    print STDERR "\n";
  }
}

sub change_gene_trans_status {

  #----------------------------------------------------------------
  # update status rules for genes/transcripts with consortium name:
  # protein_coding  => KNOWN
  # all_pseudogenes => UNKNOWN (IGNORE genes MHC/LRC: no change)
  # all_transcripts => NOVEL
  # IGNORE artifact, polymorphic
  #----------------------------------------------------------------

  my ( $loutre_dba, $geneAd, $curr_gene, $hgnc_name ) = @_;


  # taking care of NcRNA
  if ( $hgnc_name =~ /NCRNA/i ){
    # transcript type for these needs to be non-coding
    foreach my $trans (@{ $curr_gene->get_all_Transcripts }) {
      my $t_biotype = $trans->biotype;
      my $tsid = $trans->stable_id;

      unless ( $t_biotype eq 'non_coding' ){
        print STDERR "TRAN TYPE CHANGE from $t_biotype to 'non_coding' ($tsid)\n";
        $trans->biotype('non_coding');
      }
    }
    return $curr_gene;
  }

  my $g_biotype = $curr_gene->biotype;
  my $g_status  = $curr_gene->status;

  if ( $g_biotype eq 'protein_coding' and $g_status ne 'KNOWN' ){
    print STDERR "GENE TYPE CHANGE from $g_status to KNOWN\n";
    $curr_gene->status('KNOWN');
    $curr_gene = check_single_transcript_status($curr_gene, 'KNOWN');
  }
  elsif ( $g_biotype eq 'polymorphic_pseudogene' and $g_status ne 'KNOWN' ){
    print STDERR "GENE TYPE CHANGE from $g_status to KNOWN\n";
    $curr_gene->status('KNOWN');
    $curr_gene = check_single_transcript_status($curr_gene, 'KNOWN');
  }
  elsif ( $g_biotype =~ /pseudogene/ and $g_status ne 'UNKNOWN' ){
    print STDERR "GENE TYPE CHANGE from $g_status to UNKNOWN\n";
    $curr_gene->status('UNKNOWN');
    $curr_gene = check_single_transcript_status($curr_gene, 'UNKNOWN');
  }
  elsif ( $g_biotype =~ /transcript/ and $g_status ne 'NOVEL') {
    print STDERR "GENE TYPE CHANGE from $g_status to NOVEL\n";
    $curr_gene->status('NOVEL');
    $curr_gene = check_single_transcript_status($curr_gene, 'NOVEL');
  }
  else {
    print STDERR "GENE STATUS OK: $g_status\n";
    $curr_gene = check_single_transcript_status($curr_gene, $g_status);
  }

  return $curr_gene;
}

sub check_single_transcript_status {

  my ( $curr_g, $status ) = @_;
  my @trans = @{$curr_g->get_all_Transcripts};

  # if a gene has only 1 transcript, make sure its status is same as gene
  if ( @trans == 1 ){
    my $t = $trans[0];
    print STDERR "TRAN STATUS change from ", $t->status, " to $status\n";
    $t->status($status);
  }
  else {
    print STDERR "TRAN STATUS: ", $curr_g->stable_id ,
      " (becomes $status) has ", scalar @trans, " variants - annotator to check\n";
  }
  return $curr_g;
}

sub store_gene {

  my ($loutre_dba, $geneAd, $gene, $hgnc_id, $old_name) = @_;

  my $gsid         = $gene->stable_id;
  my $curr_gene_id = $gene->dbID;

  # check lock before saving
  # use project as some genes span multiple clones
  if ( my $contig_lock = check_contig_lock($loutre_dba, $gene) ) {
    print STDERR "LOCK: $gsid is locked on @$contig_lock\n";
  }
  else {

    warn "storing gene......";
    $geneAd->store($gene);
    my $new_gene_id = $gene->dbID;

    printf STDERR ("Storing %s ==> Old dbID: %d New dbID: %d\n", $gsid, $curr_gene_id, $new_gene_id);

    my $sql = qq{ INSERT INTO gene_name_update VALUES(?,?,?, now()) };
    my $update = $loutre_dba->dbc->prepare($sql);
    $update->execute($new_gene_id, $hgnc_id, $old_name);

    # --------------------------------------- IMPORTANT -----------------------------------------------------------
    # Needs to record updated gsid to make sure no second update will be done with it
    # as gene_name is used to find those in haplotype and prefixed genes
    # ie, this avoids, eg,

    # MGI:96015	Hba-a1	hemoglobin alpha, adult chain 1	16.0	11	OTTMUSG00000005377 (old name is Hba-a2)
    # MGI:96016	Hba-a2	hemoglobin alpha, adult chain 2	16.0	11	OTTMUSG00000005376 (old name is Hba-a1)

    # As when the old Hba-a2 of OTTMUSG00000005377 is first changed to Hba-a1,
    # it comes to updating Hba-a1 of OTTMUSG00000005376.
    # Here, Hba-a1 is used to find all genes in haplotype and gene_names with
    #  "prefix:Hba-a1", which we also need to update.
    # So without excluding updated gsids, this will pick up Hba-a1 of OTTMUSG00000005377 and changes back to Hba-a2

    $updated_gsid{$gsid}++;
    #---------------------------------------------------------------------------------------------------------------
  }
}

sub check_contig_lock {
  my ($loutre_dba, $gene) = @_;

  my $lock = $loutre_dba->dbc->prepare(qq{
                               SELECT contig_lock_id
                               FROM contig_lock cl, seq_region sr
                               WHERE sr.name= ?
                               AND cl.seq_region_id=sr.seq_region_id
                             });

  my $locked_contigs;
  foreach my $p ( @{$gene->project('contig')}) {
    my $ctgname = $p->[2]->seq_region_name;
    $lock->execute( $ctgname );
    push(@$locked_contigs, $ctgname) if $lock->fetchrow;
  }

  return $locked_contigs;
}


__END__

=head1 NAME - HUGO_gene_name_to_vega

=head1 HOWTO

1st Step:
Get a fresh list of HUGO gene symbols/Gene Stable ID
wget "http://www.genenames.org/cgi-bin/hgnc_downloads.cgi?title=VEGA+output&col=gd_app_sym&col=gd_app_name&col=gd_hgnc_id&col=gd_vega_ids&col=gd_locus_type&status=Approved&status_opt=2&level=pri&where=gd_vega_ids+IS+NOT+NULL+AND+gd_vega_ids%20NOT%20LIKE%20%27%25%2C%20%25%27&order_by=gd_app_sym_sort&limit=&format=text&submit=submit&.cgifields=&.cgifields=level&.cgifields=chr&.cgifields=status&.cgifields=hgnc_dbtag" -O [HGNC_FILE]

URL -> Sting
http://www.genenames.org/cgi-bin/hgnc_downloads.cgi?
title=VEGA output&
col=gd_app_sym&
col=gd_app_name&
col=gd_hgnc_id&
col=gd_vega_ids&
col=gd_locus_type&
status=Approved&
status_opt=2&
level=pri&
where=gd_vega_ids IS NOT NULL AND gd_vega_ids NOT LIKE '%, %'&
order_by=gd_app_sym_sort&
limit=&
format=text&
submit=submit&
.cgifields=&
.cgifields=level&
.cgifields=chr&
.cgifields=status&
.cgifields=hgnc_dbtag

2nd Step:
Run the script in test mode with the freshly fetched list
HUGO_gene_name_to_vega -test -dataset human [HGNC_FILE]

3rd Step:
Run the script when the annotators are happy with the modifications
HUGO_gene_name_to_vega -notest -dataset human [HGNC_FILE]

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

Updated for loutre

Chao-Kung Chen B<email> ck1@sanger.ac.uk and
Mustapha Larbaoui B<email> ml6@sanger.ac.uk