#!/usr/local/bin/perl -w

### HUGO_gene_name_to_vega

use strict;
use Bio::Otter::Lace::Defaults;
use Bio::Vega::DBSQL::DBAdaptor;
use GeneHist::DataUtils qw (process_query);

# not doing gene type update anymore,
# as HGNC no longer assign gene type and takes the data from Otter

{
  my ($dataset_name, $test);

  Bio::Otter::Lace::Defaults::do_getopt(
                                        'ds|dataset=s' => \$dataset_name,
                                        'test'         => \$test
                                       );
  Bio::Otter::Lace::Defaults::show_help() unless $dataset_name;

  my $hugo_data = parse_hugo_input();

  my $cl         = Bio::Otter::Lace::Defaults::make_Client();
  my $ds         = $cl->get_DataSet_by_name($dataset_name);
  my $loutre_dba = $ds->make_Vega_DBAdaptor;

  $loutre_dba->begin_work;
  eval{
    update_otter($loutre_dba, $hugo_data, $test);
  };
  if ($@) {
    $loutre_dba->rollback;
    die $@, "\nNo changes saved to otter db\n";
  } else {
    $loutre_dba->commit;
  }
}

sub update_otter {
  my ($loutre_dba, $hugo_data, $test) = @_;

  my $gene_aptr = $loutre_dba->get_GeneAdaptor;
  foreach my $hugo (@$hugo_data) {

    my $gene_SID = $hugo->{'otter_gene_sid'};
    my $hgnc_id   = $hugo->{'hgnc_id'};

    # warn "Working on $gene_SID\n";
    my $gene = $gene_aptr->fetch_by_stable_id($gene_SID);

    # human intervention for obsolete genes
    # send genes found here to HGNC for update
    unless ( $gene ){
      print STDERR "$gene_SID is obsolete\n";

      # tracking gene history for obsolete genes
      my $found_gsids;
      eval {
        $found_gsids = process_query($gene_SID, $loutre_dba, undef, 1);
      };
      if ( $@ ){
        print STDERR "Cannot follow history of $gene_SID ... non-existent ID\n\n";
        next;
      }
      else {
        foreach my $gsid ( @$found_gsids ){
          # want only current genes
          if ( $gene_aptr->fetch_by_stable_id($gsid) ){
            print STDERR "==> $gsid has replaced $gene_SID\n";
          }
          else {
            print STDERR "==> $gsid is OBSOLETE\n";
          }
        }
        print STDERR "\n";
        next;
      }
    }
    next if $gene->source ne 'havana';

    if (unexpected_gene_type($gene)) {
      printf STDERR "#Unexpected gene type '%s' in gene '%s' from HUGO: %s\n",
        $gene->biotype, $gene->stable_id, $hugo->{'original_line'};
      next;
    }

    update_gene_name_and_description($loutre_dba, $gene_aptr, $gene, $hugo->{'locus_symbol'}, $hugo->{'locus_description'}, $hgnc_id, $test);
  }
}

sub unexpected_gene_type {
  my( $gene ) = @_;

  my $type = $gene->biotype;
  if ($type =~ /:/ or $type eq 'obsolete') {
    return 1;
  } else {
    return 0;
  }
}
sub parse_hugo_input {
  my @field_names = qw{
                       locus_symbol locus_description hgnc_id category otter_gene_sid locus_type notes
                     };

    my $hugo_data = [];
    while (<>) {
        next if /^\s*#/;                # Allow for hashed comment lines
        next if /^\s*$/;                # Skip empty lines
        next if /^Approved Symbol/;     # The header
        chomp;

        my @fields = split /\t/, $_;    # Fields should be tab separated
        my $original_line = $_;

        # There's something wrong with the line if we
        # don't have the right number of fields.
        unless (@fields == @field_names) {
            die 'Bad line: ', fmt_list(@fields);
        }

        my $parsed_line = {};
        for (my $i = 0 ; $i < @field_names ; $i++) {
            my $field_name = $field_names[$i];
            my $data = $fields[$i];
            $data =~ s/(^\s+)|(\s+$)//g;    # Trim leading and trailing whitespace
            unless ($data) {
                die 'Bad data element: ', fmt_list(@fields);
            }
            next if $data eq 'NULL';
            $parsed_line->{$field_name} = $data;
        }
        $parsed_line->{'original_line'} = $original_line;
        push(@$hugo_data, $parsed_line);
    }
    return $hugo_data;
}

sub fmt_list {
    return join(', ', map "'$_'", @_);
}

sub update_gene_name_and_description {
  my ( $loutre_dba, $gene_aptr, $gene, $hugo_name, $hugo_desc, $hgnc_id, $test ) = @_;

  my $name_attr    = $gene->get_all_Attributes('name')->[0];
  my $current_name = $name_attr->value;
  my $current_desc = $gene->description;
  my $flag = 0;
  my $gsid = $gene->stable_id;
  my $curr_gene_id = $gene->dbID;
  my $biotype = $gene->biotype;
  my $status  = $gene->status;
  my $info = '';

  if ( $hugo_name and $current_name ne $hugo_name) {
    $flag = 1;
    $name_attr->value($hugo_name);
    $info .= "NAME CHANGE from '$current_name' to '" . $name_attr->value . "' ($biotype : $status)\n";

    # all protein_coding genes should be known if got HGNC name
    if ( $biotype eq 'protein_coding' and $status ne 'KNOWN' ){
      $info .= "TYPE CHANGE from $status to 'KNOWN'\n";
      $gene->status('KNOWN');
    }
    elsif ( $biotype =~ /pseudo/i and $status ne 'UNKNOWN' ){
      $info .= "TYPE CHANGE from $status to 'UNKNOWN'\n";
      $gene->status('UNKNOWN');
    }

    # taking care of NcRNA
    if ( $hugo_name =~ /NCRNA/i ){
      # transcript type for these needs to be non-coding
      foreach my $trans (@{ $gene->get_all_Transcripts }) {
        my $t_biotype = $trans->biotype;
        my $tsid = $trans->stable_id;

        unless ( $t_biotype eq 'non_coding' ){
          print STDERR "TYPE CHANGE from $t_biotype to 'non_coding' ($tsid)\n";
          $trans->biotype('non_coding');
        }
      }
    }
  }
  if ( $hugo_desc and $hugo_desc ne $current_desc ){
    $flag = 1;
    $gene->description($hugo_desc);
    $info .= "DESC CHANGE from '$current_desc' to '" . $gene->description . "'\n";
  }

  print STDERR "CHECKING: $gsid $current_name (V) $hugo_name (H)\n" . $info . "\n" if $flag == 1;

  return if $test;

  # store gene
  if ( $flag == 1 ){

    # check lock before saving
    # use project as some genes span multiple clones
    if ( my $contig_lock = check_contig_lock($loutre_dba, $gene) ) {
      print STDERR "LOCK: $gsid is locked on @$contig_lock\n";
    }
    else {
      print STDERR "Storing $gsid ...\n";
      $gene_aptr->store($gene);

      my $new_gene_id  = $gene_aptr->fetch_by_stable_id($gsid)->dbID;
      printf STDERR ("Storing %s ==> Old dbID: %d New dbID: %d\n", $gsid, $curr_gene_id, $new_gene_id);
      store_geneId_consortiumID_mapping($loutre_dba, $new_gene_id, $hgnc_id);
    }
  }
  else {
    printf STDERR ("Storing %s ==> dbID: %d HGNC_ID: %d\n", $gsid, $curr_gene_id, $hgnc_id);
    store_geneId_consortiumID_mapping($loutre_dba, $curr_gene_id, $hgnc_id);
  }
}

sub store_geneId_consortiumID_mapping {
  my ($loutre_dba, $geneID, $hgncID) = @_;

  my $curdate = "now()";
  my $params = sprintf("%d, %s, %s", $geneID, "'".$hgncID."'", $curdate);
  my $sql = qq{REPLACE INTO gene_name_update (gene_id, consortium_id, update_date) VALUES($params)};
  my $update = $loutre_dba->dbc->prepare($sql);
  $update->execute;

}

sub check_contig_lock {
  my ($loutre_dba, $gene) = @_;

  my $lock = $loutre_dba->dbc->prepare(qq{
                               SELECT contig_lock_id
                               FROM contig_lock cl, seq_region sr
                               WHERE sr.name= ?
                               AND cl.seq_region_id=sr.seq_region_id
                             });

  my $locked_contigs;
  foreach my $p ( @{$gene->project('contig')}) {
    my $ctgname = $p->[2]->seq_region_name;
    $lock->execute( $ctgname );
    push(@$locked_contigs, $ctgname) if $lock->fetchrow;
  }

  return $locked_contigs;
}


__END__

=head1 NAME - HUGO_gene_name_to_otter

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

Updated for loutre

Chao-Kung Chen B<email> ck1@sanger.ac.uk


