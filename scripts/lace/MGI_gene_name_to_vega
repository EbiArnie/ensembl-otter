#!/usr/local/bin/perl -w

use strict;
use Bio::Otter::Lace::Defaults;
use Bio::Vega::DBSQL::DBAdaptor;

my %updated_gsid;

{
  my ($dataset_name);
  my $test = 0; # default is NOT doing test

  Bio::Otter::Lace::Defaults::do_getopt(
                                        'ds|dataset=s' => \$dataset_name,
                                        'test'         => \$test,
                                       );
  Bio::Otter::Lace::Defaults::show_help() unless $dataset_name;

  my $cl         = Bio::Otter::Lace::Defaults::make_Client();
  my $ds         = $cl->get_DataSet_by_name($dataset_name);
  my $loutre_dba = $ds->make_Vega_DBAdaptor;
  my $geneAd     = $loutre_dba->get_GeneAdaptor;

  my ($mgi_data, $problem_symbol) = parse_mgi_input($geneAd);

  $loutre_dba->begin_work;
  eval{
    update_loutre($loutre_dba, $mgi_data, $test, $problem_symbol);
  };
  if ($@) {
    $loutre_dba->rollback;
    die $@, "\nNo changes saved to otter db\n";
  } else {
    $loutre_dba->commit;
  }
}

sub update_loutre {
  my ($loutre_dba, $mgi_data, $test, $problem_symbol) = @_;

  my $geneAd  = $loutre_dba->get_GeneAdaptor;
  my $sliceAd = $loutre_dba->get_SliceAdaptor;

  foreach my $mgi (@$mgi_data) {

    my $gene_SID   = $mgi->{'vega_id'};

    if ( $mgi->{'locus_symbol'} eq 'Tcra-V8' ){ # temporarily
      warn "SKIP Tcra-8 for now";
      next;
    }

    my $mgi_symbol = $mgi->{'locus_symbol'};
    if ( grep(/$mgi_symbol/, @$problem_symbol) ){
      next;
    }

    my $mgi_id     = $mgi->{'mgi_id'};
    my $mgi_desc   = $mgi->{'locus_description'};
    my $mgi_chr    = $mgi->{'chromosome'};

    my $curr_gene = $geneAd->fetch_by_stable_id($gene_SID);

    # double check MGI VEGA chr
    $curr_gene->slice->seq_region_name =~ /^chr(\w+)-/;
    my $chr = $1;
    unless ( $chr eq $mgi_chr ){
      print STDERR "ERROR: chromosome diff: $chr (V) vs $mgi_chr (M)\n";
      next;
    }

    my $curr_gene_name  = $curr_gene->get_all_Attributes('name')->[0]->value;
    if ( $curr_gene_name ne $mgi_symbol ){
      print STDERR "DIFF: $gene_SID $curr_gene_name (V) $mgi_symbol (M)\n";
      update_gene_name_and_description($chr, $loutre_dba, $geneAd, $curr_gene, $curr_gene_name, $mgi_id, $mgi_symbol, $mgi_desc, $test);
    }
  }
}

sub parse_mgi_input {

  my ($geneAd) = @_;
  my @field_names = qw{
                       mgi_id locus_symbol locus_description score chromosome vega_id
                     };

  my $mgi_data = [];
  my $mgiSymbol_2_vegaIDs = {}; # for checking symbols linked to multiple VEGA ids
                               # as there were quite a few in MGI data

  # bad vega ids (obsolte or source is not 'havana') are filtered
  while (<>) {
    chomp;

    my @fields = split /\t/, $_; # Fields should be tab separated
    my $original_line = $_;

    # There's something wrong with the line if we
    # don't have the right number of fields.
    unless (@fields == @field_names) {
      die 'Bad line: ', fmt_list(@fields);
    }

    my $vega_id_from_mgi = $fields[5];
    my $curr_gene = $geneAd->fetch_by_stable_id($vega_id_from_mgi);

    unless ( $curr_gene ){
      print STDERR "ERROR: $vega_id_from_mgi NOT CURRENT in database\n";
      next;
    }

    my $mgi_symbol = $fields[1];

    my $source = $curr_gene->source;
    # double check that MGI update only contains genes which source is 'havana/WU'
    if ( $source ne 'havana' and $source ne 'WU'){
      print STDERR "SKIP: $vega_id_from_mgi source is $source\n";
      next;
    }

    my $parsed_line = {};

    # currently, lots of MGI names are still bad names!
    my $ok = check_for_good_symbols($mgi_symbol, $vega_id_from_mgi);

    if ( $ok ){
      for (my $i = 0 ; $i < @field_names ; $i++) {
        my $field_name = $field_names[$i];
        my $data = $fields[$i];
        $data =~ s/(^\s+)|(\s+$)//g; # Trim leading and trailing whitespace
        unless ($data) {
          die 'Bad data element: ', fmt_list(@fields);
        }
        next if $data eq 'NULL';

        $parsed_line->{$field_name} = $data if $ok;
      }

      push(@{$mgiSymbol_2_vegaIDs->{$mgi_symbol}}, $vega_id_from_mgi);

      $parsed_line->{'original_line'} = $original_line;
      push(@$mgi_data, $parsed_line);
    }
  }

  my $problem_symbol = [];
  foreach my $symbol ( keys %$mgiSymbol_2_vegaIDs ){
    if ( @{$mgiSymbol_2_vegaIDs->{$symbol}} > 1 ){

#      my $ok = check_for_good_symbols($symbol);
      my $val = check_for_good_symbols($symbol) ? 'good' : 'bad';

      print STDERR "MGI_2_MULTILE_IDs $symbol: ($val) @{$mgiSymbol_2_vegaIDs->{$symbol}}\n";
      # don't want to update loutre with such gene names.
      # give annotators to look at them first
      push(@$problem_symbol, $symbol);
    }
  }

  return ($mgi_data, $problem_symbol);
}

sub check_for_good_symbols {
  my ($mgi_symbol, $gsid_from_mgi) = @_;

  # symbols to ignore (per info from HAVANA: Jane L.)
  my @ignore_list = qw(D1Ertd622e D1Ertd471e D1Pas1 D2Bwg1335e D2Ertd391e
                       U46068 N28178 D4Wsu132e D4Bwg0951e C87499 C77080 D4Ertd196e C79267
                       D4Ertd22e C87977 D4Wsu114e D6Mm5e D8Ertd457e C86695 P140 X83328
                       D11Wsu99e D11Wsu47e D11Bwg0517e C79407 D12Ertd647e D16Ertd472e D17Wsu92e
                       C77370);

  # non-standard, but ok (per info from HAVANA: Jane L.)
  my @usable_list = qw(B3gat2 C4bp B3galt2 C8g S100a7a C1qc C1qdc2 C1qtnf
                       P2rx7 B3gnt4 B3galtl C1galt1 H1fx B4galnt3 M6pr E2f8 p P4ha3 B3gat1
                       C1qtnf5 H2afv C1d B3gnt2 C1qtnf2 G3bp1 B9d1 B4galnt2 B3gntl1 B4galt7
                       C1qtnf9 R3hcc1 C9 C1qtnf3 B3gnt5 B4galt4 N6amt1 T L3mbtl4 F9 P2ry10);

  # also ignore these:
  #   clone based names - starting with two capital letters
  #   names that are Gene models - starting with Gm
  #   riken based names - end with Rik

  if ( $mgi_symbol =~ /^[A-Z]{2,2}|^Gm|Rik$|OTTMUS/ ){
    #    print STDERR "TO ignore: $mgi_symbol";
    return 0;
  }
  elsif ( grep(/$mgi_symbol/, @ignore_list) ){
    #print STDERR $mgi_symbol;
    return 0;
  }
  # give these names to HAVANA, as some could be usable
  elsif ( ( $mgi_symbol =~ /^[A-Z]{1,1}\d+/ or $mgi_symbol =~ /^[A-Z]{1,1}$/ ) and
          ! grep(/$mgi_symbol/, @usable_list) ){
    print STDERR "SYMBOL_TO_CHECK: $gsid_from_mgi $mgi_symbol\n";
    return 0;
  }
  # standard names we want
  elsif ( $mgi_symbol =~ /^[A-Z]{1,1}[a-z]{1,1}/ or /[a-z]{2,2}/ ){
    return 1;
  }
  else {
    print STDERR "SURPRISE: $gsid_from_mgi $mgi_symbol\n";
    return 0;
  }
}

sub fmt_list {
    return join(', ', map "'$_'", @_);
}

sub update_gene_name_and_description {

  my ( $chr, $loutre_dba, $geneAd, $gene, $vega_name, $mgi_id, $mgi_symbol, $mgi_desc, $test) = @_;

  # find all current genes with prefix:$vega_name and from its haplotype
  warn "Finding all genes with PREFIX:$vega_name\n";
  my $gids = find_prefixed_genes($loutre_dba, $vega_name, $chr);

  my $num = @$gids;
  print STDERR "MULTIPLE OCCURRENCE: $num [@$gids]\n" if $num > 1;

  # find haplotype for the chr, if any
  foreach my $gene_id ( @$gids ){

    my $curr_gene  = $geneAd->fetch_by_dbID($gene_id);
    my $gsid       = $curr_gene->stable_id;

    # reason see store_gene() below
    if ( $updated_gsid{$gsid} ){
      print STDERR "SKIP $gsid ($gene_id)\n";
      next;
    }

    my $name_attr  = $curr_gene->get_all_Attributes('name')->[0];
    my $curr_name  = $name_attr->value;
    my $curr_desc  = $curr_gene->description || 'NA';
    my $seq_region = $curr_gene->slice->seq_region_name;
    my $source     = $curr_gene->source;

    print STDERR "CHECKING $gsid on $seq_region SOURCE $source\n";

    if ( $source ne 'havana' ){
      my $prefixed_mgi_symbol = $source . ":" . $mgi_symbol;

      unless ( $curr_name eq $prefixed_mgi_symbol ){
        print STDERR "NAME   CHANGE from $curr_name to $prefixed_mgi_symbol\n";
        $name_attr->value($prefixed_mgi_symbol);
      }
      else {
        print STDERR "SKIP WU update from $curr_name to $prefixed_mgi_symbol\n";
      }
    }
    else {
      print STDERR "NAME   CHANGE from $curr_name to $mgi_symbol\n";
      $name_attr->value($mgi_symbol);
    }

    if ( $mgi_desc and $mgi_desc ne $curr_desc ){
      $curr_gene->description($mgi_desc);
      print STDERR "DESC   CHANGE from '$curr_desc' to '$mgi_desc'\n";
    }
    if ( $curr_gene->status ne 'KNOWN' ){
      print STDERR "STATUS CHANGE from ", $curr_gene->status, " to KNOWN\n";
    }

    # store gene if not already locked on contig
    store_gene($loutre_dba, $geneAd, $curr_gene, $mgi_id) unless $test;

    print STDERR "\n";
  }
}

sub find_prefixed_genes {
  my ($loutre_dba, $vega_name, $chr) = @_;

  my $mapping = get_expected_haplotype_from_chr($chr);
  my $sql = qq{SELECT sr.name, g.gene_id
               FROM gene_attrib ga, gene g, seq_region sr, attrib_type at
               WHERE sr.seq_region_id=g.seq_region_id
               AND g.gene_id=ga.gene_id
               AND ga.attrib_type_id=at.attrib_type_id
               AND at.code='name'
               AND g.is_current = 1
               AND ga.value like "%$vega_name"};

 # warn $sql;
  my $qry = $loutre_dba->dbc->prepare($sql);
  $qry->execute();

  my $gids;
  while ( my ( $seq_region, $gid ) = $qry->fetchrow ){

    if ( $mapping->[0] and $seq_region !~ /^chr/i ){
      push(@$gids, $gid) if find_haplotype_update($chr, $seq_region, $vega_name, $mapping);
    }
    elsif ($seq_region =~ /^chr/i ) {
      push(@$gids, $gid);
    }
  }

  return $gids;
}

sub store_gene {

  my ($loutre_dba, $geneAd, $gene, $mgi_id) = @_;

  # make sure status becomes KNOWN
  $gene->status('KNOWN') unless $gene->status eq 'KNOWN';

  my $gsid         = $gene->stable_id;
  my $curr_gene_id = $gene->dbID;

  # check lock before saving
  # use project as some genes span multiple clones
  if ( my $contig_lock = check_contig_lock($loutre_dba, $gene) ) {
    print STDERR "LOCK: $gsid is locked on @$contig_lock\n";
  }
  else {
    $geneAd->store($gene);
    my $new_gene_id = $gene->dbID;
    printf STDERR ("Storing %s ==> Old dbID: %d New dbID: %d\n", $gsid, $curr_gene_id, $new_gene_id);

    my $curdate = "now()";
    my $params = sprintf("%d, %s, %s", $new_gene_id, "'".$mgi_id."'", $curdate);
    my $sql = qq{INSERT INTO gene_name_update (gene_id, consortium_id, update_date) VALUES($params)};
    my $update = $loutre_dba->dbc->prepare($sql);
    $update->execute;

    # --------------------------------------- IMPORTANT -----------------------------------------------------------
    # Needs to record updated gsid to make sure no second update will be done with it
    # as gene_name is used to find those in haplotype and prefixed genes
    # ie, this avoids, eg,

    # MGI:96015	Hba-a1	hemoglobin alpha, adult chain 1	16.0	11	OTTMUSG00000005377 (old name is Hba-a2)
    # MGI:96016	Hba-a2	hemoglobin alpha, adult chain 2	16.0	11	OTTMUSG00000005376 (old name is Hba-a1)

    # As when the old Hba-a2 of OTTMUSG00000005377 is first changed to Hba-a1,
    # it comes to updating Hba-a1 of OTTMUSG00000005376.
    # Here, Hba-a1 is used to find all genes in haplotype and gene_names with
    #  "prefix:Hba-a1", which we also need to update.
    # So without excluding updated gsids, this will pick up Hba-a1 of OTTMUSG00000005377 and changes back to Hba-a2
    $updated_gsid{$gsid}++;
    #---------------------------------------------------------------------------------------------------------------
  }
}

sub find_haplotype_update {

  my ($chr, $seq_region, $vega_name, $mapping) = @_;

  warn "HAPLOTYPE: @$mapping\n";
  my $match;
  foreach ( @$mapping ) {
    warn "$_ vs $seq_region --------\n";
    if ( index($seq_region, $_) == 0 ){
      $match = 1;
      print STDERR "HAPLOTYPE UPDATE: $seq_region\n";
      return 1;
    }
  }
  unless ( $match ){
    print STDERR "ERROR: $seq_region unexpected for VEGA symbol $vega_name\n";
    return 0;
  }
}

sub get_expected_haplotype_from_chr {

  my $chr = shift;

  my $map = {1  => [qw(NOD_IDD5.1 CHORI29_IDD5.1_test NOD_IDD5.4)],
             3  => [qw(129_IDD3 NOD_IDD3 NOD_IDD10 NOD_IDD18)],
             4  => [qw(129_MUP B6_MUP NOD_IDD9 mrc4)],
             6  => [qw(CHO_IDD6)],
             11 => [qw(CHO_IDD4 NOD_IDD4 lace_chr11_clones4)],
             17 => [qw(CHO_IDD16 mhc_4)]
            };

  return $map->{$chr};
}

sub check_contig_lock {
  my ($loutre_dba, $gene) = @_;

  my $lock = $loutre_dba->dbc->prepare(qq{
                               SELECT contig_lock_id
                               FROM contig_lock cl, seq_region sr
                               WHERE sr.name= ?
                               AND cl.seq_region_id=sr.seq_region_id
                             });

  my $locked_contigs;
  foreach my $p ( @{$gene->project('contig')}) {
    my $ctgname = $p->[2]->seq_region_name;
    $lock->execute( $ctgname );
    push(@$locked_contigs, $ctgname) if $lock->fetchrow;
  }

  return $locked_contigs;
}

__END__

=head1 NAME - MGI_gene_name_to_vega

=head1 AUTHOR

Modified from HUGO_gene_name_to_vega

Chao-Kung Chen B<email> ck1@sanger.ac.uk


