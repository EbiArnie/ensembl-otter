#!/usr/local/bin/perl -w

use strict;
use Bio::Otter::Lace::Defaults;
use Bio::Vega::DBSQL::DBAdaptor;

{
  my ($dataset_name);
  my $test = 0; # default is NOT doing test

  Bio::Otter::Lace::Defaults::do_getopt(
                                        'ds|dataset=s' => \$dataset_name,
                                        'test'         => \$test
                                       );
  Bio::Otter::Lace::Defaults::show_help() unless $dataset_name;

  my $cl         = Bio::Otter::Lace::Defaults::make_Client();
  my $ds         = $cl->get_DataSet_by_name($dataset_name);
  my $loutre_dba = $ds->make_Vega_DBAdaptor;
  my $geneAd     = $loutre_dba->get_GeneAdaptor;

  my $mgi_data = parse_mgi_input($geneAd);

  $loutre_dba->begin_work;
  eval{
    update_loutre($loutre_dba, $mgi_data, $test);
  };
  if ($@) {
    $loutre_dba->rollback;
    die $@, "\nNo changes saved to otter db\n";
  } else {
    $loutre_dba->commit;
  }
}

sub update_loutre {
  my ($loutre_dba, $mgi_data, $test) = @_;

  my $geneAd  = $loutre_dba->get_GeneAdaptor;
  my $sliceAd = $loutre_dba->get_SliceAdaptor;

  foreach my $mgi (@$mgi_data) {

    my $mgi_symbol = $mgi->{'locus_symbol'};
    my $gene_SID   = $mgi->{'vega_id'};
    my $mgi_id     = $mgi->{'mgi_id'};
    my $mgi_desc   = $mgi->{'locus_description'};
    my $mgi_chr    = $mgi->{'chromosome'};

    my $curr_gene = $geneAd->fetch_by_stable_id($gene_SID);

    # double check MGI VEGA chr
    $curr_gene->slice->seq_region_name =~ /^chr(\w+)-/;
    my $chr = $1;
    unless ( $chr eq $mgi_chr ){
      print STDERR "ERROR: chromosome diff: $chr (V) vs $mgi_chr (M)\n";
      next;
    }

    my $curr_gene_name  = $curr_gene->get_all_Attributes('name')->[0]->value;
    if ( $curr_gene_name ne $mgi_symbol ){
      print STDERR "DIFF: $gene_SID $curr_gene_name (V) $mgi_symbol (M)\n";
      update_gene_name_and_description($chr, $loutre_dba, $geneAd, $curr_gene, $curr_gene_name, $mgi_id, $mgi_symbol, $mgi_desc, $test);
    }
  }
}

sub parse_mgi_input {

  my $geneAd = shift;
  my @field_names = qw{
                       mgi_id locus_symbol locus_description score chromosome vega_id
                     };

  my $mgi_data = [];

  # bad vega ids (obsolte or source is not 'havana') are filtered
  while (<>) {
    chomp;

    my @fields = split /\t/, $_; # Fields should be tab separated
    my $original_line = $_;

    # There's something wrong with the line if we
    # don't have the right number of fields.
    unless (@fields == @field_names) {
      die 'Bad line: ', fmt_list(@fields);
    }

    my $vega_id_from_mgi = $fields[5];
    my $curr_gene = $geneAd->fetch_by_stable_id($vega_id_from_mgi);

    unless ( $curr_gene ){
      print STDERR "ERROR: $vega_id_from_mgi NOT FOUND in database\n";
      next;
    }

    my $source = $curr_gene->source;
    # double check that MGI update only contains genes which source is 'havana'
    if ( $source ne 'havana' ){
      print STDERR "SKIP: $vega_id_from_mgi source is $source\n";
      next;
    }

    my $parsed_line = {};

    # currently, lots of MGI name are still bad names!
    my $ok = check_for_good_symbols($fields[1], $vega_id_from_mgi);

    if ( $ok ){
      for (my $i = 0 ; $i < @field_names ; $i++) {
        my $field_name = $field_names[$i];
        my $data = $fields[$i];
        $data =~ s/(^\s+)|(\s+$)//g; # Trim leading and trailing whitespace
        unless ($data) {
          die 'Bad data element: ', fmt_list(@fields);
        }
        next if $data eq 'NULL';

        $parsed_line->{$field_name} = $data if $ok;
      }
      $parsed_line->{'original_line'} = $original_line;
      push(@$mgi_data, $parsed_line);
    }
  }
  return $mgi_data;
}

sub check_for_good_symbols {
  my ($mgi_symbol, $gsid_from_mgi) = @_;

  # symbols to ignore (per info from HAVANA: Jane L.)
  my @ignore_list = qw(D1Ertd622e D1Ertd471e D1Pas1 D2Bwg1335e D2Ertd391e
                       U46068 N28178 D4Wsu132e D4Bwg0951e C87499 C77080 D4Ertd196e C79267
                       D4Ertd22e C87977 D4Wsu114e D6Mm5e D8Ertd457e C86695 P140 X83328
                       D11Wsu99e D11Wsu47e D11Bwg0517e C79407 D12Ertd647e D16Ertd472e D17Wsu92e
                       C77370);

  # non-standard, but ok (per info from HAVANA: Jane L.)
  my @usable_list = qw(B3gat2 C4bp B3galt2 C8g S100a7a C1qc C1qdc2 C1qtnf
                       P2rx7 B3gnt4 B3galtl C1galt1 H1fx B4galnt3 M6pr E2f8 p P4ha3 B3gat1
                       C1qtnf5 H2afv C1d B3gnt2 C1qtnf2 G3bp1 B9d1 B4galnt2 B3gntl1 B4galt7
                       C1qtnf9 R3hcc1 C9 C1qtnf3 B3gnt5 B4galt4 N6amt1 T L3mbtl4 F9 P2ry10);

  # also ignore these:
  #   clone based names - starting with two capital letters
  #   names that are Gene models - starting with Gm
  #   riken based names - end with Rik

  if ( $mgi_symbol =~ /^[A-Z]{2,2}|^Gm|Rik$|OTTMUS/ ){
    #    print STDERR "TO ignore: $mgi_symbol";
    return 0;
  }
  elsif ( grep(/$mgi_symbol/, @ignore_list) ){
    #print STDERR $mgi_symbol;
    return 0;
  }
  # give these names to HAVANA, as some could be usable
  elsif ( ( $mgi_symbol =~ /^[A-Z]{1,1}\d+/ or $mgi_symbol =~ /^[A-Z]{1,1}$/ ) and
          ! grep(/$mgi_symbol/, @usable_list) ){
    print STDERR "SYMBOL_TO_CHECK: $gsid_from_mgi $mgi_symbol\n";
    return 0;
  }
  # standard names we want
  elsif ( $mgi_symbol =~ /^[A-Z]{1,1}[a-z]{1,1}/ or /[a-z]{2,2}/ ){
    return 1;
  }
  else {
    print STDERR "SURPRISE: $gsid_from_mgi $mgi_symbol\n";
    return 0;
  }
}

sub fmt_list {
    return join(', ', map "'$_'", @_);
}

sub update_gene_name_and_description {

  my ( $chr, $loutre_dba, $geneAd, $gene, $vega_name, $mgi_id, $mgi_symbol, $mgi_desc, $test) = @_;

  # find haplotype for the chr, if any
  my $mapping = get_expected_haplotype_from_chr($chr);

  # look for gene stable ids from both reference haploptype
  # only want current genes: specify as 1
  my $gsids = $geneAd->fetch_stable_id_by_name($vega_name, 'gene', 1);

  my $num = @$gsids;
  my @ids = @$gsids;
  print STDERR "MULTIPLE OCCURRENCE: $num @ids\n" if $num > 1;

  foreach my $gsid (@$gsids ){

    my $flag = 0;
    my $gene         = $geneAd->fetch_by_stable_id($gsid);
    my $name_attr    = $gene->get_all_Attributes('name')->[0];
    my $current_name = $name_attr->value;
    my $current_desc = $gene->description || 'NA';
    my $seq_region   = $gene->slice->seq_region_name;
    my $source       = $gene->source;

    print STDERR "CHECKING $gsid on $seq_region SOURCE $source\n";

    if ( $mapping->[0] and $seq_region !~ /^chr/i ){
      warn "MAPPING";
      next unless find_haplotype_update($chr, $seq_region, $vega_name, $mapping);
    }

    $mgi_symbol = $source . ":" . $mgi_symbol if $source ne 'havana';

    # also check haplotype gene name
    if ( $current_name ne $mgi_symbol ){
      $flag = 1;
      print STDERR "NAME   CHANGE from $current_name to $mgi_symbol\n";
      $name_attr->value($mgi_symbol);
    }
    if ( $mgi_desc and $mgi_desc ne $current_desc ){
      $flag = 1;
      $gene->description($mgi_desc);
      print STDERR "DESC   CHANGE from '$current_desc' to '$mgi_desc'\n";
    }
    if ( $gene->status ne 'KNOWN' ){
      $flag = 1;
      print STDERR "STATUS CHANGE from ", $gene->status, " to KNOWN\n";
    }

    # store gene if not already locked on contig
    store_gene($loutre_dba, $geneAd, $gene, $mgi_id) if ( !$test and $flag == 1 );

    print STDERR "\n";
  }
}

sub store_gene {

  my ($loutre_dba, $geneAd, $gene, $mgi_id) = @_;

  # make sure status becomes KNOWN
  $gene->status('KNOWN') unless $gene->status eq 'KNOWN';

  my $gsid         = $gene->stable_id;
  my $curr_gene_id = $gene->dbID;

  # check lock before saving
  # use project as some genes span multiple clones
  if ( my $contig_lock = check_contig_lock($loutre_dba, $gene) ) {
    print STDERR "LOCK: $gsid is locked on @$contig_lock\n";
  }
  else {
    $geneAd->store($gene);

    my $new_gene_id = $geneAd->fetch_by_stable_id($gsid)->dbID;
    printf STDERR ("Storing %s ==> Old dbID: %d New dbID: %d\n", $gsid, $curr_gene_id, $new_gene_id);

    my $curdate = "now()";
    my $params = sprintf("%d, %s, %s", $new_gene_id, "'".$mgi_id."'", $curdate);
    my $sql = qq{INSERT INTO gene_name_update (gene_id, mgi_id, update_date) VALUES($params)};
    my $update = $loutre_dba->dbc->prepare($sql);
    $update->execute;
  }
}

sub find_haplotype_update {

  my ($chr, $seq_region, $vega_name, $mapping) = @_;

  warn "HAPLOTYPE: @$mapping\n";
  my $match;
  foreach ( @$mapping ) {
    warn "$_ vs $seq_region --------\n";
    if ( index($seq_region, $_) == 0 ){
      $match = 1;
      print STDERR "HAPLOTYPE UPDATE: $seq_region\n";
      return 1;
    }
  }
  unless ( $match ){
    print STDERR "ERROR: $seq_region unexpected for VEGA symbol $vega_name\n";
    return 0;
  }
}

sub get_expected_haplotype_from_chr {

  my $chr = shift;

  my $map = {1  => [qw(NOD_IDD5.1 CHORI29_IDD5.1_test NOD_IDD5.4)],
             3  => [qw(129_IDD3 NOD_IDD3 NOD_IDD10 NOD_IDD18)],
             4  => [qw(129_MUP B6_MUP NOD_IDD9 mrc4)],
             6  => [qw(CHO_IDD6)],
             11 => [qw(CHO_IDD4 NOD_IDD4 lace_chr11_clones4)],
             17 => [qw(CHO_IDD16 mhc_4)]
            };

  return $map->{$chr};
}

sub check_contig_lock {
  my ($loutre_dba, $gene) = @_;

  my $lock = $loutre_dba->dbc->prepare(qq{
                               SELECT contig_lock_id
                               FROM contig_lock cl, seq_region sr
                               WHERE sr.name= ?
                               AND cl.seq_region_id=sr.seq_region_id
                             });

  my $locked_contigs;
  foreach my $p ( @{$gene->project('contig')}) {
    my $ctgname = $p->[2]->seq_region_name;
    $lock->execute( $ctgname );
    push(@$locked_contigs, $ctgname) if $lock->fetchrow;
  }

  return $locked_contigs;
}

__END__

=head1 NAME - MGI_gene_name_to_vega

=head1 AUTHOR

Modified from HUGO_gene_name_to_vega

Chao-Kung Chen B<email> ck1@sanger.ac.uk


