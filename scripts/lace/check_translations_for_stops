#!/usr/local/bin/perl -w

### check_translations_for_stops

use strict;
use Getopt::Long 'GetOptions';
use Bio::Otter::Lace::Defaults;
use Bio::Seq;

$| = 1;

{
    my ($dataset, $sequence_set, $chr_start_acc, $chr_end_acc, $gene_stable_id);
    my ($tunnel, $remarks, $verbose, $seleno, $sql, $prefix);
    my $help = sub { exec('perldoc', $0) };

    Bio::Otter::Lace::Defaults::do_getopt(
        'ds|dataset=s'          => \$dataset,
        'chr|set=s'             => \$sequence_set,
        'start_acc=s'           => \$chr_start_acc,
        'end_acc=s'             => \$chr_end_acc,
        'gene_stable_id=s'      => \$gene_stable_id,
        'tunnel=s'              => \$tunnel,
        'remarks'               => \$remarks,
        'seleno|selenocysteine' => \$seleno,
        'sql:s'                 => \$sql,
        'verbose|v'             => \$verbose,
        'prefix:s'              => \$prefix,
        'h|help'                => $help,
      )
      or $help->();
    $help->() unless $dataset;

    my $client = Bio::Otter::Lace::Defaults::make_Client();
    my $dset   = $client->get_DataSet_by_name($dataset);

    # for tunnelling
    if ($tunnel) {
        $dset->HOST('127.0.0.1');
        $dset->PORT($tunnel);
        $dset->DNA_HOST('127.0.0.1');
        $dset->DNA_PORT($tunnel);
        print STDERR "Tunnelling otter mysql connection\n";
        print STDERR '  HOST=' . $dset->HOST . "\n";
        print STDERR '  PORT=' . $dset->PORT . "\n";
        print STDERR '  DNA_HOST=' . $dset->DNA_HOST . "\n";
        print STDERR '  DNA_PORT=' . $dset->DNA_PORT . "\n";
    }
    my $otter_db  = $dset->get_cached_DBAdaptor;
    my $gene_aptr = $otter_db->get_GeneAdaptor;

    my $gene_id_list;
    if ($gene_stable_id) {
        if (-e $gene_stable_id) {

            # 'gene_stable_id' is a file
            my $n = 0;
            open(IN, $gene_stable_id) || die "cannot open $gene_stable_id";
            while (<IN>) {
                chomp;
                push(@$gene_id_list, $gene_aptr->fetch_by_stable_id($_)->dbID);
                $n++;
            }
            close(IN);
            print STDERR "checking $n gene_stable_ids only\n";
        }
        else {
            my $n = 0;
            foreach my $gsi (split(/,/, $gene_stable_id)) {
                if ($gsi =~ /T\d+/) {

                    # looks like a transcript_id
                    push(@$gene_id_list,
                        $gene_aptr->fetch_by_transcript_stable_id($gsi)->dbID);
                }
                else {
                    push(@$gene_id_list,
                        $gene_aptr->fetch_by_stable_id($gsi)->dbID);
                }
                $n++;
            }
            print STDERR "checking $n $gene_stable_id only\n";
        }
    }
    elsif ($sequence_set) {
        my $slice_aptr = $otter_db->get_SliceAdaptor;
        $otter_db->assembly_type($sequence_set);

        # code warns to set this, but doesn't exist/work...
        #$client->get_SequenceSets_for_DataSet($dset);
        my $ss = $dset->get_SequenceSet_by_name($sequence_set);
        $dset->selected_SequenceSet($ss);
        $dset->fetch_all_CloneSequences_for_SequenceSet($ss);
        if ($chr_start_acc or $chr_end_acc) {
            die sprintf(
                "Need both start_acc (got '%s') and end_acc (got '%s')\n",
                $chr_start_acc || 'NONE',
                $chr_end_acc   || 'NONE',
              )
              unless $chr_start_acc
              and $chr_end_acc;
            select_CloneSequence_contig($ss, $chr_start_acc, $chr_end_acc);
        }
        else {
            $ss->selected_CloneSequences($ss->CloneSequence_list);
        }
        my ($chr, $chr_start, $chr_end) =
          $client->chr_start_end_from_contig($ss->selected_CloneSequences);
        my $slice =
          $slice_aptr->fetch_by_chr_start_end($chr, $chr_start, $chr_end);
        $gene_id_list = $gene_aptr->list_current_dbIDs_for_Slice($slice);
    }
    else {
        $gene_id_list = $gene_aptr->list_current_dbIDs;
    }
    printf STDERR "Found %d current genes\n", scalar(@$gene_id_list);
    my $i = 0;

    # if sql file name specified, writes sql to add annotation remarks for
    # selenocysteine in correct format.
    if ($sql) {
        open(OUT2, ">$sql") || die "cannot open $sql";
    }
    foreach my $id (@$gene_id_list) {
        $i++;
        print STDERR '.';
        print STDERR " $i\n" unless $i % 50;
        my $gene = $gene_aptr->fetch_by_dbID($id);
        my $gt   = $gene->type;
        next if ($prefix && $gt !~ /$prefix:/);
        next if ($gt eq 'obsolete');
        foreach my $trans (@{ $gene->get_all_Transcripts }) {
            next unless $trans->translation;
            my $sqltxt =
              check_for_stops($gene, $trans, $remarks, $verbose, $seleno, $sql);
            print OUT2 $sqltxt if $sql;
        }
    }
    print STDERR " $i\n";
    close OUT2 if $sql;
}

sub check_for_stops {
    my ($gene, $trans, $remarks, $verbose, $seleno) = @_;

    # stop is ok if
    # - pseudogene
    # - selenocysteine and only single stop

    # selenocysteine stop codon
    my $scodon = 'TGA';
    my $sql    = '';

    # Translate method trims stops from sequence end
    my $peptide = $trans->translate;
    my $pseq    = $peptide->seq;

    # exit if no stops
    return unless ($pseq =~ /\*/);

    # contains stops: find out where and how many there are
    my @stop;
    my $tstop;
    {
        my $mrna        = $trans->translateable_seq;
        my $offset      = 0;
        my $last_offset = 0;
      LOOP:
        {
            if ($pseq =~ /([^\*]+)\*(.*)/) {
                my $pseq1_f = $1;
                $pseq = $2;

                # see if stop codon is result of selenocysteine (TGA)
                my $seq_flag = 0;
                $offset += length($pseq1_f) * 3;
                my $stop = substr($mrna, $offset, 3);
                if ($verbose) {
                    my $pseq3_f = join('  ', split(//, $pseq1_f));
                    my $mrna_f =
                      substr($mrna, $last_offset, $offset - $last_offset);
                    printf "%4d  " . $pseq3_f
                      . "   *\n%4d "
                      . $mrna_f . " "
                      . $stop
                      . "\n", length($pseq1_f), length($mrna_f);
                }
                my $aaoffset = int($offset / 3);
                push(@stop, [ $stop, $aaoffset ]);
                if ($tstop) { $tstop .= "; "; }
                $tstop .= "$aaoffset:$stop";

                $offset += 3;
                $last_offset = $offset;
                redo LOOP if $pseq ne '';
            }
        }
    }

    my $nstop = scalar(@stop);

    my $flag_seq = 0;

    # if all stops are TGA, this is a candidate selenocysteine
    {
        my $ntga = 0;
        for (my $i = 0 ; $i < $nstop ; $i++) {
            if ($stop[$i]->[0] eq $scodon) {
                $ntga++;
            }
        }
        if ($ntga == $nstop) {
            $flag_seq = 1;
        }
    }

    # check if pseudo or not
    my $trans_class = $trans->transcript_info->class->name, my $flag_pseudo = 0;
    if ($trans_class =~ /seudogene$/) {
        $flag_pseudo = 1;
    }

    # check remarks
    my $flag_remark  = 0;
    my $flag_remark2 = 0;
    my $alabel       = 'Annotation_remark- selenocysteine ';
    my $out          = '';
    my $out2         = '';
    my $tiid;
    foreach my $remark ($trans->transcript_info->remark) {
        my $dbid = $remark->dbID;
        $tiid = $remark->transcript_info_id;
        my $text = $remark->remark;
        if ($text =~ /seleno/i) {
            $flag_remark = 1;
        }
        if ($text =~ /^$alabel(.*)/) {
            my $stops      = $1;
            my $nmatch     = 0;
            my $i          = 0;
            my $flag_patch = 0;
            foreach my $rstop (split(/;\s/, $stops)) {
                my ($offset, $stop) = split(/:/, $rstop);
                if ($stop ne $scodon) {
                    next;
                }
                if ($i + 1 > $nstop) {
                    $nmatch = 0;
                    last;
                }
                if ($stop[$i]->[1] == $offset) {
                    $nmatch++;
                }
                elsif (($stop[$i]->[1] * 3) == $offset) {
                    $nmatch++;
                    $flag_patch = 1;
                }
                $i++;
            }
            if ($nmatch == $nstop) {
                $flag_remark2 = 1;
                if ($flag_patch) {

                    # existing structured remark is wrong - patch
                    $sql .=
"update transcript_remark set remark=\'$alabel$tstop\' where transcript_remark_id=$dbid;\n";
                    $out2 = sprintf(
                        "  UPDATED REMARK: %s %s\n",
                        $trans->transcript_info->name,
                        "$alabel$tstop"
                    );
                }
            }
        }
        $out .= "  remark: $text\n";
    }

    # provide feedback
    my $label;
    if ($flag_pseudo) {
        $label = 'P-OK';
    }
    elsif ($flag_seq == 1) {
        if ($flag_remark) {

            # remark indicates stop is a Selenocysteine
            $label = 'S-OK';
            if (!$flag_remark2) {

                # unless structured remark exists, build appropriate sql
                $sql .=
"insert into transcript_remark values (NULL,\'$alabel$tstop\',$tiid);\n";
                $out2 = sprintf(
                    "  NEW REMARK: %s %s\n",
                    $trans->transcript_info->name,
                    "$alabel$tstop"
                );
            }
        }
        else {
            $label = 'S-??';
        }
    }
    else {
        $label = '????';
    }

    # don't report if perfectly tagged seleno, unless -seleno option
    if ($seleno || $flag_remark2 == 0) {
        printf "%-24s %-24s %18s %2d %12s %4s %2d %s\n",
          $gene->gene_info->name->name, $trans->transcript_info->name,
          $trans->stable_id, $trans->version, $trans_class, $label, $nstop,
          $tstop;

        print "$out$out2\n" if $remarks;
    }
    return $sql;
}

### Also in gene_stats - should be in a module
sub select_CloneSequence_contig {
    my ($ss, $start_acc, $end_acc) = @_;

    my $ctg       = [];
    my $in_contig = 0;
    my $cs_list   = $ss->CloneSequence_list;
    foreach my $cs (@$cs_list) {
        my $acc = $cs->accession;
        if ($acc eq $start_acc) {
            $in_contig = 1;
        }
        if ($in_contig) {
            push(@$ctg, $cs);
        }
        if ($acc eq $end_acc) {
            if ($in_contig) {
                $in_contig = 0;
            }
            else {
                die "Found end '$end_acc' but not start '$start_acc'\n";
            }
        }
    }
    if (@$ctg == 0) {
        die "Failed to find start '$start_acc'\n";
    }
    elsif ($in_contig) {
        die "Failed to find end '$end_acc'\n";
    }

    $ss->selected_CloneSequences($ctg);
}

__END__

=head1 NAME - check_translations_for_stops

=head1 SYNOPSIS

  ./check_translations_for_stops -dataset <NAME>

=head1 DESCRIPTION

Checks all the translations of the genes in an
otter database, printing a report to STDOUT of
those that have internal stop codons.

=head1 FLAGS

=over 4

=item -remarks

Reports remark records for any transcript containing stops

=item -selenocysteine

Reports transcripts containing stops labelled as such in remarks
(skipped by default)

=back

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

(Extended by Tim Hubbard B<email> th@sanger.ac.uk)
