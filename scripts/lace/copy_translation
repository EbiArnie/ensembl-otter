#!/usr/bin/env perl

use warnings;


### copy_translation

use strict;
use Getopt::Long 'GetOptions';
use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotationBroker;

$| = 1;

{
  my ($dataset, $verbose, @a_types);

  my $help = sub { exec('perldoc', $0) };

  Bio::Otter::Lace::Defaults::do_getopt('ds|dataset=s' => \$dataset,
					'v|verbose'    => \$verbose,
					't|type=s@'    => \@a_types,
					'h|help'       => $help,
				       ) or $help->(); # plus default options
  $help->() unless $dataset;

  my $client    = Bio::Otter::Lace::Defaults::make_Client(); # Bio::Otter::Lace::Client
  my $dset      = $client->get_DataSet_by_name($dataset);    # Bio::Otter::Lace::DataSet
  my $otter_db  = $dset->get_cached_DBAdaptor;               # Bio::EnsEMBL::Containerr

  my ($chrom, $geneAd, $sliceAd, $slice, $tiles, $gene);

  unless ( @a_types ){

    # sql query to get all assembly types
    my $sql = q{SELECT assembly_type FROM sequence_set};
    my $sth = $otter_db->prepare($sql);
    $sth->execute;
    while ( my ($type) = $sth->fetchrow_array()) {
      push (@a_types, $type);
    }
    $sth->finish;
  }

  # loop thru all assembly types to fetch all annotated genes in it on otter

  my $data_error;
  my $match_with_stop              = 0;
  my $match_without_stop           = 0;
  my $match_if_without_stop_at_end = 0;
  my $copy                         = 0;
  my $type;
  my $rfile = "Redundant_transcripts_in_".$dataset;
  open (R, ">$rfile") || die $!;

  foreach $type ( @a_types ) {

    print STDERR "\nExamining genes on '$type'\n";

    $otter_db->assembly_type($type); # replace the default sequence set setting

    my $seqSet    = $dset->get_SequenceSet_by_name($type);
    $dset->fetch_all_CloneSequences_for_SequenceSet($seqSet);
    $chrom     = $seqSet->CloneSequence_list()->[0]->chromosome;

    $geneAd  = $otter_db->get_GeneAdaptor; # Bio::Otter::AnnotatedGeneAdaptor
    $sliceAd = $otter_db->get_SliceAdaptor;
    $slice = $sliceAd->fetch_by_chr_name($chrom->name);
    $tiles = $slice->get_tiling_path;

    my $latest_gene_id = $geneAd->list_current_dbIDs_for_Slice($slice);

    GENE:
    foreach my $id ( @$latest_gene_id ) {
      my $db_gene = $geneAd->fetch_by_dbID($id)->transform($slice); # transform contig coords of a gene into chrom. coords
      $gene       = $geneAd->fetch_by_dbID($id)->transform($slice); # make $gene a copy of $db_gene and work on $gene

      my $all_exons = $gene->get_all_Exons;
      foreach ( @$all_exons ) {
	if ( $_->contig != $slice ) {
	  $data_error .= "$type\t". $gene->stable_id ."\t". $gene->gene_info->name->name. " has exon not mapped onto slice\n" if ( $_->contig != $slice );
	  next GENE;
	}
      }

      my $chkpnt;

      # first remove redundant transcript (ie, all exons (coding and nocoding) are identical) of a gene
      # $flag indicates if $gene needs update
      my ($all_trans, $flag) = is_redundant($gene, $type);

      # now working on transcript w/o translation
      if ( scalar @$all_trans > 1 ){
	my (@positives, @negatives, $no_product, $has_product);

	foreach my $trans ( @$all_trans ) {
	  if ( $trans->translation ) {
	    $has_product++;
	    push (@positives, $trans);
	  }
	  else {
	    $no_product++;
	    push(@negatives, $trans);
	  }
	}

        # At least one of the transcripts should have translation and its info is a template for another transcript that has no translation
	if ( $no_product && $has_product ) {

	  foreach my $trans_CDS ( @positives ) {

	    my $trans_info = "\n=========$trans_CDS ". $gene->stable_id."\n";
	    foreach my $t ( @negatives ) {

	      $trans_info .= $t->transcript_info->name." (no translation)\n";

	      # -----------------------------------------------------------------------------
	      #    fetch info to make new translation obj for a transcript which lacks one
	      #------------------------------------------------------------------------------

	      my ($start_Exon, $end_Exon, $start_Exon_start, $ATG_site, $start_Exon_end, $end_Exon_start, $STOP_site, $end_Exon_end) =
	         coordinate_munging($t, $trans_CDS, $gene);

	      if ( $start_Exon ) {
		$copy++;
		
		my $trln = make_new_translation($t, $start_Exon, $end_Exon, $ATG_site, $start_Exon_start, $STOP_site, $end_Exon_start, $otter_db);

		# original and new protein seqs
		my $new_seq = $t        ->translate->primary_seq->seq;
		my $ori_seq = $trans_CDS->translate->primary_seq->seq;

		# remark for the script-modified transcript $t
		my $remark = "Annotation_remark- automatic translation info for the start_Exon, ATG site, end_Exon and STOP site from ".
                              $trans_CDS->transcript_info->name;
                $t->transcript_info->remark( new Bio::Otter::TranscriptRemark(-remark => $remark) );

		# for debugging only, use with -v option
		$trans_info .= $gene->stable_id."\t".$gene->gene_info->name->name."\t".$t->transcript_info->name. "\n"
                               . "Remark: ". $t->transcript_info->remark."\n"
		               . "start_Exon: $start_Exon\nend_Exon: $end_Exon\n"
    		               . "start_Exon_start ATG start_Exon_end end_Exon_start STOP end_Exon_end\n"
             	               . "$start_Exon_start $ATG_site $start_Exon_end $end_Exon_start $STOP_site $end_Exon_end\n"
                               . "==== copied from ".$trans_CDS->transcript_info->name."\n"
		               . $trans_CDS->translation->start_Exon->start."\t".$trans_CDS->translation->start."\t"
			       . $trans_CDS->translation->start_Exon->end."\t"
		               . $trans_CDS->translation->end_Exon->start."\t".$trans_CDS->translation->end."\t"
			       . $trans_CDS->translation->end_Exon->end."\n"
		               . $t->translation->start_Exon."\n"
   		               . $t->translation->end_Exon."\n"
		               . "\n".$new_seq."  ". length ($new_seq) . "\n";

		#----------------------------------------------------------------------------------------------
		#  check that new translation obj can be translated and compare old with new protein sequences
                #----------------------------------------------------------------------------------------------
	
		# grep only transcirpts with non-stop translation
		if ( $new_seq !~ /\*/ && $new_seq eq $ori_seq){
		  $chkpnt = 1;
		  $match_without_stop++;

		  # print transcript info for debugging purposes
		  trans_info($trans_info) if $verbose;
		}

		# should spot selenocystein gene if translation seqs are identical and has stop codon
		elsif ( $new_seq =~ /\*/ && $new_seq eq $ori_seq){
		  $chkpnt = 1;
		  $match_with_stop++;

		  $trans_info .= "selenocystein gene: ". $gene->stable_id. " ". $t->transcript_info->name. " ?";
		  trans_info($trans_info) if $verbose;
		}

		# also captures 2 sequences differ only by end stop codon
	        elsif ( $new_seq =~ /\*$/ && $new_seq ne $ori_seq){
		  my @matches = $new_seq =~ /\*/g;
		  my $no_stop = substr($new_seq, 0, (length $new_seq)-1); # $new_seq w/o end stop codon

		  if ( scalar @matches == 1 && $no_stop eq $ori_seq){
		    $chkpnt = 1;
		    $match_if_without_stop_at_end++;

		    $trans_info .= "\nSAME_if_without_end_Stop: ".$new_seq. "  ".length ($new_seq). "\n";
		    trans_info($trans_info) if $verbose;
		  }
		}
	      }

	      #-----------------------------------------------
	      #  undo new translaton obj if $chkpnt is undef
	      #-----------------------------------------------
	      if ( !$chkpnt ){
		$t->flush_Translation;
		print "Killed new translation obj ". $t->transcript_info->name . " (". $gene->stable_id. ")\n";
	      }
	    }
	  }
	}
      }

      # ok to update $gene
      if ( $flag || $chkpnt ){
	otter_to_XML_to_otter($chrom->name, $slice->chr_start, $slice->chr_end, $type, $tiles, $otter_db, $geneAd, $db_gene, $gene, $slice);
      }
    }
    print "Total number of candidate transcripts w/o translation: $copy\n"
          . "$match_with_stop: same translation with stop\n"
          . "$match_without_stop: same translation without stop\n"
	  . "$match_if_without_stop_at_end: same translation if without stop at end\n"
	  . "Rest is irrelevant\n";
  }

  if ( $data_error ) {
    my $outfile = $dataset."_data_error";	
    open (my $f, ">$outfile") || die $!;
    print $f $data_error;
    warn "Check also the file $outfile\n";
  }

  warn "\n\n* * The list of redundant transcritps is in $rfile* *\n\n" if (-s $rfile != 0);
}

sub trans_info {
  print @_;
}

sub make_new_translation {

  my ($t, $start_Exon, $end_Exon, $ATG_site, $start_Exon_start, $STOP_site, $end_Exon_start, $otter_db) = @_;

  my $trln = Bio::EnsEMBL::Translation->new();
	
  # assign start_Exon / end_Exon to exons of transcript w/o translation
  $trln->start_Exon($start_Exon);
  $trln->  end_Exon(  $end_Exon);

  # assign ATG site position relative to the start (stating with 1) of start_Exon
  if ( $ATG_site == $start_Exon_start ) {
    $trln->start(1);
  }
  else {
    $trln->start($ATG_site - $start_Exon_start + 1);
  }

  # assign STOP site position relative to the start (stating with 1) of end_Exon
  $trln->end($STOP_site - $end_Exon_start + 1);
	
  # assign new translation obj to transcript $t and assign it a new id
  $t->translation($trln);

  my $stable_id_Ad = $otter_db->get_StableIdAdaptor;
  $t->translation->stable_id( $stable_id_Ad->fetch_new_translation_stable_id );

  return $trln;
}

sub is_redundant {
  my ($gene, $type) = @_;

  my $trans_list = $gene->get_all_Transcripts;
  my (%exonlist_transName, %name_trans, %trans_h);

  @$trans_list = sort @$trans_list;

  for (my $i = 0; $i < scalar @{$trans_list}; $i++ ){
    my @exon_list = get_exon_coords($trans_list->[$i]);
    my $exons = join('-', @exon_list);

    push(@{ $exonlist_transName{$exons} }, $trans_list->[$i]->transcript_info->name);
    $name_trans{$trans_list->[$i]->transcript_info->name} = $trans_list->[$i];

    $trans_h{$trans_list->[$i]} = $i;  # record index of transcript in array
  }

  my $count = @$trans_list;

  # remove only redundant transcript which has no translation (also takes care of redundant ones that have translation)
  foreach my $k ( keys %exonlist_transName ){
    my $num = scalar @{$exonlist_transName{$k}};	

    unless ( $num == 1 ){
      my $index;
      my $delete = 0;
      my $ref_t;
      my $red_t;

      my @rev_nameList = reverse sort @{$exonlist_transName{$k}}; # intend to remove higher number transcript
      print "\nNAME LIST: @rev_nameList\n";
	
      foreach my $ea ( @rev_nameList ){

	# $ea is name of transcript obj
	if ( $name_trans{$ea}->translation ){
	  print $ref_t = $name_trans{$ea};
	  next;
	}

	# in case > 1 transcripts do not have translation, leave only 1
	if ( !$name_trans{$ea}->translation && $num != 1 && $delete == 0 ){
	  $num--;
	  print "----- REMOVE redundant $ea index ($trans_h{$name_trans{$ea}}) ". $name_trans{$ea}->transcript_info->name."\n";
	  splice(@$trans_list, $trans_h{$name_trans{$ea}}, 1);      #  single redundant transcript
	  print R "$type - redundant transcript: $ea\t".$gene->stable_id."\t".$gene->gene_info->name->name."\n";
	  $red_t = $name_trans{$ea};
	  $index = $trans_h{$name_trans{$ea}};
	  $delete++;
	}
	elsif ( !$name_trans{$ea}->translation && $num != 1 && $delete >= 1 ){
	  $num--;
	  print "----- REMOVE redundant $ea index ($trans_h{$name_trans{$ea}}-1)". $name_trans{$ea}->transcript_info->name."\n";
	  splice(@$trans_list, $trans_h{$name_trans{$ea}}-1, 1) if $trans_h{$name_trans{$ea}} > $index;   #  > 1 redundant transcripts
	  splice(@$trans_list, $trans_h{$name_trans{$ea}},   1) if $trans_h{$name_trans{$ea}} < $index;
	  print R "$type - redundant transcript: $ea\t".$gene->stable_id."\t".$gene->gene_info->name->name."\n";
	  $red_t = $name_trans{$ea};
	}
	elsif ( !$ref_t && $red_t ) {
	  $ref_t = $name_trans{$ea};
	}
      }

      # add remark to $gene and its transcripts if associated transcript obj is deleted
      # also note that there are cases where redundant transcripts have different translation annotations,
      # flag as dubious annotation?

      if ( $ref_t && $red_t ){
	add_gene_trans_remark($gene, $ref_t, $red_t);
      }
      else {
	print R "$type - check translation annotations of redundant transcripts: @rev_nameList (".$gene->gene_info->name->name.")\n";
      }
    }
  }

  print "NEW LIST: \n";
  foreach (@$trans_list){
    print $_->transcript_info->name, "\n";
  }

  # Is trans_list changed? If yes, return $flag to indicate $gene needs update
  my $flag = 1;
  if ( $count ne scalar @$trans_list ){
    warn "TRANS LIST changed";
    return $trans_list, $flag;
  }
  else {
    return $trans_list;
  }
}

sub add_gene_trans_remark {
  my ($gene, $ref_t, $red_t) = @_;

  my $remark = Bio::Otter::GeneRemark->new;

  print $gene->stable_id."\n";

  # for transcript obj to delete, ensure that it has no Remark and/or Evidence info attached:

  if ( $ref_t->translation ) {

    # move evidence over to the transcript with CDS if it has not one but the redundant transcript to delete has one
    unless ( @{$ref_t->transcript_info->get_all_Evidence} ) {
      $ref_t->transcript_info->add_Evidence(@{$red_t->transcript_info->get_all_Evidence}) if @{$red_t->transcript_info->get_all_Evidence};
    }

    unless ( $ref_t->transcript_info->remark ) {
      $ref_t->transcript_info->remark($red_t->transcript_info->remark) if $red_t->transcript_info->remark;
    }

    print "CDS: ".$ref_t." ".$ref_t->transcript_info->name."\n";
    my $rem = "Annotation_remark- ".$red_t->transcript_info->name." is deleted as it is redundant to ".$ref_t->transcript_info->name.
              ". Its evidence/remark is carried over to ". $ref_t->transcript_info->name;
    print $rem, "\n";

    $remark->remark($rem);
    $gene->gene_info->remark($remark);
  }

  else {

    if ( @{$red_t->transcript_info->get_all_Evidence} && !(@{$ref_t->transcript_info->get_all_Evidence}) ){
      print $red_t->transcript_info->name. " has EVIDENCE\n";

      #  move evidence/remark from transcript with higher number to the one with lower number and delete the higher number one
      #  attach also its evidence if available
      #  this is trying to keep the numbering of transcripts

      $ref_t->transcript_info->add_Evidence( @{$red_t->transcript_info->get_all_Evidence} );

      print "MOVE OVER\n";
      my @evidence = map $_->name, @{$ref_t->transcript_info->get_all_Evidence};
      print "NEW: @evidence\n";
    }

    if ( $red_t->transcript_info->remark && !($ref_t->transcript_info->remark) ){
      $ref_t->transcript_info->remark( $red_t->transcript_info->remark );
    }

    my $rem = "Annotation_remark- ".$red_t->transcript_info->name." is deleted as it is redundant to ".$ref_t->transcript_info->name.
              ". Its evidence/remark is carried over to ". $ref_t->transcript_info->name;
    print $rem, "\n";

    $remark->remark($rem);
    $gene->gene_info->remark($remark);
  }
}


sub coordinate_munging {
 ## my ($trans, $trans_CDS, $gene, %array_order) = @_;
  my ($trans, $trans_CDS, $gene) = @_;
  my ($start_Exon, $start_Exon_start, $start_Exon_end, $ATG_site);

  foreach my $e ( @{$trans ->get_all_Exons} ){

    #------------------------------------
    #      dealing with single exon
    #------------------------------------

    # situation where start_Exon = end_Exon eg. OTTHUMG00000028635
    # ie, $trans_CDS->translation->start_Exon->start ==$trans_CDS->translation->end_Exon->start

    if ( $trans_CDS->translation->start_Exon == $trans_CDS->translation->end_Exon &&
	 $e->start <= get_ATG_site_coord ($trans_CDS)                             &&
	 $e->end   >= get_STOP_site_coord($trans_CDS) ){

      my $end_Exon       = $start_Exon       = $e;
      my $end_Exon_start = $start_Exon_start = $e->start;
      my $end_Exon_end   = $start_Exon_end   = $e->end;

      return ($start_Exon, $end_Exon, $start_Exon_start, get_ATG_site_coord($trans_CDS),
	      $start_Exon_end, $end_Exon_start, get_STOP_site_coord($trans_CDS), $end_Exon_end) if
              $start_Exon && $end_Exon && $start_Exon_start && get_ATG_site_coord($trans_CDS) &&
	      $start_Exon_end && $end_Exon_start && get_STOP_site_coord($trans_CDS) && $end_Exon_end;
	
      last;
    }

    #---------------------------------------
    #      dealing with multiple exon
    #---------------------------------------

    # working on 5': coord of start_Exon start matched or < ATG site coord of CDS
    if ( $trans_CDS->translation->start_Exon != $trans_CDS->translation->end_Exon &&
	 $e->start <= get_ATG_site_coord($trans_CDS)                              &&
	 $e->end   >= get_ATG_site_coord($trans_CDS) ){

      $start_Exon       = $e;
      $start_Exon_start = $e->start;
      $start_Exon_end   = $e->end;
      $ATG_site         = get_ATG_site_coord($trans_CDS);
      next;
    }

    # working on 3'
    if ( $start_Exon_start                                                        &&
	 $trans_CDS->translation->start_Exon != $trans_CDS->translation->end_Exon &&
	 $e->start <  get_STOP_site_coord($trans_CDS)                             &&
	 $e->end   >= get_STOP_site_coord($trans_CDS) ){

      my $end_Exon       = $e;
      my $end_Exon_start = $e->start;
      my $end_Exon_end   = $e->end;

      return ($start_Exon, $end_Exon, $start_Exon_start, $ATG_site, $start_Exon_end,
	      $end_Exon_start, get_STOP_site_coord($trans_CDS), $end_Exon_end) if
	      $start_Exon && $end_Exon && $start_Exon_start && $ATG_site &&
	      $start_Exon_end && $end_Exon_start && get_STOP_site_coord($trans_CDS) && $end_Exon_end;
      last;
    }
  }
}

sub get_ATG_site_coord {
  my ($trans_CDS) = @_;

  # $trans_CDS->translation->start_Exon->start is chrom coord (eg, 6569554)
  # $trans_CDS->translation->start             is coord of first bp of ATG site of that start_Exon (eg, 58)
  my $ATG_site_coord = $trans_CDS->translation->start_Exon->start + $trans_CDS->translation->start - 1 if $trans_CDS->translation->start  > 1;
     $ATG_site_coord = $trans_CDS->translation->start_Exon->start                                      if $trans_CDS->translation->start == 1;

  return $ATG_site_coord;
}

sub get_STOP_site_coord {
  my ($trans_CDS) = @_;

  # $trans_CDS->translation->end_Exon->start is chrom coord (eg, 9633292)
  # $trans_CDS->translation->end             is first bp of stop codon in that end_Exon (eg, 24)
  return my $STOP_site_coord = $trans_CDS->translation->end_Exon->start + $trans_CDS->translation->end - 1;
}


# get all exon coords of a transcript
sub get_exon_coords {
  my ($trans) = shift;
  my @exon_coords;
  foreach ( @{$trans ->get_all_Exons} ){
    push(@exon_coords, $_->start, $_->end);
  }
  return sort @exon_coords;
}

# using codes in script realign_offtrack_genes
sub otter_to_XML_to_otter {
  my ($chr_name, $chr_start, $chr_end, $seq_set, $tiles, $otter_db, $geneAd, $db_gene, $gene, $slice) = @_;


  my $temp = Bio::Otter::Lace::TempFile->new;
  $temp->name("copy_translation.$$.xml");
  my $w_fh = $temp->write_file_handle;

  #   using Bio::Otter::Converter::path_to_XML to do XML conversion
  #   To update/modified a gene, the API cannot write to otterdb directly and needs XML converter,
  #   which assigns a new dbID and an incremented version number of the existent gene that needs update
  #   to a copied gene (in XML format). These dbIDs will have same gene_stable_id.
  #   Ie, the modified version out of XML converter is the $xml_gene (based on $gene);
  #   the original version of the same gene is $db_gene
  #   The functions in save_new_gene() routine are then able to make the distintion between the original copy of gene
  #   ($db_gene) and the modified version of the same gene ($xml_gene) and save the modified version to
  #   the database.

  print $w_fh
    "<otter>\n<sequence_set>\n"
    , Bio::Otter::Converter::path_to_XML($chr_name, $chr_start, $chr_end, $seq_set, $tiles)
    , $gene->toXMLString
    , "</otter>\n</sequence_set>\n";

  my $r_fh = $temp->read_file_handle;
  my ($gene_list) = Bio::Otter::Converter::XML_to_otter($r_fh);
  my $xml_gene = shift @$gene_list;

  my $anal = $otter_db->get_AnalysisAdaptor->fetch_by_logic_name('otter');
  $xml_gene->analysis($anal);

  # effective changes (for debug)
  #warn  "\n". $xml_gene->stable_id;
  #warn "XG ".scalar @{$xml_gene->get_all_Transcripts};
  #warn "DG ".scalar @{$db_gene->get_all_Transcripts};

  save_new_gene($otter_db, $geneAd, $db_gene, $xml_gene, $slice);
}

# function from script realign_offtrack_genes
sub save_new_gene {
  my( $dba, $gene_aptr, $db_gene, $xml_gene, $slice ) = @_;

  my $broker = Bio::Otter::AnnotationBroker->new($dba);
  $broker->make_id_version_hash([$db_gene]);
  $broker->increment_versions_in_gene($xml_gene);
  $gene_aptr->attach_to_Slice($xml_gene, $slice);

  eval {
    $dba->begin_work;
    $xml_gene->detach_DBAdaptors;
    $gene_aptr->store($xml_gene);
    $dba->commit;
  };
  if ($@) {
    $dba->rollback;
    warn "Error saving remapped gene: $@";
  }
}

__END__

=head1 NAME - copy_translation

=head1 SYNOPSIS

copy_translation [-ds <dataset>] [-t <assembly_type>] -v > output_filename
-v > output_filename is optional to capture transcript information and can be useful for debugging purposes.


=head1 DESCRIPTION

On chromosome 14, there are transcripts that do not have corresponding translations due to annotators creating only one tranlation object for
one of the transcripts (if multiple) of a gene.
This script corrects the problem by copying information of start_Exon, ATG site, end_Exon and STOP sites, when appropriate, from transcripts having UTR and CDS annotations, if the copied-over info leads to non-stop translation. Stop codon at end of translation is allowed.

Redundant transcripts spotted by the script will be removed. Should there be any evidence/remark attached to the transcript to delete than its info is carried over to the transcript to keep.

The script, if info is found, also creates 2 addtional files:
(1) $dataset."_data_error,
(2) Redundant_transcripts_in_".$dataset

where $dataset is eg, test_human.
(1) spots genes that have exons not mapped to chromosome coordinates.
(2) list of redundancies of the format, eg,chr14 - redundant transcript: AL136501.2-002    OTTHUMG00000028646      GALC


=head1 AUTHOR

Chao-Kung Chen B<email> ck1@sanger.ac.uk

