#!/usr/local/bin/perl -w

use strict;
use Bio::Otter::Converter;
use Bio::Otter::Lace::Defaults;

my $otter_dba; # it's much cheaper to have these globally visible
my $gene_adaptor;
my $slice_adaptor;
my $red_hash;
my $load_str;
my $reduncount=0;
my $loadcount=0;
$|=1;

my %assembly_nonmatch_version = (
'human' => {
    'chr1-7A'       => 7.5,
    'Chr1_final'    => 8,

    'chr2'          => 1,

    'chr3-00'       => 0.5,

    'chr3-01B'      => 1.6,

    'chr4'          => 1,

    'chr6-14A'      => 14.5,

    'chr7'          => 1,
    'chr7-01A'      => 1.5,

    'chr8_jena1'    => 0, # parallel branch?
    'chr8_jena2'    => 0, # parallel branch?

    'chr9p12'       => 6,
    'Chr9_09'       => 9,
    'chr9-14A'      => 14.5,
    'chr9-16-peri'  => 0, # parallel branch?
    'chr9-peri-17'  => 0, # parallel branch?
    'chr9_hetero'   => 0, # ?

    'chr11-hsa11_20030701' => 0, # ?
    'chr11-hsa11_20040402' => 0, # ?

    'chr12-00'      => 0.5,
    'chr12-01A'     => 1.3,
    'chr12-01B'     => 1.6,

    'chr13-10A'     => 10.5,

    'chr14'         => 1,

    'chr16-00'      => 0.5,

    'chr17_mm11'    => 0, # ?

    'chr18p-01'     => 0, # seems to be only one half of the whole assembly?
    'chr18q-01'     => 0, # seems to be the other half?

    'chr19'         => 1,

    'chr20-ncbi33'  => 0, # ? not the freshest, definitely
    'chr20-10A'     => 10.5,

    'chr21-hsa21_20030701' => 0, # no clues

    'chr22p-03'     => 0, # a half?
    'chr22'         => 1,

    'chrX-07A'      => 7.5,

    'chr_Y_01'      => 1,
},
'pig' => {
	'chr17-SSC17_MAX1-05'    => 5,
	'chr17-SSC17_MAX1-04'    => 4,
	'chr17-SSC17_MAX1-03'    => 3,
	'chr17-SSC17_MAX1-02'    => 2,
	'chr17-01'               => 1,
	'chr17-SSC17_MAX1-01'    => 0.8,
	'bE447P16-01'    => 0,
	'CR974431_CpG'   => 0,
	'phrap_test-01'  => 0,
	'chr4_HSD3B-01'  => 1,
	'SSC6_test1-01'  => 3,
	'Chr_6_NKG-02'   => 2,
	'Chr_6_NKG'  => 1,
	'mhc-08' => 8,
	'mhc-07' => 7,
	'mhc-06' => 6,
	'mhc-05' => 5,
	'mhc-04' => 4,  # ? didn't find the agp
	'SSC7_test2-02'  => 3.6
	'SSC7_test2-01'  => 3.3
	'mhc-03' => 3,
	'mhc-02' => 2,
	'mhc-01' => 1,
	'MHC_class-I'    => 0.6,
	'MHC_class-II'   => 0.3,
},
'dog' => {
},
);

{ # lexical environment for &execute_ctgids_2_asm

    my %cached_sth_by_arity = ();

    sub execute_ctgids_2_asm {
        my ($otter_dba, $set_hash) = @_;
        my $arity    = scalar(keys %$set_hash);

        if(!exists $cached_sth_by_arity{$arity}) {

            my $sql = qq{
                SELECT asm.type, chr.name
                FROM assembly asm, chromosome chr
                WHERE asm.chromosome_id=chr.chromosome_id
                AND asm.contig_id IN (
            }. join(',', ('?')x$arity) .qq{)
                GROUP BY asm.type
                HAVING count(*)=$arity;
            };
            $cached_sth_by_arity{$arity} = $otter_dba->prepare($sql);
        }
        my $sth = $cached_sth_by_arity{$arity};

        $sth->execute(keys %$set_hash);
        return $sth;
    }
} # lexical environment for &execute_ctgids_2_asm


sub gene_transformed_successfully {
    my( $gene, $slice ) = @_;

    my $slice_length = $slice->length;
    foreach my $exon (@{$gene->get_all_Exons}) {
        if ($exon->contig != $slice or $exon->start < 1 or $exon->end > $slice_length) {
            return 0;
        }
    }

    # Check for overlapping exons in each transcript
    foreach my $transcript (@{$gene->get_all_Transcripts}) {
        my @exon_list = @{$transcript->get_all_Exons};
        if ($exon_list[0]->strand == -1) {
            # exons are in opposite order for reverse strand transcripts
            @exon_list = reverse @exon_list;
        }

        my $last = 0;
        foreach my $exon (@exon_list) {
            if ($exon->start <= $last) {
                return 0;
            }
            $last = $exon->end;
        }
    }

    return 1;
}

{ # lexical environment for add_xml_gene

    my %slices_hash = (); # atype->Slice

    sub add_xml_gene {
        my ($gene, $ver_2_asm_chr) = @_;

        for my $version (sort {$b <=> $a} keys %$ver_2_asm_chr) {
            # print STDERR "VER=$version: ";
            for my $pair (@{$ver_2_asm_chr->{$version}}) {
                my ($atype, $chr_name) = @$pair;
                # print STDERR "ATYPE=$atype(CHR=$chr_name) ";

                $otter_dba->assembly_type($atype);

                my $slice = $slices_hash{$atype}
                  ||= $slice_adaptor->fetch_by_chr_name($chr_name);
                
                $gene->transform($slice);

                if (gene_transformed_successfully($gene, $slice)) {
                    my $gene_id  = $gene->dbID();
                    my $modified = $gene->modified;
                    print ''.('-'x40)."\n";
                    print "$chr_name\t$atype\t$gene_id\t$modified\n";
                    print $gene->toXMLString . "\n";
                    print STDERR "--> $atype\n";
                    return;
                } else { # re-fetch it to avoid transforming between versions of assembly
                    $gene = $gene_adaptor->fetch_by_dbID($gene->dbID());
                }

            } # for $atype
        } # for $version
        print STDERR "---FAILED TO MAP!\n";
    }

} # lexical environment for add_xml_gene

sub create_red_list {
  my $redfile=shift;
  open (IN,"<$redfile") || die ("Could not open redundant file for reading :$redfile \n $!\n");
  while(<IN>){
	 if ($_ =~ /(\S+)/){
		$red_hash->{$1}=1;
	 }
  }
  close IN;
}

sub create_load_string {
  my $loadfile=shift;
  open (IN,"<$loadfile") || die ("Could not open load file for reading :$loadfile \n $!\n");
  $load_str=0;
  while(<IN>){
	 if ($_ =~ /(\S+)/){
		$load_str=$load_str.','.$1;
	 }
  }
  close IN;
}

sub main {

    my $dataset_name    = 'human'; # 'test_human';      # 'mouse', ...
    my $skip_to         = 0;
	 my ($redunfile,$loadfile);

    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s'     => \$dataset_name,
        'skipto=s'      => \$skip_to,
		  'redunfile=s'   => \$redunfile,
		  'loadfile=s'    => \$loadfile,
#        'set=s'         => \$set_name,
#        'chr=s'         => \$chr_name,
    );
    
    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);

        # init the global things:
    $otter_dba     = $ds->get_cached_DBAdaptor; # now it is global
    $gene_adaptor  = $otter_dba->get_GeneAdaptor();
    $slice_adaptor = $otter_dba->get_SliceAdaptor();
	 
	 #if redundant file is present create a hash of redundant dbids
	 if ($redunfile) {
		create_red_list($redunfile);
	 }
	 my $sth_gene_ids;
	 if ($loadfile) {
		create_load_string($loadfile);
		$sth_gene_ids = $otter_dba->prepare(qq{
        SELECT gene_id, stable_id, version, UNIX_TIMESTAMP(modified)
        FROM gene_stable_id
        WHERE gene_id IN (}.$load_str.qq{)
        ORDER by gene_id ASC
    });
	 }
	 else {
		$sth_gene_ids = $otter_dba->prepare(qq{
        SELECT gene_id, stable_id, version, UNIX_TIMESTAMP(modified)
        FROM gene_stable_id
        WHERE gene_id > $skip_to
        ORDER by gene_id ASC
    });
	 }
	 
    #   LIMIT 1000

    $sth_gene_ids->execute();

    while( my ($gene_id, $stable_id, $version, $modified) = $sth_gene_ids->fetchrow()) {

		### Ignore gene_ids in Chao-Kung's file(redundant file)

		if ($redunfile && exists $red_hash->{$gene_id}){
		  $reduncount++;
		  # print STDERR "redundant - not loaded $gene_id\t$stable_id.$version\t$modified\n";
		  next;
		  
		}
		$loadcount++;
        print STDERR "$gene_id\t$stable_id.$version\t$modified\t";

        my $gene = $gene_adaptor->fetch_by_dbID($gene_id);
        my $contig_id_set = {};
        for my $transcript (@{$gene->get_all_Transcripts()}) {
            for my $exon (@{$transcript->get_all_Exons()}) {
                my $rawcontig   = $exon->contig();
                my $contig_id   = $rawcontig->dbID();
                my $contig_name = $rawcontig->name();

                $contig_id_set->{$contig_id}++;
            }
        }

        my $sth_ctgids_2_asm = execute_ctgids_2_asm($otter_dba, $contig_id_set);

        my $ver_2_asm_chr = {}; # version->[list of [asm_type, chr_name] pairs]

        while( my ($atype, $chr_name) = $sth_ctgids_2_asm->fetchrow()) {

            my $version = ($atype=~/^chr\d+-0*(\d+)$/)
                ? $1
                : exists($assembly_nonmatch_version{$dataset_name}{$atype})
                    ? $assembly_nonmatch_version{$dataset_name}{$atype}
                    : 0;
            push @{$ver_2_asm_chr->{$version}}, [$atype, $chr_name];

        } # ctgids_2_asm fetching loop

        if(%$ver_2_asm_chr) {
            add_xml_gene($gene, $ver_2_asm_chr);
        }
    } # gene_id fetching loop

} # main()

main();
print STDERR "\nLOG of the dump";
print STDERR "\nneglected $reduncount redundant ids";
print STDERR "\ndumped $loadcount ids to output file\n";
undef $otter_dba;
undef $gene_adaptor;
undef $slice_adaptor;
undef $red_hash;
undef $load_str;
undef $reduncount;
undef $loadcount;

1;
