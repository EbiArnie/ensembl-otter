#!/usr/local/bin/perl -w

use strict;
use IO::File;
use Bio::Otter::Converter;
use Bio::Otter::Lace::Defaults;

my $otter_dba; # it's much cheaper to have it globally visible

my %assembly_nonmatch_version = (
    'chr1-7A'       => 7.5,
    'Chr1_final'    => 8,

    'chr2'          => 1,

    'chr3-00'       => 0.5,

    'chr3-01B'      => 1.6,

    'chr4'          => 1,

    'chr6-14A'      => 14.5,

    'chr7'          => 1,
    'chr7-01A'      => 1.5,

    'chr8_jena1'    => 0, # parallel branch?
    'chr8_jena2'    => 0, # parallel branch?

    'chr9p12'       => 6,
    'Chr9_09'       => 9,
    'chr9-14A'      => 14.5,
    'chr9-16-peri'  => 0, # parallel branch?
    'chr9-peri-17'  => 0, # parallel branch?
    'chr9_hetero'   => 0, # ?

    'chr11-hsa11_20030701' => 0, # ?
    'chr11-hsa11_20040402' => 0, # ?

    'chr12-00'      => 0.5,
    'chr12-01A'     => 1.3,
    'chr12-01B'     => 1.6,

    'chr13-10A'     => 10.5,

    'chr14'         => 1,

    'chr16-00'      => 0.5,

    'chr17_mm11'    => 0, # ?

    'chr18p-01'     => 0, # seems to be only one half of the whole assembly?
    'chr18q-01'     => 0, # seems to be the other half?

    'chr19'         => 1,

    'chr20-ncbi33'  => 0, # ? not the freshest, definitely
    'chr20-10A'     => 10.5,

    'chr21-hsa21_20030701' => 0, # no clues

    'chr22p-03'     => 0, # a half?
    'chr22'         => 1,

    'chrX-07A'      => 7.5,

    'chr_Y_01'      => 1,
);

{ # lexical environment for &execute_ctgids_2_asm

    my %cached_sth_by_arity = ();

    sub execute_ctgids_2_asm {
        my ($otter_dba, $set_hash) = @_;
        my $arity    = scalar(keys %$set_hash);

        if(!exists $cached_sth_by_arity{$arity}) {

            my $sql = qq{
                SELECT asm.type, chr.name
                FROM assembly asm, chromosome chr
                WHERE asm.chromosome_id=chr.chromosome_id
                AND asm.contig_id IN (
            }. join(',', ('?')x$arity) .qq{)
                GROUP BY asm.type
                HAVING count(*)=$arity;
            };
            $cached_sth_by_arity{$arity} = $otter_dba->prepare($sql);
        }
        my $sth = $cached_sth_by_arity{$arity};

        $sth->execute(keys %$set_hash);
        return $sth;
    }
} # lexical environment for &execute_ctgids_2_asm



{ # lexical environment for add_xml_gene

    my $slice_adaptor;
    my %assembly_fh = ();

    sub add_xml_gene {
        my ($gene, $asm_type, $chr_name) = @_;

        $otter_dba->assembly_type($asm_type);

        if(!$slice_adaptor) {
            $slice_adaptor = $otter_dba->get_SliceAdaptor();
        }

        my $current_fh = $assembly_fh{$asm_type};

        if(!$current_fh) {
            my $filename = "assembly_dump.$asm_type";
            $current_fh = $assembly_fh{$asm_type} = new IO::File("> $filename");

            my $slice = $slice_adaptor->fetch_by_chr_name($chr_name);

            my $path     = $slice->get_tiling_path;
            my $chrstart = $slice->chr_start;
            my $chrend   = $slice->chr_end;

            my $xmlstr   = "<otter>\n<sequence_set>\n";
            $xmlstr     .= Bio::Otter::Converter::path_to_XML($chr_name, $chrstart, $chrend, $asm_type, $path);

            $current_fh->autoflush(1);

            print $current_fh $xmlstr;
        }

        print $current_fh $gene->toXMLString . "\n";
    }

    sub finalize_files {
        for my $asm_type (keys %assembly_fh) {
            my $fh = delete $assembly_fh{$asm_type};
            print $fh "</sequence_set>\n</otter>\n";
            $fh->close();
        }
    }

} # lexical environment for add_xml_gene



sub main {

    my $dataset_name    = 'human'; # 'test_human';      # 'mouse', ...

    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s'     => \$dataset_name,
#        'set=s'         => \$set_name,
#        'chr=s'         => \$chr_name,
    );
    
    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);

    $otter_dba = $ds->get_cached_DBAdaptor; # now it is global

    my $gene_adaptor  = $otter_dba->get_GeneAdaptor();

    my $sth_gene_ids = $otter_dba->prepare(qq{
        SELECT gene_id, stable_id, version
        FROM gene_stable_id
        ORDER by gene_id ASC
    });
    #    LIMIT 100

    $sth_gene_ids->execute();
    while( my ($gene_id, $stable_id, $version) = $sth_gene_ids->fetchrow()) {
        print "$gene_id\t$stable_id.$version\t";
        my $gene = $gene_adaptor->fetch_by_dbID($gene_id);
        
        my $contig_id_set = {};
        # my %contig_id_2_name = ();
        for my $transcript (@{$gene->get_all_Transcripts()}) {
            for my $exon (@{$transcript->get_all_Exons()}) {
                my $rawcontig   = $exon->contig();
                my $contig_id   = $rawcontig->dbID();
                my $contig_name = $rawcontig->name();

                $contig_id_set->{$contig_id}++;
                # $contig_id_2_name{$contig_id} = $contig_name;
            }
        }

        # print join(', ', values %contig_id_2_name)." ";

        my $sth_ctgids_2_asm = execute_ctgids_2_asm($otter_dba, $contig_id_set);

        my $current_atype    = 'none';
        my $current_version  = 0;
        my @other_atypes     = ();
        my $current_chr_name = '';

        while( my ($atype, $chr_name) = $sth_ctgids_2_asm->fetchrow()) {
            $current_chr_name ||= $chr_name;

            my $version = ($atype=~/^chr\d+-0*(\d+)$/)
                ? $1
                : exists($assembly_nonmatch_version{$atype})
                    ? $assembly_nonmatch_version{$atype}
                    : 0;
            if($version >= $current_version) {
                ($current_atype, $current_version) = ($atype, $version);
            } elsif(!$version) {
                push @other_atypes, $atype;
            }
        }
        print $current_atype.'; '.join(', ', @other_atypes)."\n";

        if($current_atype ne 'none') {
            add_xml_gene($gene, $current_atype, $current_chr_name);
        }
    }

    finalize_files();

} # main()

main();


