#!/usr/local/bin/perl -w

# dump_otter_SFeature_Atag_by_assembly.pl
# output xml for genomic features: simple_featuares, assembly_tags

use strict;
use Getopt::Long 'GetOptions';
use Bio::Otter::Lace::Defaults;
use Bio::Otter::Converter;

my ($dataset);

Bio::Otter::Lace::Defaults::do_getopt('ds|dataset=s' => \$dataset # eg, human or mouse or zebrafish
									 );

my $client   = Bio::Otter::Lace::Defaults::make_Client();
my $dset     = $client->get_DataSet_by_name($dataset);	
my $otter_db = $dset->get_cached_DBAdaptor;
my $sliceAd  = $otter_db->get_SliceAdaptor;
my $ssets    = $client->get_all_SequenceSets_for_DataSet($dset);

foreach my $ss ( @$ssets ){

  my $asm_type = $ss->name;

 # $asm_type = "chr20-11"; #testing

  print STDERR "$asm_type\n";

  $otter_db->assembly_type($asm_type); # replace the default sequence set setting

  my $seqSet = $dset->get_SequenceSet_by_name($asm_type);
  $dset->fetch_all_CloneSequences_for_SequenceSet($seqSet);

  my $chrom = $seqSet->CloneSequence_list()->[0]->chromosome;
  my $slice = $sliceAd->fetch_by_chr_name($chrom);

  my $xmlfile = $asm_type . ".xml";
  open( my $fh, ">$xmlfile") or die $!;

  my $xml = slice_to_XML($slice, $otter_db);

  print $fh $xml;
  close $fh;

 # die;
}

sub slice_to_XML {
  my ($slice, $db) = @_;

  my $xmlstr = "";

  $xmlstr .= "<otter>\n";
  $xmlstr .= "<sequence_set>\n";

  my $path;
  # captures cases like eg, "MSG: Cannot deal with mis-lengthed mappings so far"
  eval {$path = $slice->get_tiling_path};
  unless ( $path ){
	print STDERR print $@;
	next;
  }

  my $chr      = $slice->chr_name;
  my $chrstart = $slice->chr_start;
  my $chrend   = $slice->chr_end;

  $xmlstr .= Bio::Otter::Converter::path_to_XML($chr, $chrstart, $chrend, $db->assembly_type, $path);

  # Simple features for polyA signals and sites etc...
  if (my $feats = $slice->get_all_SimpleFeatures) {
	if ( defined $feats->[0] ) {
	  $xmlstr .= Bio::Otter::Converter::features_to_XML($chrstart, $feats);
	}
  }

  # get all assembly tag data
  my $atag_str = Bio::Otter::Converter::assembly_tags_to_XML($slice, $db);
  $xmlstr .= $atag_str if $atag_str;

  $xmlstr .= "</sequence_set>\n";
  $xmlstr .= "</otter>\n";

  return format_string($xmlstr);
}

sub format_string {
  my $xmlstr = shift;

  my @parts;
  foreach my $part ( split(/\n/, $xmlstr) ){

	if ( $part =~ /^(\s*<\w*>)(.*)(<\/\w*>)$/ ){
	  my $otag = $1;
	  my $etag = $3;
	  my $data = $2;

	  $data =~ s/&/&amp;/g;
	  $data =~ s/</&lt;/g;
	  $data =~ s/>/&gt;/g;
	  $data =~ s/\"/&quot;/g;
	  $data =~ s/\'/&apos;/g;
	
	  $part = $otag.$data.$etag;
	}
	push(@parts, $part);
  }

  $xmlstr = join("\n", @parts);

  return $xmlstr;
}



__END__



