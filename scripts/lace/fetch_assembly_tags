#!/usr/local/bin/perl -w

### fetch_assembly_tags

use strict;
use Hum::Submission ('prepare_statement');
use Hum::Tracking ('intl_clone_name');
use Hum::AnaStatus::Sequence;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotatedClone;

use Bio::EnsEMBL::DBSQL::CloneAdaptor;

use Getopt::Long 'GetOptions';

$| = 1;

my ($dataset, $verbose, @sets, @clones, $clone_list, $check);

my $help = sub { exec('perldoc', $0) };


Bio::Otter::Lace::Defaults::do_getopt(
									  'ds|dataset=s' => \$dataset,
									  'v|verbose'    => \$verbose,
									  's|set=s@'     => \@sets,
									  'c|clone=s@'   => \@clones,
									  'clist=s'      => \$clone_list,
									  'check'        => \$check,
									  'h|help'       => $help,
									 ) or $help->(); # plus default options

$help->() unless ($dataset && (@sets || @clones || $clone_list) );

{
  my $client       = Bio::Otter::Lace::Defaults::make_Client();
  my $dset         = $client->get_DataSet_by_name($dataset);
  my $otter_db     = $dset->get_cached_DBAdaptor;

  # first make sure new clones added by load_otter_ensembl are populated in the assembly_tagged_clone table
  prepare_new_clones_for_assembly_tag($otter_db);

  # hashref
  my $atagCtgID_clnID = get_assembly_tagged_clones($otter_db);



  # options to populate assembly_tag table, see also POD
  if ( @sets ) {

	# when specifying -set all
	my @tmp;
    if ( $sets[0] eq "all" ){

      warn "Fetching all assembly types\n";

      my $sth = $otter_db->prepare(q{SELECT assembly_type FROM sequence_set});
      $sth->execute;

	  while ( my ($type) = $sth->fetchrow_array()) {
		push (@tmp, $type);
      }
      $sth->finish;
      @sets = @tmp;
	  undef @tmp;
    }

    my $type;
    foreach $type ( @sets ) {

      warn "\nWorking on $type\n";

      $otter_db->assembly_type($type); # replace the default sequence set setting
      my $seqSet = $dset->get_SequenceSet_by_name($type);
      my $clones = $dset->fetch_all_CloneSequences_for_SequenceSet($seqSet);

      fetch_by_clone_obj($clones, $otter_db, $atagCtgID_clnID, $type);
    }
  }

  elsif ( @clones ) {
    fetch_by_clone_name(\@clones, $otter_db, $atagCtgID_clnID);
  }

  elsif ( $clone_list ){
    my $clones = [];
    open(my $fh, $clone_list) || die $!;
    while (<$fh>){
      chomp;
      push(@$clones, $_) if $_; # ignore empty lines
    }

    fetch_by_clone_name($clones, $otter_db, $atagCtgID_clnID);
  }
}

###################################################################
#                      s u b r o u t i n e s
###################################################################

sub prepare_new_clones_for_assembly_tag {
  my $otter_db = shift;

  my $new_clones = $otter_db->prepare(q{
										SELECT cl.clone_id
										FROM clone cl
										LEFT JOIN assembly_tagged_clone at
										ON cl.clone_id = at.clone_id
										WHERE at.clone_id is NULL
									   });
  $new_clones->execute;
  my $rows;

  while ( my $cln_id = $new_clones->fetchrow ) {
	$rows .= "($cln_id),";
  }
  $new_clones->finish;

  if ( $rows ) {
	$rows =~ s/,$//;
	my $added;

	$otter_db->begin_work;
	eval {
	  my $cln = $otter_db->prepare("INSERT INTO assembly_tagged_clone (clone_id) VALUES $rows");
	  $cln->execute();
	  $added = $cln->rows;
	  $cln->finish;
	};

	unless ( $@ ){
	  $otter_db->commit;
	  warn "$added NEW clone ids added to assembly_tagged_clone table";
	}
	else {
	  $otter_db->rollback;
	}
  }
  else {
	warn "\nNo new clone ids added to assembly_tagged_clone table\n\n";
  }
}

sub fetch_by_clone_name {

  my ($clones, $otter_db, $atagCtgID_clnID) = @_;
  my $cloneAd = $otter_db->get_CloneAdaptor;
  my $cl_obj = [];

  foreach ( @$clones ){
    push( @$cl_obj, $cloneAd->fetch_by_accession_version( split(/\./, $_)) );
  }

  fetch_by_clone_obj($cl_obj, $otter_db, $atagCtgID_clnID);
}

sub fetch_by_clone_obj {

  my ($clones, $otter_db, $atagCtgID_clnID, $type) = @_;

  my $cloneAd = $otter_db->get_CloneAdaptor;
  my ($atagClone_acefile_info, $to_do, $acc, $ctg_name, $seq_name, $ctg_id, $version, $ctg_strand, $humace_file);

  foreach my $obj (@$clones) {

    $to_do = 0;
    # does only clones not yet assembly_tag tagged
    if ( ref($obj) eq "Bio::Otter::AnnotatedClone" && !exists $atagCtgID_clnID->{$obj->get_all_Contigs->[0]->dbID} ){

      $to_do = 1;

      $acc        = $obj->embl_id;
      $ctg_name   = $obj->get_all_Contigs->[0]->name;
      $seq_name   = sanger_name($obj->embl_id);
      $ctg_id     = $obj->get_all_Contigs->[0]->dbID;
      $version    = $obj->embl_version;
      $ctg_strand = get_contig_strand($ctg_id, $otter_db);
    }

    elsif ( ref($obj) eq "Bio::Otter::Lace::CloneSequence" && !exists $atagCtgID_clnID->{$obj->contig_id} ){

      $to_do = 1;

      $acc        = $obj->accession;
      $ctg_name   = $obj->contig_name;
      $seq_name   = sanger_name($obj->accession);
      $ctg_id     = $obj->contig_id;
      $version    = $obj->sv;
      $ctg_strand = $obj->contig_strand;
    }

    # skip clones in otter db where there is no corresponding accession in the submissions database
	my $seq;

    eval {
      #Hum::AnaStatus::Sequence->new_from_seqname_sv($seq_name, $version);
      $seq = Hum::AnaStatus::Sequence->new_from_accession($acc);
    };

    # work out path to acefile with assembly_tags info of a Sanger clone
    if ( !$@ && $seq_name && $to_do == 1 ){
	  my $dir = $seq->analysis_directory;

      # double check existence of acefile
      if ( -e "$dir/rawdata/$seq_name.humace.ace" ){
		$humace_file = "$dir/rawdata/$seq_name.humace.ace";
	  }
      elsif ( -e "$dir/rawdata/$seq_name.humace.ace.gz" ){
		$humace_file = "$dir/rawdata/$seq_name.humace.ace.gz";
	  }
	  else {
		print "INFO: $ctg_name - no acefile at $dir/rawdata/\n" if !$humace_file and ($verbose or $check);
      }

	  # use for checking existence/location of assembly_tag acefile of a clone (acc.sv)
	  if ( $check ){
		print "$acc.$version => $humace_file\n";
	  }

	  push(@{$atagClone_acefile_info->{$ctg_name}}, $humace_file, $ctg_strand, $ctg_id) if $humace_file and !$check;
    }
  }
  exit if $check;

  # parsing acefile for all Sanger clones of an assembly type in one go
  my $contig_atag_data = parse_ace($atagClone_acefile_info, $otter_db);

  # insert new data to assembly_tag table and update assembly_tagged_clone table
  if ( scalar keys %$contig_atag_data > 0 ){
	warn "About to store new assembly tags ...\n";
	store_and_update($contig_atag_data, $otter_db);
  }
  else {
	warn "\nNothing new to update for $type\n\n";
  }
}

sub get_assembly_tagged_clones {

  my $otter_db = shift;
  my $ctgID_clnID = {};

  my $tagged = $otter_db->prepare(qq{
									 SELECT c.contig_id, cl.clone_id
									 FROM assembly_tagged_clone atc
									 , clone cl
									 , contig c
									 WHERE atc.transferred = 'yes'
									 AND cl.clone_id = c.clone_id
									 AND c.clone_id = atc.clone_id
									});
  $tagged->execute;

  while ( my ($ctg_id, $cln_id) = $tagged->fetchrow ) {
	$ctgID_clnID->{$ctg_id} = $cln_id;
  }
  $tagged->finish;

  return $ctgID_clnID;
}

sub get_contig_strand {

  my ($ctg_id, $otter_db) = @_;
  my $ori = $otter_db->prepare(q{
									SELECT e.contig_strand
									FROM exon e, contig c
									WHERE c.contig_id = ?
									AND c.contig_id = e.contig_id
								   });
  $ori->execute($ctg_id);

  my $strand = $ori->fetchrow;
  $ori->finish;

  return $strand;
}

sub parse_ace {

  my ($atagClone_acefile_info, $otter_db)  = @_;

  my $asmblyTagAd = $otter_db->get_AssemblyTagAdaptor;

  my ($fh, $line);
  my ($contig_atag_data, $ctg_name);

  # go thru each contig of an assembly type
  foreach $ctg_name ( keys %$atagClone_acefile_info ){

    my @values;
    my $ace_file   = $atagClone_acefile_info->{$ctg_name}->[0];
    my $ctg_id     = $atagClone_acefile_info->{$ctg_name}->[2];

    if ($ace_file =~ /\.gz$/) {
      $ace_file = "gzip -cd $ace_file |";
    }

    open( $fh, $ace_file ) || die "Failed to read $ace_file";
    my $info;

    while ( $line = <$fh> ){

      my $ctg_strand = $atagClone_acefile_info->{$ctg_name}->[1];
      my ( $tag_type, $tag_start, $tag_end, $tag_info);

      # omit Type "Oligo"

      if ( $line =~ /^Assembly_tags\s+(-|\"-\"|unsure)\s+(\d+)\s+(\d+)\s+\"(.+)\"/i ){

		($1 eq "-" || $1 eq "\"-\"") ? ($tag_type = "Misc") : ($tag_type = $1);

		# convertion for Ensembl/otter_db: starting coord is always smaller, so flip if not so
        #                                  starting coord > end coord means minus strand

		if ( $2 > $3 ){
		  $tag_start = $3;
		  $tag_end   = $2;
		  if ( $ctg_strand == -1 ){
			$ctg_strand = 1;
		  }
		  else {
			$ctg_strand = -1;
		  }
		}
		elsif ( $2 < $3 ) {
		  $tag_start  = $2;
		  $tag_end    = $3;
		}
		elsif ( $2 == $3 ){
		  $tag_start = $tag_end = $2;
		  $ctg_strand = 1;   # default setting
		}

		$4 ? ($tag_info = $4) : ($tag_info = "Null");
		$tag_info = trim($tag_info);

		if ( $verbose ){
		  $info .= "flip\n" if $2>$3;
		  $info .= "$ctg_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info\n";
		}
		push(@{$contig_atag_data->{$ctg_name}}, $ctg_id, $tag_start, $tag_end, $ctg_strand, $tag_type, $tag_info);
      }

      if ( $line =~ /^(Clone_\w+_end)\s+(.+)\s+(\d+)/i ){

		$tag_type   = $1;
		$tag_start  = $3;
		$tag_end    = $3;  # set end value to start value as no end value present
		$tag_info   = $2;
		$ctg_strand = 1;
		$tag_info   =~ s/\"//g;
		$tag_info   = trim($tag_info);
	
		# replace internal Sanger name (= $tag_info) with international clone name
		my $name = $tag_info." (old name) ";
		$tag_info = Hum::Tracking::intl_clone_name($tag_info); # info in Oracle Trackings db
		$name .= $tag_info." (intl name)";

		$info .= "$ctg_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info --- [$name]\n" if $verbose;
	
		push(@{$contig_atag_data->{$ctg_name}}, $ctg_id, $tag_start, $tag_end, $ctg_strand, $tag_type, $tag_info);
      }
    }

    # log/info message
    if ( $info ){
      $info = "\n".$ctg_name." => ".$ace_file."\n".$info;
      print $info if $verbose;
    }
    else {
      print "\nNOTE: ".$ctg_name." => ".$ace_file." (no assembly_tag data)\n" if $verbose;
    }
  }

  return ($contig_atag_data);
}

sub trim {
  my $st = shift;
  $st =~ s/\\n/ /g;
  $st =~ s/\s{1,}/ /g;
  return $st;
}

sub sanger_name {
  my( $acc ) = @_;

  my $sth = prepare_statement(qq{
        SELECT s.sequence_name
        FROM project_acc a
          , project_dump d
          , sequence s
        WHERE a.sanger_id = d.sanger_id
          AND d.seq_id = s.seq_id
          AND a.accession = '$acc'
        ORDER BY s.seq_id DESC
        LIMIT 1
        });

  $sth->execute;
  my $sanger_name = $sth->fetchrow;
  $sth->finish;

  return $sanger_name if $sanger_name;
}

sub store_and_update {

  my ($ctg_atag_data, $otter_db) = @_;

  my (@rows, @ctg_ids);

  $otter_db->begin_work;

  eval {
    foreach my $ctg_name ( keys %$ctg_atag_data ) {

      my @values = @{$ctg_atag_data->{$ctg_name}};
	  warn "NEW assembly_tagged contig: $ctg_name (ctgid: $values[0])\n";

      for ( my $i = 0; $i < scalar @values; $i=$i+6 ) {

		# column contig_end/tag_info can be null for tag_type = clone_left_end or clone_right_end
		$values[$i+5] = '' if  $values[$i+5] eq "Null";
		push(@rows, "('', $values[$i], $values[$i+1], $values[$i+2], $values[$i+3], '$values[$i+4]', '$values[$i+5]')");
		push(@ctg_ids, $values[$i]);
	  }
	}
	my $rows = join(',', @rows);
	my $atag = $otter_db->prepare(qq{
									 INSERT IGNORE INTO assembly_tag
									 (tag_id, contig_id, contig_start, contig_end, contig_strand, tag_type, tag_info)
									 VALUES $rows
									});
	$atag->execute;
	$atag->finish;

	# update also assembly_tagged_clone table, which is initially
	# populated with all clones having transferred col = "no"

	my $ctgids = join(',', @ctg_ids);

	my $sql_1 = $otter_db->prepare(qq{
									  SELECT ct.clone_id
									  FROM contig ct, clone cl
									  WHERE ct.clone_id = cl.clone_id
									  AND ct.contig_id in ($ctgids)
									 });
	$sql_1->execute;
	
	my @clnIDs;
	
	while ( my $cln_id = $sql_1->fetchrow ){
	  push(@clnIDs, $cln_id);
	}
	$sql_1->finish;
	
	my $clone_ids = join(',', @clnIDs);

	my $sql_2 = $otter_db->prepare(qq{
									  UPDATE assembly_tagged_clone
									  SET transferred = 'yes'
									  WHERE clone_id in ($clone_ids)
									 });
	$sql_2->execute;
	$sql_2->finish;
	$otter_db->commit;
  };

  if ( !$@ ){
	printf(">Successful\n\n");
  }
  else {
	print $@;
	printf(">Failed\n\n");
	$otter_db->rollback;
  }
}

__END__


=head1 NAME - fetch_assembly_tags

=head1 SYNOPSIS

Script parameters: database_name (eg, fetch_assembly_tags B<-dataset> human B<-verbose> [optional]) followed by one of the 4 options, eg:

1. B<-set> chr4 B<-set> -chr20  (fetch all clones from one or more chromosomes)

2. B<-set> all (fetch all clones from all chromosomes)

3. B<-clone> AC000094.x B<-clone> AC000095.x  (fetch single or multiple clones [accession.version])

4. B<-clist> filename (fetch from list of clones as [accession.version] from file, one clone per line)

5. or specify acc.sv to see location of assembly_tag acefile.  B<-check> B<-clone> AL627402.10


Verbose mode prints detailed info of assembly_tags.

=head1 DESCRIPTION

There are assembly_tags info for Sanger clones submitted to EMBL. This is stored in "submissions" database (B<~jgrg/bin/sql>)
and can be found in acefiles, eg, /nfs/disk100/humpub/analysis/projects/Chr_20/yR31BE7/20001221/rawdata/yR31BE7.humace.ace.

The Assembly_tags info is shown in AceDB under the Assembly_tags tag of a Sequence object and is stored in B<assembly_tag> table of otter db.

This script populates and updates the otter B<assembly_tag> and B<assemlby_tagged_clone> tables, respectively.
The latter table is populated by "INSERT INTO assembly_tagged_clone (clone_id) SELECT clone_id FROM clone;"
before hand, where all clones have the transferred column with value initially set to "no".
For clones which have assembly_tag data, it will be updated to "yes".

The B<assembly_tagged_clone> table allows quick look up of clones that have assembly_tag info.

Assembly_tag info in the otter DB is dumped out in EMBL format via the script B<emblDump> in the humscripts directory.
(To check out: cvs -d /nfs/humace2/CVS_master checkout humscripts)

=head1 AUTHOR

Chao-Kung Chen B<email> ck1@sanger.ac.uk
