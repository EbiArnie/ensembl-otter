#!/usr/local/ensembl/bin/perl -w

=head1 NAME

loadSeqSet_OttertoPipeline.pl

=head1 SYNOPSIS

loadSeqSet_OttertoPipeline.pl

=head1 DESCRIPTION

This script is used to load a sequence set from an organisme specific Otter database into the seq_region, seq_region_attrib, attrib_type, assembly and dna tables of the Pipeline database. 
Appropriate option like the coord_system version for the specific chromosome coord_system level, has to be given from the coord_system table of the corresponding database.
a set of seq_regions into the seq_region object. The sequence that is loaded into the dna table is Pfetched. 

here is an example commandline

./loadSeqSet_OttertoPipeline.pl -set chr11 -chromosome_cs_version Otter -ohost ecs4 -oport 3352 -oname otter_human -ouser pipuser -opass ***** -phost otterpipe2 -pport 3352 -pname pipe_human -puser pipuser -ppass *****


=head1 OPTIONS

    -ohost (default:humsrv1)   host name for the dataset specific Otter database (gets put as ohost= in locator)
    -oname (default:otter_human)   For RDBs, what name to connect to (oname= in locator)
    -ouser (default:ensadmin)   For RDBs, what username to connect as (ouser= in locator)
    -opass (default:ensembl)   For RDBs, what password to use (opass= in locator)
    -oport (default:3306)   For RDBs, what port to use (oport= in locator)
    -phost (default:otterpipe1)   host name for the Pipeline database (gets put as phost= in locator)
    -pname (no default)  For RDBs, what name to connect to (pname= in locator)
    -puser (default:ottadmin)   For RDBs, what username to connect as (puser= in locator)
    -ppass (default:wibble)   For RDBs, what password to use (ppass= in locator)
    -pport (default:3302)   For RDBs, what port to use (pport= in locator)

    -chromosome_cs_version the version of the coordinate system being stored
    -set|chr the sequence set to load 
    -help|h      displays this documentation with PERLDOC

=head1 CONTACT

Mustapha Larbaoui B<email> ml6@sanger.ac.uk

=cut

use strict;

use Getopt::Long;
use Bio::SeqIO;
use Bio::EnsEMBL::DBSQL::DBConnection;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch;
use Bio::EnsEMBL::DBSQL::SequenceAdaptor;
use Bio::EnsEMBL::Slice;
use Bio::EnsEMBL::CoordSystem;
use Bio::EnsEMBL::Attribute;
use Bio::EnsEMBL::Utils::Exception qw(throw warning);


# Otter and Pipeline connexion parameters, default values.
my $p_host = 'otterpipe1';
my $p_port = '3302';
my $p_name = '';
my $p_user = 'ottadmin';
my $p_pass = 'wibble';
my $o_host = 'humsrv1';
my $o_port = '3306';
my $o_name = 'otter_human';
my $o_user = 'ensadmin';
my $o_pass = 'ensembl';

my $chromosome_name;
my $chromosome_cs_version;
my $sequence_set;

my $usage = sub { exec( 'perldoc', $0 ); };

&GetOptions(
	'phost:s'                 => \$p_host,
	'pport:n'                 => \$p_port,
	'pname:s'                 => \$p_name,
	'puser:s'                 => \$p_user,
	'ppass:s'                 => \$p_pass,
	'ohost:s'                 => \$o_host,
	'oport:n'                 => \$o_port,
	'oname:s'                 => \$o_name,
	'ouser:s'                 => \$o_user,
	'opass:s'                 => \$o_pass,
	'chromosome_cs_version:s' => \$chromosome_cs_version,
	'chr|set=s'               => \$sequence_set,
	'h|help!'                 => $usage
  )
  or $usage->();

if ( !$p_name ) {
	print STDERR
	  "Can't load sequence set without a target pipeline database name\n";
	print STDERR "-phost $p_host -puser $p_user -ppass $p_pass\n";
	$usage->();
}

if ( !$chromosome_cs_version || !$sequence_set ) {
	print STDERR "Need chr|set and chromosome_cs_version to be able to run\n";
	$usage->();
}

my %end_value;
my $hashref = {};

# Get the sequence data set from Otter database and store it in a Hashtable.
{
	print STDOUT "Getting $sequence_set from Otter database: $o_name ($o_host:$o_port)\n";
	my $dbc = Bio::EnsEMBL::DBSQL::DBConnection->new(
		-user   => $o_user,
		-dbname => $o_name,
		-host   => $o_host,
		-port   => $o_port,
		-pass   => $o_pass
	);
	my $sth = $dbc->prepare(
		q{
        SELECT chr.name, a.chr_start, a.chr_end
          , a.contig_start, a.contig_end, a.contig_ori
          , c.embl_acc, c.embl_version, a.superctg_name
        FROM chromosome chr
          , assembly a
          , contig g
          , clone c
        WHERE chr.chromosome_id = a.chromosome_id
          AND a.contig_id = g.contig_id
          AND g.clone_id = c.clone_id
          AND a.type = ?
        ORDER BY a.chr_start
        }
	);
	$sth->execute($sequence_set);

	while (
		my (
			$chr_name,     $chr_start,  $chr_end,
			$contig_start, $contig_end, $strand,
			$acc,          $sv,         $superctg_name
		)
		= $sth->fetchrow
	  )
	{
		if ( !$end_value{$chr_name} ) {
			$end_value{$chr_name} = $chr_end;
		}
		else {
			if ( $chr_end > $end_value{$chr_name} ) {
				$end_value{$chr_name} = $chr_end;
			}
		}
		$hashref->{ $acc . $sv } = [
			$chr_name,   $chr_start, $chr_end, $contig_start,
			$contig_end, $strand,    $acc,     $sv
		];

	}
	my $row_number = scalar(keys %$hashref);
	throw("No sequence set '$sequence_set' in $o_name") unless($row_number);
	print STDOUT $row_number." contigs retrieved for $sequence_set sequence set\n";
}

# Load the sequence data set into the Pipeline database
{
	print STDOUT "Writing data into Pipeline database: $p_name ($p_host:$p_port)\n";
	my $db = Bio::EnsEMBL::DBSQL::DBAdaptor->new(
		-user   => $p_user,
		-dbname => $p_name,
		-host   => $p_host,
		-port   => $p_port,
		-pass   => $p_pass
	);
	my $db_c = $db->dbc();

	my %asm_seq_reg_id;

	my $attr_a  = $db->get_AttributeAdaptor();
	my $cs_a    = $db->get_CoordSystemAdaptor();
	my $slice_a = $db->get_SliceAdaptor();
	my $seq_a   = $db->get_SequenceAdaptor();

	my $chromosome_cs;
	my $clone_cs;
	my $contig_cs;

	eval {
		$chromosome_cs =
		  $cs_a->fetch_by_name( "chromosome", $chromosome_cs_version );
		$clone_cs  = $cs_a->fetch_by_name("clone");
		$contig_cs = $cs_a->fetch_by_name("contig");

	};
	if ($@) {
		throw(
		"A coord_system matching the arguments does not exsist in the cord_system table, please ensure you have the right coord_system entry in the database [$@]\n"
		);
	}

	# insert chromosome(s) in seq_region table
	foreach my $name ( keys(%end_value) ) {
		my $endv = $end_value{$name};
		my $slice = &make_slice( $name, 1, $endv, $endv, 1, $chromosome_cs );
		$asm_seq_reg_id{$name} = $slice_a->store($slice);
	}

	# insert clone & contig in seq_region, seq_region_attrib, dna and assembly tables
	my $insert_query = qq {
				INSERT INTO assembly 
				(asm_seq_region_id, cmp_seq_region_id,asm_start,asm_end,cmp_start,cmp_end,ori) 
				values 
				(?,?,?,?,?,?,?)};
	my $sth = $db_c->prepare($insert_query);
	while ( my ( $k, $v ) = each %$hashref ) {
		my @values    = @$v;
		my $chr_name  = $values[0];
		my $chr_start = $values[1];
		my $chr_end   = $values[2];
		my $ctg_start = $values[3];
		my $ctg_end   = $values[4];
		my $ctg_ori   = $values[5];
		my $acc       = $values[6];
		my $ver       = $values[7];
		my $acc_ver   = $acc . "." . $ver;

		##fetch the dna sequence from pfetch server with acc_ver id
		my $seqobj ||= &pfetch_acc_sv($acc_ver);
		my $seq    = $seqobj->seq;
		my $seqlen = $seqobj->length;
		
		my $contig = $acc_ver . "." . "1" . "." . $seqlen;
		my $ctg_seq_reg_id;
		my $clone;
		my $clone_seq_reg_id;
		my $slice;

		eval { $clone = $slice_a->fetch_by_region( 'clone', $acc_ver ); };
		if ($clone) {
			warn "clone <". $clone->name."> is already in the pipeline database\n";
			$clone_seq_reg_id = $clone->get_seq_region_id;
			### code to be added to grab contigs related to the clone and
			### alter the contig insertion section by moving it to the else part of this.
		}
		else {
			##make clone and insert clone to seq_region table
			$slice = &make_slice( $acc_ver, 1, $seqlen, $seqlen, 1, $clone_cs );
			$clone_seq_reg_id = $slice_a->store($slice);
			if ( !defined($clone_seq_reg_id) ) {
				print
				"clone seq_region_id has not been returned for the accession $acc_ver";
				exit;
			}
			##make attribute for clone and insert attribute to seq_region_attrib & attrib_type tables
			$attr_a->store_on_Slice( $slice,
				&make_clone_attribute( $acc, $ver ) );

			##make contig and insert contig, and associated dna sequence to seq_region & dna table
			$slice = &make_slice( $contig, 1, $seqlen, $seqlen, 1, $contig_cs );
			$ctg_seq_reg_id = $slice_a->store( $slice, \$seq );
			if ( !defined($ctg_seq_reg_id) ) {
				print
				"contig seq_region_id has not been returned for the contig $contig";
				exit;
			}
			##insert chromosome to contig assembly data into assembly table
			$sth->execute( $asm_seq_reg_id{$chr_name},
				$ctg_seq_reg_id, $chr_start, $chr_end, $ctg_start, $ctg_end,
				$ctg_ori );
			##insert clone to contig assembly data into assembly table
			$sth->execute( $clone_seq_reg_id, $ctg_seq_reg_id, 1, $seqlen, 1,
				$seqlen, $ctg_ori );
		}
	}

}

sub make_clone_attribute {
	my ( $acc, $ver ) = @_;
	my @attrib;
	my $attrib = &make_attribute(
		'htgs_phase',                              'HTGS Phase',
		'High Throughput Genome Sequencing Phase', '3'
	);
	push @attrib, $attrib;
	push @attrib,
	  &make_attribute( 'intl_clone_name', 'International Clone Name',
		'', $acc . "." . $ver );
	push @attrib,
	  &make_attribute( 'embl_accession', 'EMBL Accession', '', $acc );
	push @attrib, &make_attribute( 'embl_version', 'EMBL Version', '', $ver );
	return \@attrib;
}

sub make_attribute {
	my ( $code, $name, $description, $value ) = @_;
	my $attrib = Bio::EnsEMBL::Attribute->new(
		-CODE        => $code,
		-NAME        => $name,
		-DESCRIPTION => $description,
		-VALUE       => $value
	);
	return $attrib;
}

sub make_slice {

	my ( $name, $start, $end, $length, $strand, $coordinate_system ) = @_;
	my $slice = Bio::EnsEMBL::Slice->new(
		-seq_region_name   => $name,
		-start             => $start,
		-end               => $end,
		-seq_region_length => $length,
		-strand            => $strand,
		-coord_system      => $coordinate_system,
	);
	return $slice;
}

#
# Pfetch the sequences
#-------------------------------------------------------------------------------
#  If the sequence isn't available from the default pfetch
#  the archive pfetch server is tried.
#

{
	my ( $pfetch, $pfetch_archive );

	sub pfetch_acc_sv {
		my ($acc_ver) = @_;
		print "Fetching '$acc_ver'\n";
		$pfetch ||= Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch->new;
		$pfetch_archive ||=
		  Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch->new(
			-PFETCH_PORT => 23100, );
		my $seq = $pfetch->get_Seq_by_acc($acc_ver);
		unless ($seq) {
			$seq = $pfetch_archive->get_Seq_by_acc($acc_ver);
		}
		unless ($seq) {
			my $seq_file = "$acc_ver.seq";
			warn
			  "Attempting to read fasta file <$acc_ver.seq> in current dir.\n";
			my $in = Bio::SeqIO->new(
				-file   => $seq_file,
				-format => 'FASTA',
			);
			$seq = $in->next_seq;
			my $name = $seq->display_id;
			unless ( $name eq $acc_ver ) {
				die "Sequence in '$seq_file' is called '$name' not '$acc_ver'";
			}
		}
		return $seq;
	}
}

1;
