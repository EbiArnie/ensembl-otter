#!/usr/local/bin/perl -w

=head1 DESCRIPTION

load_new_otter -dataset dsname <filenames>*

=head1 OPTIONS

-dataset dsname

<filenames>* are input files to be parsed in mixed format (text_header+otter_xml)
             Input is taken from STDIN if there are no filenames.

=cut

    # run it as a new schema script:
BEGIN {
    foreach my $path (@INC) {
        unless( $path=~s{ensembl/modules}{ensembl_head/modules}g ) {
            $path=~s{ensembl_head/modules}{ensembl/modules}g;
        };
    }
}


use strict;
use Bio::Otter::Lace::Defaults;
use Bio::Vega::Transform::Otter;
use Bio::Vega::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Utils::Exception qw ( throw warning );

$|=1;

my $dsname = '';

Bio::Otter::Lace::Defaults::do_getopt(
    'dataset=s' => \$dsname,
);

my $cl = Bio::Otter::Lace::Defaults::make_Client();
my $ds = $cl->get_DataSet_by_name($dsname);

if(!$ds->HEADCODE()) {
    die "Can only load things into a new API database";
}

my $dba = $ds->get_cached_DBAdaptor;

###start working with the actual dump file
#unless ($mc->list_value_by_key('last_gene_old_dbid')){
#$mc->store_key_value('last_gene_old_dbid',0);
#}

my $mc=$dba->get_MetaContainer();
my $sa=$dba->get_SliceAdaptor();
my $gene_adaptor=$dba->get_GeneAdaptor();

my $dbid;
my $ss_hash;
my $loading_started=time();

$/="----------------------------------------\n";
## read from STDIN + @ARGV filenames
while (<>){
  my $gene_xml=$_;
  eval{
	 $dba->begin_work;
	 chomp $gene_xml;
	 if ($gene_xml=~/^\S+\s+(\S+)\s+(\S+)\s+(\S+)\s+(<locus>.*<\/locus>).*/ms){
		
		my $ss=$1;
		$dbid=$2;
		my $modified=$3;
		$gene_xml=$4;

		my $slice = $ss_hash->{$ss} ||= $sa->fetch_by_region('chromosome',$ss,undef,undef,undef,'Otter') ;

		unless ($slice) {
		  throw "slice for $ss is not in db";
		}
		##create a parser 
		my $parser = Bio::Vega::Transform::Otter->new;
		$parser->set_ChromosomeSlice($slice);
		$parser->parse($gene_xml,'latin1');
		my $genes=$parser->get_Genes;
		my $gene_count=@$genes;
		if ($gene_count!=1) {
            throw "parser has returned $gene_count genes (instead of 1) for geneid : $dbid";
		}

		my $gene=$genes->[0];
        my $current = ($gene->biotype !~ /obsolete/) ? 1 : 0;

		$gene->is_current( $current );
		$gene_adaptor->store($gene,'chr_whole_slice', $modified);

        if($current) {
            print STDOUT "stored old gene dbid:$dbid as new gene dbid:".$gene->dbID
                        ." and the curent version is:".$gene->stable_id.".".$gene->version. "\n";
        } else {
            print STDOUT "The gene ".$gene->dbID." was deleted from the database\n";
        }

		$mc->update_key_value('last_gene_old_dbid',$dbid);

		$dba->commit;
		$parser->DESTROY;
	 }
  };
  if ($@) {
	 $dba->rollback;
	 print STDERR ("\ngene $dbid did not get loaded due to \n" .$@);
  }
}

my $loading_finished=time();
my $total_time=$loading_finished-$loading_started;
print STDOUT "Total time for storing the above genes is $total_time\n";

1;
