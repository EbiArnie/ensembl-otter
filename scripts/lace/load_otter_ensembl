#!/usr/local/bin/perl -w

use strict;

use Getopt::Long;
use Bio::SeqIO;
use Bio::EnsEMBL::Analysis;
use Bio::EnsEMBL::Clone;
use Bio::EnsEMBL::RawContig;
use Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch;
use Bio::EnsEMBL::Chromosome;

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Clone;
use Bio::Otter::Lace::CloneSequence;
use Bio::Otter::Lace::PipelineDB;
use Bio::Otter::Lace::Defaults;

use Data::Dumper;

{

# some important variables (and some less inportant ones that look neater up here)
    my $INPUT_TYPE;       # AGP or LIST
    my $agp_file;         # the file containing the assembly details
    my $agp_chr_name;     # tmp variable for chr in agp file
    my $pipe_analysis;    # analysis adaptor for the pipeline db
    my $end_coord;        # max(chr_end)
    my $clone_sequence_list
      ;                   # the clone sequence list built for the sequence set

    ## next set of variables are overwritten if a command line option is specified
    my $analysis_priority =
      5;                  # hold the default value for the analysis priority
    my $author      = (getpwuid($<))[0];
    my $description =
      undef;              # "This is a default description, created by $author";
    my $dataset_name    = undef;            # dataset to get from otter server
    my $chromosome_name = undef;
    my $set_name        = undef;
    my $submit_contig   = 'SubmitContig';
    my $superctg_ori    = 1
      ; # default value for just now. - true value will be added by a different script
    my $help      = 0;
    my $at_sanger = 1;    # Set if we want to get sequence notes and clone names
    my $do_submit = 0;	  # Set if we don't want to prime the pipeline with the SubmitContig analysis 
    my $populate_pipe = 0;

    my $old_set_name;   # an optional set_name to hide
    my $unhide;         # set this if you want the set to be loaded NOT to be hidden

    #---------------------------------------------------------------------------
    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s'     => \$dataset_name,
        'description=s' => \$description,
        'priority=i'    => \$analysis_priority,
        'chromosome=s'  => \$chromosome_name,
        'set|name=s'    => \$set_name,
        'sanger!'       => \$at_sanger,
        'no_submit'     => sub{ $do_submit = 0 },
        'submit!'	    => \$do_submit,
        'pipe!'         => \$populate_pipe,
        'replace=s'     => \$old_set_name,
        'unhide!'       => \$unhide,
      )
    or Bio::Otter::Lace::Defaults::show_help();

    Bio::Otter::Lace::Defaults::show_help() unless $dataset_name;

    # takes the remaining argument as the filename to be read
    $agp_file = $ARGV[0];

    $do_submit = 0 unless $populate_pipe;

    # some options checking to make sure there's some sanity
    warn 'cannot load assembly details, as there is no agp file'
      if (!defined $agp_file);
    die "no description given" if (!defined $description);
    die "you need to give the set name as an argument" if (!defined $set_name);
    die "Chr names containing 'chr' are illegal: <$chromosome_name>"
      if ($chromosome_name =~ /chr/i);

    # make otter client and connect to database
    my $cl       = Bio::Otter::Lace::Defaults::make_Client();
    my $ds       = $cl->get_DataSet_by_name($dataset_name);

    my $otter_db = $ds->get_cached_DBAdaptor;

    # Make a connection to the pipeline database
    my ($pipeline_db, $ana_obj);
    if ($populate_pipe) {
        $pipeline_db =
          Bio::Otter::Lace::PipelineDB::get_pipeline_rw_DBAdaptor($otter_db);
        $pipeline_db->db_handle->{'PrintError'} =
          0;    # turn off error writing for this db handle

        # Get SubmitContig analysis object for priming the pipeline
        $pipe_analysis = $pipeline_db->get_AnalysisAdaptor;
        my $ana_obj = $pipe_analysis->fetch_by_logic_name($submit_contig);
        unless ($ana_obj) {
            $ana_obj = new Bio::EnsEMBL::Pipeline::Analysis(
                -LOGIC_NAME    => $submit_contig,
                -INPUT_ID_TYPE => 'CONTIG',
            );
            $pipe_analysis->store($ana_obj);
        }
    }

#------------------------- read input file -----------------------------------------
    open(my $fh, "$agp_file") or die "Can't read '$agp_file' : $!";

    # make an empty sequence set to start with
    my $SequenceSet = Bio::Otter::Lace::SequenceSet->new;
    $SequenceSet->name($set_name);               # set name from command line
    $SequenceSet->dataset_name($dataset_name);   # data set from command line
    $SequenceSet->description($description);     # description from command line

    while (!$INPUT_TYPE && defined(my $first = <$fh>)) {
        chomp($first);
        next if $first =~ /^\#/;
        ($INPUT_TYPE, $agp_chr_name) = check_line($first, $chromosome_name);
        $INPUT_TYPE = undef if $INPUT_TYPE eq 'SKIP';
    }
    seek($fh, 0, 0) or die "Can't go back to beginning of file: $!";
    die "check format of file" unless $INPUT_TYPE;

    # Chr prefix causes problems for Apollo
    $chromosome_name ||= $agp_chr_name;
    die "you need to specify a chromosome name" unless $chromosome_name;
    $chromosome_name =~
      s/^chr//i;    # recheck chromosome name as it may have changed [AGP]

    my $otter_chromosome = get_chromosome($otter_db,    $chromosome_name);

    if(!$otter_chromosome) {
        die "Could not create a chromosome object";
    }

    my $pipe_chromosome;
    if ($pipeline_db) {
        $pipe_chromosome = get_chromosome($pipeline_db, $chromosome_name);
        $end_coord =
          $ds->tmpstore_meta_info_for_SequenceSet($SequenceSet,
            [ $otter_db, $pipeline_db ]);
    } else {
        $end_coord =
          $ds->tmpstore_meta_info_for_SequenceSet($SequenceSet,
            [ $otter_db ]);
    }

    # $ds->__dump_table("meta_info", [$otter_db, $pipeline_db]);
    # warn "This is end_coord: $end_coord";

    while (<$fh>) {

        # Skip comment lines
        chomp;
        next if $_ =~ /^\#/;
        my (
            $input_type, $super_contig_name, $chr_start, $chr_end,
            $n,          $type,              $acc_ver,   $ctg_start,
            $ctg_end,    $ctg_ori
          )
          = check_line($_, $chromosome_name);
        if ($input_type ne $INPUT_TYPE) {
            warn "Skipping $input_type type line\n";
            next;
        }
        if ($input_type eq 'AGP') {

     # input file must be in AGP format
     # 0       1       2       3       4       5               6       7       8
     # chr_20  2808333 2934911 29      F       AL121905.0      101     126679  +
     # nothing else needs to be done to organise the line.
        }
        elsif ($input_type eq 'LIST') {

            # grrr we have to pfetch twice.
            ## all we have is the list of contigs/clones - need to give default values for agp
            my $seq = pfetch_acc_sv($acc_ver);
            my $seq_length;
            if ($seq) {
                $seq_length = $seq->length;
                print STDERR "Sequence: $acc_ver, length: $seq_length\n";
            }
            else {
                die "Can't fetch sequence '$acc_ver'\n";
            }

 # $super_contig_name/$chromosome_name should be available from the command line
 # if we have a clone list as input (or we would have died earlier)
            $super_contig_name = $chromosome_name;
            $n       = 5;    # does this get used for anything? - don't think so
            $type    = 'F';
            $ctg_ori = '+';
            $chr_start = $end_coord + 10001;
            $chr_end   = ($chr_start + $seq_length - 1);
            $end_coord =
              $chr_end;    # so that it is in a suitable position for next time
            $ctg_start = 1;
            $ctg_end   = $seq_length
              ; # $ctg_end = $ctg_start + length - 1 ; as we are starting at 1 just use length

        }
        else {
            die "You should have input type AGP or LIST not <$INPUT_TYPE>\n";
        }

        # translate orientation to integer
        if ($ctg_ori eq '-') {
            $ctg_ori = -1;
        }
        elsif ($ctg_ori eq '+') {
            $ctg_ori = 1;
        }
        else {
            die "Invalid orientation '$ctg_ori'\n";
        }

        #split into accesion number and version number
        my ($acc, $sv) = $acc_ver =~ /^(.+)\.(\d+)$/;
        die "Can't parse '$acc_ver' into accession and sv\n"
          unless $acc and $sv;

        # make a CloneSequence for each line
        my $cs = Bio::Otter::Lace::CloneSequence->new();

        $cs->accession($acc);
        $cs->sv($sv);

        # $cs->clone_name();
        # $cs->length();
        $cs->chromosome($otter_chromosome->dbID);
        $cs->pipeline_chromosome($pipe_chromosome->dbID) if $pipeline_db;
        $cs->chr_start($chr_start);
        $cs->chr_end($chr_end);
        $cs->super_contig_name($super_contig_name);

        # $cs->contig_id();
        # $cs->contig_name();
        $cs->contig_start($ctg_start);
        $cs->contig_end($ctg_end);
        $cs->contig_strand($ctg_ori);

        # add CloneSequence to the SequenceSet (temporary array)
        push(@{$clone_sequence_list}, $cs);

    }
    close $fh;

#--------------------------------finished reading input file ------------------------

    # Store the sequence set, returning a list of pipeline contigs
    #warn "Storing '$clone_sequence_list'";
    $SequenceSet->CloneSequence_list($clone_sequence_list);
    my $pipe_contigs =
      $ds->store_SequenceSet($SequenceSet, \&pfetch_acc_sv,
        $INPUT_TYPE eq 'LIST',
        $populate_pipe);

    hide_set($otter_db, $old_set_name) if $old_set_name;


    # print STDERR join("\n", map { $_->name } @$pipe_contigs);

    # prime the pipeline database with SubmitContig analysis
    store_input_id_analysis($pipe_contigs, $pipeline_db, $ana_obj) if $do_submit;

    # update chromosome lengths
    update_chromosome_length($pipeline_db, $pipe_chromosome) if $pipeline_db;
    update_chromosome_length($otter_db,    $otter_chromosome);

    # repair_intl_clone names now used to replace clones_to_otter
    ## Get sequence notes and clone names from fox and oracle
    #if ($at_sanger) {
    #    my ($root) = $0 =~ m{^(.+?)[^/]+$};
    #    $root =~ s{/$}{};
    #    system("$root/submissions_to_otter",
    #        '-host', $cl->host(),
    #        '-port', $cl->port(),
    #        '-dataset', $dataset_name);
    #    system("$root/clones_to_otter",
    #        '-host', $cl->host(),
    #        '-port', $cl->port(),
    #        '-reverse',
    #        '-dataset', $dataset_name);
    #}

    unhide_set($otter_db, $set_name) if $unhide;
}

#------------------end of main script ------------------------------------------
#                     Subroutines
#-------------------------------------------------------------------------------


sub hide_set {
    my( $dba, $ssname ) = @_;
    
    my $sth = $dba->prepare(q{
        UPDATE sequence_set
        SET hide = 'Y'
        WHERE assembly_type = ?
        });
    $sth->execute($ssname);
}

sub unhide_set {
    my( $dba, $ssname ) = @_;
    
    my $sth = $dba->prepare(q{
        UPDATE sequence_set
        SET hide = 'N'
        WHERE assembly_type = ?
        });
    $sth->execute($ssname);
}

#
# check line
#-------------------------------------------------------------------------------
# reads/checks each line of input file
#
sub check_line {
    my ($line, $chromosome_name) = @_;
    my $input_type;

# 0       1       2       3       4       5               6       7       8     9
# chr_20  2808333 2934911 29      F       AL121905.0      101     126679  +     Optional comment
# splits each line into its component parts - puts line in a temporary array (splits the line on whitespace)
    my @line_in_array = split /\s+/, $line, 10;

    # warn 'line: ', join(', ', map "'$_'", @line_in_array), "\n";

    if (scalar(@line_in_array) == 1) {

       # cant think of anything to check  here yet
       # we will end up here if the input file has only a list of contigs in it.
        $input_type = "LIST";
        if (!defined $chromosome_name) {

            # we need a chromosome name if only a list of contigs is given
            die
"you need to provide the name of a chromosome when the input file is a list of clones";
        }
        $line_in_array[5] = $line_in_array[0];
        $line_in_array[9] = "FROM LIST OF CLONES";
        $line_in_array[0] = $chromosome_name;
    }
    elsif ($line_in_array[4] && $line_in_array[4] =~ /^[AUF]$/) {

        # we must have the full file rather than just clone names
        $input_type = "AGP";

        if ($chromosome_name) {
            $line_in_array[0] =~ s/^chr//i;
            die
"clones on different chromosomes: '$chromosome_name' and '$line_in_array[0]'"
              unless $chromosome_name eq $line_in_array[0];
        }
    }
    else {
        return ('SKIP');
    }
    return $input_type, @line_in_array;
}

#
# Pfetch the sequences
#-------------------------------------------------------------------------------
#  If the sequence isn't available from the default pfetch
#  the archive pfetch server is tried.
#
{
    my ($pfetch, $pfetch_archive);

    sub pfetch_acc_sv {
        my ($acc_ver) = @_;

        $pfetch ||= Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch->new;
        $pfetch_archive ||=
          Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch->new(
            -PFETCH_PORT => 23100,);
        my $seq = $pfetch->get_Seq_by_acc($acc_ver);
        unless ($seq) {
            warn "Fetching '$acc_ver' from archive\n";
            $seq = $pfetch_archive->get_Seq_by_acc($acc_ver);
        }
        unless ($seq) {
            my $seq_file = "$acc_ver.seq";
            warn
              "Attempting to read fasta file <$acc_ver.seq> in current dir.\n";
            my $in = Bio::SeqIO->new(
                -file   => $seq_file,
                -format => 'FASTA',
            );
            $seq = $in->next_seq;
            my $name = $seq->display_id;
            unless ($name eq $acc_ver) {
                die "Sequence in '$seq_file' is called '$name' not '$acc_ver'";
            }
        }
        return $seq;
    }
}

#
# Get the chromosome
#---------------------------------------------------------------------------------------------------
# returns a chromosome when given a db object and a chromosome name
sub get_chromosome {
    my ($db, $chr_name) = @_;

    my $chr_adp = $db->get_ChromosomeAdaptor();
    my $chr;
    eval { $chr = $chr_adp->fetch_by_chr_name($chr_name) };

    unless ($chr) {
        ## put a new chromosome into the db to get its id # note that the length value is a default value and will be set later

        $chr = Bio::EnsEMBL::Chromosome->new(
            -chr_name => $chr_name,
            -adaptor  => $chr_adp,
            -length   => 1
        );

        $chr_adp->store($chr);
    }

    return $chr;
}

#
# update_chromosome_length
#-----------------------------------------------------------------------------------------------------------------------
# updates the chromosome length field
# after assembly table has had values entered
sub update_chromosome_length {
    my ($db, $chromosome) = @_;

    my $chr_id = $chromosome->dbID;

    my $chr_length_query =
      qq{ SELECT max(chr_end) FROM assembly WHERE chromosome_id = $chr_id };
    my $sth = $db->prepare($chr_length_query);
    if ($sth->execute()) {
        my $chr_end = $sth->fetchrow;
        if (!defined $chr_end) { $chr_end = 0 }

        $sth =
          $db->prepare(
"UPDATE chromosome SET length = $chr_end WHERE chromosome_id = $chr_id"
          );
        if ($sth->execute) {
        }
        else {
            warn "Couldn't update the chromosome";
        }

    }
    else {
        warn "Couldn't find the max_end value for chromosome with ID: $chr_id";
    }
}

#
# store_input_id_analysis
#-------------------------------------------------------------------------------
# forces a write to the input_id_analysis table
#
sub store_input_id_analysis {
    my ($contigs, $pipe_db, $ana_obj) = @_;
    my $state_info = $pipe_db->get_StateInfoContainer();
    foreach my $contig (@$contigs) {
        my $ctg_name = $contig->name();
        eval {
            $state_info->store_input_id_analysis($ctg_name, $ana_obj,
                'localhost');
        };
    }
}
sub useage { exit(exec('perldoc', $0)); }

__END__


=head1 NAME

load_otter_ensembl

=head1 SYNOPSIS
 
  load_otter_ensembl -dataset <DATASET_NAME> -set <SET_NAME> [-replace <SET_NAME>]\
    -description <DESC> [-[no]pipe] [-no[sanger]] [-no[submit] <AGP>

  load_otter_ensembl -help

=head1 DESCRIPTION

Used to load sequence and assembly data into an
otter database given an AGP file.

=head1 PARAMATERS

=over 4

=item -dataset <DATASET_NAME>

The name of the dataset

=item -set <SET_NAME>

The name of the new set to be loaded.

=item -replace <SET_NAME>

The name of the previous version of this assembly.
This is very important to specify if there is one
(see below).

=item -description <DESC>

Description of the sequence set. This appears in
the SequenceSetChooser window. Especially
important for small special-purpose sequence sets
so that we know in the future why they are there.

=item <AGP>

The name of the AGP file to load.

=back

=head1 FLAGS

=over 4

=item -[no]pipe

Whether or not to load the old pipeline database.
Now defaults to B<no>.

=item -[no]sanger

Whether or not to load international clone names
into otter. Defaults to B<yes>.

=item -[no]submit

Whether or not to add SubmitContig analyses for
each contig in the old pipeline. Defaults to
B<no>.

=item -help

Displays this help message.

=back

=head1 PROCEDURE TO LOAD A NEW AGP

Please follow this procedure when loading a new AGP:

=over 4

=item B<1.> Check the AGP.

If it you make it from chromoview with oracle2agp
follow up any warnings, especially double 5' or 3'
join errors. We need to sort out assembly problems
before annotation begins.

If it is an update to an existing assembly, use
compare_agps to see if it looks sensible relative
to the last one.

Check the gaps - are there gaps where the TPF says
clones should overlap?

We have seen mistakes in non-Sanger and manually
created AGPs. A quick test is to do:

  chromoview/test_agp_parser new.agp > new-parsed.agp
  sdiff new.agp new-parsed.agp

test_agp_parser runs the agp through our parser,
and prints it out again. If there is something
wrong with the chromosomal coodinates, this will
show up as differences in sdiff. (Otherwise
errors in chromosomal coordinates only appear when
an annotator tries to open the clones in
otterlace.)

=item B<2.> Load the AGP with load_otter_ensembl.

Example command line:

  load_otter_ensembl -dataset mouse \
    -set NOD_IDD10-04 \
    -replace NOD_IDD10-03 \
    -desc 'Chromosome 3 NOD strain IDD10 region (2006/03/23)' \
    ~/work/mouse/chr_3/chr3_NOD_IDD10-04.agp

The new set is created with hide=Y, and the old
set (the -replace argument) is also hidden. Thus
the annotators don't see the old or new sets until
we have finished preparing them. They also do not
appear in some of our command line tools such as
"show_sequence_set". (FIXME: they will still be
visible in running otterlace sessions. We need to
add a "write" column to sequence_set that is
looked at by the otterlace system to ensure that
running otterlaces can't open data on sets where
write=N.)

NB: Make sure there aren't any even older sequence
sets that the B<-replace> set that are visible, or
annotators might work on them!

To avoid stalling the annotation process, consider
leaving out the B<-replace> option if the set is
currently being annotated and there is a lot of
pipeline analysis to run on the new set.

load_otter_ensembl now, by default, does not
populate the old pipeline databases. Add the
"-pipe" flag if you need this.

=item B<3.> Load the AGP into the new pipeline database.

As the new pipeline is based on schema version
20+, you will need to use the new API to do that.
After loading the AGP in otter, use the script
below to copy the sequence set from otter into the
new pipeline.

Example command line:

  ensembl-pipeline/scripts/Finished/load_from_otter_to_pipeline.pl \
    -o_name otter_mouse \
    -p_name pipe_mouse \
    -set NOD_IDD10-04

In this example the database connection parameters
(login, password and port) are retrieved from the
~/.netrc file and the otter and pipeline host
(-o_host, -p_host) are the default values,
otterlive and otterpipe1, so we dont need to set
them here. Cf POD documentation for more info and
ask Mustapha if you need a copy of ~/.netrc.

NB: -set can be used several times

=item B<4.> Run the analysis pipeline

This will take a long time if there are a lot of
jobs to run. See note in B<2.> above.

=item B<5.> Run realign_offtrack_genes

Example command line:

  realign_offtrack_genes -dataset mouse -set NOD_IDD10-04

realign_offtrack_genes now locks the region it is realigning, so you
will get a failed lock error if an annotator has part of it open. I
usually run it first with the -test flag to check if it looks like it
is doing the right thing. Save the STDOUT and STDERR in a log file.

=item B<6.> Make the new set visible

If there were no off-track genes, or they were successfully
realigned, then login to the otter database and set the hide column
to "N" for the new set. eg:

  UPDATE sequence_set
  SET hide = 'N'
  WHERE assembly_type = 'NOD_IDD10-04'

=back

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk and a
host of others over the years.

