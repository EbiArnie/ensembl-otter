#!/usr/bin/env perl

use warnings;


### make_assembly_tags_as_misc_features

use strict;
use Hum::Submission ('prepare_statement');
use Hum::Tracking ('intl_clone_name');
use Hum::AnaStatus::Sequence;

use Bio::Otter::Lace::Defaults;
use Bio::Vega::DBSQL::DBAdaptor;

use Bio::EnsEMBL::MiscFeature;
use Bio::EnsEMBL::MiscSet;
use Bio::EnsEMBL::Attribute;


use Getopt::Long 'GetOptions';

$| = 1;

my ($dataset, $verbose, $check);


my $help = sub { exec('perldoc', $0) };


Bio::Otter::Lace::Defaults::do_getopt(
									  'ds|dataset=s' => \$dataset,
									  'v|verbose'    => \$verbose,
									  'check'        => \$check,
									  'h|help'       => $help,
									 ) or $help->(); # plus default options

$help->() unless ( $dataset );


my $client    = Bio::Otter::Lace::Defaults::make_Client();
my $dset      = $client->get_DataSet_by_name($dataset);
my $loutre_db = $dset->make_Vega_DBAdaptor;
my $sliceAd   = $loutre_db->get_SliceAdaptor;
my $mfeats    = [];
my $mfeatAd   = $loutre_db->get_MiscFeatureAdaptor;


{

  my $contigs_to_skip = find_contigs_to_skip(); # ignore contigs already have assembly_tag info

  # fetch acefile with assembly_tag info of clones
  my $clones = $sliceAd->fetch_all('clone');
  prepare_assembly_tag_data($clones, $contigs_to_skip);

  # Caution: the ensembl API does not check for identical misc_features
  # so running the script twice doubles the rows in db - need to fix
  $mfeatAd->store(@$mfeats);
}

#--------------------
#    subroutines
#--------------------

sub find_contigs_to_skip {

  # return 
  my @atype_codes = qw(atag_CLE atag_CRE atag_Misc atag_Unsure);

  my $mfeats;
  foreach ( @atype_codes ){
	push( @$mfeats, $mfeatAd->fetch_all_by_attribute_type_value($_) );
  }

  my $contigs_to_skip;
  foreach ( @$mfeats ){
	foreach my $mf ( @$_ ){
	  $contigs_to_skip->{$sliceAd->fetch_by_region('contig', $mf->slice->seq_region_name)}++;
	}
  }

  if ( $contigs_to_skip ){
	print STDERR scalar keys %$contigs_to_skip, " clones to skip - already with assembly_tag infos ...\n\n";
  }

  return $contigs_to_skip;
}

sub prepare_assembly_tag_data {

  my ($clones, $contigs_to_skip) = shift;

  foreach my $cl ( @$clones ) {
    $cl->seq_region_name =~ /(.*)\.(\d+)/;

    my $cln_db_ver  = $2;
    my $acc         = $1;
    my $contig_name = $cl->seq_region_name.".".$cl->start.".".$cl->end;

	next if $contigs_to_skip->{$contig_name};

    my $seq;
    eval {
      $seq = Hum::AnaStatus::Sequence->new_from_accession($acc);
    };

    unless ( $@ ) {
      my $seq_ver =  $seq->sequence_version;
      unless ( $seq_ver ){
        print STDERR "ERROR: $acc has no version in submissions db - cannot update, Investigate!\n" if $verbose;
        next;
      }

	  # only update if the version of loutre contig match that of submissions db
      if ( $cln_db_ver eq $seq_ver ) {

		my $contig   = $sliceAd->fetch_by_region('contig', $contig_name);
		my $seq_region_id = $sliceAd->get_seq_region_id($contig);

		#if ( $atagAd->check_seq_region_id_is_transferred($seq_region_id) ){
		  #print STDERR "$contig_name (srid $seq_region_id) is already transferred\n";
		  #next;
		#}

        my $dir      = $seq->analysis_directory;
        my $seq_ver  = $seq->sequence_version;
        my $seq_name = $seq->sequence_name;

        # double check existence of acefile
        if ( -e "$dir/rawdata/$seq_name.humace.ace" ) {
          my $acefile = "$dir/rawdata/$seq_name.humace.ace";
          print STDERR "INFO: updating $acc.$seq_ver: $acefile\n" if $verbose;

          parse_ace($contig, $seq_region_id, $acefile, $loutre_db, $sliceAd); # create a list of atag objs
        } else {
          print STDERR "No update for $acc.$seq_ver: MISSING  $dir/rawdata/$seq_name.humace.ace\n" if $verbose;
        }
      }
    }
  }
}

sub parse_ace {

  my ($contig, $seq_region_id, $acefile, $loutre_db, $sliceAd)  = @_;

  my $contig_name       = $contig->seq_region_name;
  my $ctg_seq_region_id = $sliceAd->get_seq_region_id($contig);
  my $ctg_strand        = $contig->strand;
  my $ctg_len           = $contig->seq_region_length;

  if ($acefile =~ /\.gz$/) {
    $acefile = "gzip -cd $acefile |";
  }

  open( my $fh, '<', $acefile ) || die "Failed to read $acefile";

  my $info;

  while ( my $line = <$fh> ) {

    $ctg_strand = 1 unless $ctg_strand; # default to 1 if info not available

    my ( $tag_type, $tag_start, $tag_end, $tag_info);

    # omit Type "Oligo"
    if ( $line =~ /^Assembly_tags\s+(-|\"-\"|unsure)\s+(\d+)\s+(\d+)\s+\"(.+)\"/i ) {

      ($1 eq "-" || $1 eq "\"-\"") ? ($tag_type = "Misc") : ($tag_type = $1);

      # convertion for Ensembl/otter_db: starting coord is always smaller, so flip if not so
      #                                  starting coord > end coord means minus strand

      if ( $2 > $3 ) {
        $tag_start = $3;
        $tag_end   = $2;
        if ( $ctg_strand == -1 ) {
          $ctg_strand = 1;
        }
      } elsif ( $2 < $3 ) {
        $tag_start  = $2;
        $tag_end    = $3;
      } elsif ( $2 == $3 ) {
        $tag_start = $tag_end = $2;
        $ctg_strand = 1;        # default setting
      }

      $4 ? ($tag_info = $4) : ($tag_info = "Null");
      $tag_info = trim($tag_info);

      # flag info about unsure tag beyond the length of the contig in contig table of otter db
      # this will be filtered out

      my $skip = 1;
      if ( $tag_type =~ /unsure/i ) {

        if ( $tag_end > $ctg_len ) {
          $skip = 0;
          $info .= "Unsure tag out of bound (loutre contig seq_region_id $ctg_seq_region_id)\n" .
            "\t [tag coord: $tag_end VS contig length: $ctg_len) - SKIPPED\n";
        }
      }

      # filter out unsure tag out of bound
      if (  $skip == 1 ) {
        if ( $verbose ){
          $info .= "flip\n" if $2>$3;
          $info .= "$ctg_seq_region_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info\n";
        }

		make_misc_feats_for_atags($contig, $ctg_seq_region_id, $tag_type, $ctg_strand, $tag_start, $tag_end, $tag_info);
      }
    }

    if ( $line =~ /^(Clone_\w+_end)\s+(.+)\s+(\d+)/i ) {

      $tag_type   = $1;
      $tag_start  = $3;
      $tag_end    = $3;         # set end value to start value as no end value present
      $tag_info   = $2;
      $ctg_strand = 1;
      $tag_info   =~ s/\"//g;
      $tag_info   = trim($tag_info);
	
      # replace internal Sanger name (= $tag_info) with international clone name
      my $name = $tag_info." (Sanger name) ";
      $tag_info = Hum::Tracking::intl_clone_name($tag_info); # info in Oracle Trackings db
      $name .= $tag_info." (intl name)";

      $info .= "$ctg_seq_region_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info --- [$name]\n" if $verbose;
	  make_misc_feats_for_atags($contig, $ctg_seq_region_id, $tag_type, $ctg_strand, $tag_start, $tag_end, $tag_info);
    }
  }

  # log/info message
  if ( $info ) {
    $info = "\n".$contig_name." => ".$acefile."\n".$info;
    print $info if $verbose;
  } else {
    print "\nNOTE: ".$contig_name." => ".$acefile." (no assembly_tag data)\n" if $verbose;
  }
}

sub trim {
  my $st = shift;
  $st =~ s/\\n/ /g;
  $st =~ s/\s{1,}/ /g;
  return $st;
}

sub make_misc_feats_for_atags {
  my ($contig, $ctg_seq_region_id, $tag_type, $ctg_strand, $tag_start, $tag_end, $tag_info) = @_;

  my $tag_code = {
				  Unsure          => 'atag_Unsure',
				  Clone_left_end  => 'atag_CLE',
				  Clone_right_end => 'atag_CRE',
				  Misc            => 'atag_Misc'
				 };

  my $mfeat = Bio::EnsEMBL::MiscFeature->new(-START  => $tag_start,
											 -END    => $tag_end,
											 -STRAND => $ctg_strand,
											 -SLICE  => $contig);

  my $atag_set = Bio::EnsEMBL::MiscSet->new(-CODE            => $tag_code->{$tag_type},
											-NAME            => 'Assembly tag',
											-DESCRIPTION     => 'Assembly tag',
											-LONGEST_FEATURE => 1e6);


  my $atag_attrib = Bio::EnsEMBL::Attribute->new(-VALUE => $tag_info,
												 -CODE  => $tag_code->{$tag_type},
												 -NAME  => $tag_type,
								  );

  $mfeat->add_MiscSet($atag_set);
  $mfeat->add_Attribute($atag_attrib);

  push(@$mfeats, $mfeat);

}

__END__


=head1 NAME - make_assembly_tags_as_misc_features

=head1 SYNOPSIS

Running the script

Eg, make_assembly_tags_as_misc_features B<-dataset> zebrafish [-verbose][-check]

=head1 DESCRIPTION

There are assembly_tags info for Sanger clones submitted to EMBL. They are stored in "submissions" database and are available as acefiles, eg, /nfs/disk100/humpub/analysis/projects/Chr_20/yR31BE7/20001221/rawdata/yR31BE7.humace.ace.

The Assembly_tags info is shown in AceDB under the Assembly_tags tag of a Sequence object and is stored in B<assembly_tag> table of an otter db.

Assembly_tag info in the otter DB is dumped out in EMBL format via the script B<emblDump> in the humscripts directory.
(To check out: cvs -d /nfs/humace2/CVS_master checkout humscripts)

=head1 AUTHOR

Chao-Kung Chen B<email> ck1@sanger.ac.uk
