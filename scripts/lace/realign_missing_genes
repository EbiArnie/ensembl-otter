#!/usr/bin/env perl

use warnings;


### realign_missing_genes

use strict;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotationBroker;
use Hum::Analysis::Factory::ExonLocator;

{
    my( $dataset_name,
        $sequence_set,
        );

    my $usage = sub { exec('perldoc', $0) };
    Bio::Otter::Lace::Defaults::do_getopt(
        'h|help!'       => $usage,
        'dataset=s'     => \$dataset_name,
        'chr|set=s'     => \$sequence_set,
        ) or $usage->();
    $usage->() unless $dataset_name and $sequence_set;

    # Connect to Ensembl/Otter database and fetch adaptors
    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);
    my $ss = $ds->get_SequenceSet_by_name($sequence_set);
    $ds->fetch_all_CloneSequences_for_SequenceSet($ss);
    #map printf(STDERR "  %s\n", $_->accession), @{$ss->CloneSequence_list};

    my $dba = $ds->get_cached_DBAdaptor;
    $dba->assembly_type($sequence_set);
    my $clone_aptr = $dba->get_CloneAdaptor;
    my $gene_aptr  = $dba->get_GeneAdaptor;
    my $slice_aptr = $dba->get_SliceAdaptor;
    my $accs_missing_genes = @ARGV
        ? [@ARGV]
        : list_exonless_accessions($dba, $sequence_set);
    my $anal = $dba->get_AnalysisAdaptor->fetch_by_logic_name('otter');
    #print map "  $_\n", @$accs_missing_genes;
    
    foreach my $acc_sv (@$accs_missing_genes) {
        my ($acc, $sv) = @$acc_sv;
        my $clid = clone_id_of_clone_with_greatest_sv_and_exons($dba, $acc)
            or next;
        print STDERR "\n$acc\t$sv\n";
        my $old_clone = $clone_aptr->fetch_by_dbID($clid);
        my $old_contig = $old_clone->get_all_Contigs->[0];
        my $gene_id_list = $gene_aptr->list_current_dbIDs_for_Contig($old_contig);
        my @acc_list = accs_connected_to_genes($dba, $gene_id_list);
        my $contig = cs_contig_from_acc_list($ss, [@acc_list]);
        my ($chr, $start, $end) = $cl->chr_start_end_from_contig($contig);
        #warn "Making slice from $chr, $start, $end";
        my $slice = $slice_aptr->fetch_by_chr_start_end($chr, $start, $end);
        my $dest_seq = hum_seq_from_contig($slice);
        my $finder = Hum::Analysis::Factory::ExonLocator->new;
        $finder->genomic_Sequence($dest_seq);
        my $tiles = $slice->get_tiling_path;
        foreach my $gene_id (@$gene_id_list) {
            my $db_gene = $gene_aptr->fetch_by_dbID($gene_id);
            next unless $gene_aptr->Gene_is_current_version($db_gene);
            #print STDERR "\nGene: $gene_id\n";
            #foreach my $t (@{$db_gene->get_all_Transcripts}) {
            #    printf STDERR "  Transcript: %s %s %d\n",
            #        $t->stable_id,
            #        $t->transcript_info->name,
            #        $t->dbID;
            #}
            if (remap_ens_Exons($finder, $db_gene->get_all_Exons, $slice)) {
                warn "Remapped exons OK\n";
                # otter > XML > otter
                my $temp = Bio::Otter::Lace::TempFile->new;
                $temp->name("realign_missing.$$.xml");
                my $w_fh = $temp->write_file_handle;
                print $w_fh
                    "<otter>\n<sequence_set>\n"
                    , Bio::Otter::Converter::path_to_XML($chr, $start, $end, $sequence_set, $tiles)
                    , $db_gene->toXMLString
                    , "</otter>\n</sequence_set>\n";
                my $r_fh = $temp->read_file_handle;
                my ($gene_list) = Bio::Otter::Converter::XML_to_otter($r_fh);
                my $xml_gene = shift @$gene_list;
                $xml_gene->analysis($anal);
                save_new_gene($dba, $gene_aptr, $db_gene, $xml_gene, $slice);
            }
        }
    }
}

sub cs_contig_from_acc_list {
    my( $ss, $acc_list ) = @_;
    
    my %acc_in_list = map {$_, 1} @$acc_list;
    my $cs_ctg = [];
    my $in_ctg = 0;
    my($first_i, $last_i);
    my $cs_list = $ss->CloneSequence_list or die "No CloneSequence_list";
    for (my $i = 0; $i < @$cs_list; $i++) {
        my $id = $cs_list->[$i]->accession;
        if ($acc_in_list{$id}) {
            $first_i ||= $i;
            $last_i    = $i;
            delete($acc_in_list{$id});
        }
    }
    if (my @not_found = keys %acc_in_list) {
        warn "Failed to find accessions: ", join(', ', @not_found), "\n";
    }
    unless ($first_i) {
        die "Didn't find any of the accessions in SequenceSet";
    }
    return [ @$cs_list[$first_i .. $last_i] ];
}

sub accs_connected_to_genes {
    my( $dba, $gene_id_list ) = @_;
    
    my $gene_id_str = join(', ', @$gene_id_list);
    my $sth = $dba->prepare(qq{
        SELECT DISTINCT c.embl_acc
        FROM transcript t
          , exon_transcript et
          , exon e
          , contig g
          , clone c
        WHERE t.transcript_id = et.transcript_id
          AND et.exon_id = e.exon_id
          AND e.contig_id = g.contig_id
          AND g.clone_id = c.clone_id
          AND t.gene_id IN ($gene_id_str)
        });
    $sth->execute;
    
    my( @clone_acc );
    while (my ($acc) = $sth->fetchrow) {
        push(@clone_acc, $acc);
    }
    return @clone_acc;
}

sub clone_id_of_clone_with_greatest_sv_and_exons {
    my( $dbh, $acc ) = @_;
    
    my $sth = $dbh->prepare(q{
        SELECT c.clone_id
          , c.embl_version
        FROM clone c
          , contig g
          , exon e
        WHERE c.clone_id = g.clone_id
          AND g.contig_id = e.contig_id
          AND c.embl_acc = ?
        GROUP BY c.clone_id
        });
    $sth->execute($acc);
    
    my $prev_list = [];
    while (my ($clid, $sv) = $sth->fetchrow) {
        push(@$prev_list, [$clid, $sv]);
    }
    if (@$prev_list) {
        my ($first) = sort {$b->[1] <=> $a->[1]} @$prev_list;
        return $first->[0];
    } else {
        return;
    }
}

sub list_exonless_accessions {
    my( $dbh, $set_name ) = @_;
    
    my $sth = $dbh->prepare(q{
        SELECT c.embl_acc
          , c.embl_version
        FROM (clone c
          , contig g
          , assembly a)
        LEFT JOIN exon e
          ON g.contig_id = e.contig_id
        WHERE c.clone_id = g.clone_id
          AND g.contig_id = a.contig_id
          AND e.contig_id IS NULL
          AND a.type = ?
        GROUP BY c.clone_id
        });
    $sth->execute($set_name);
    
    my $acc_list = [];
    while (my ($acc, $sv) = $sth->fetchrow) {
        push(@$acc_list, [$acc, $sv]);
    }
    return $acc_list;
}

sub save_new_gene {
    my( $dba, $gene_aptr, $db_gene, $xml_gene, $slice ) = @_;

    my $broker = Bio::Otter::AnnotationBroker->new($dba);
    $broker->make_id_version_hash([$db_gene]);
    $broker->increment_versions_in_gene($xml_gene);
    $gene_aptr->attach_to_Slice($xml_gene, $slice);

    eval {
        $dba->begin_work;
        $xml_gene->detach_DBAdaptors;
        $gene_aptr->store($xml_gene);
        $dba->commit;
    };
    if ($@) {
        $dba->rollback;
        warn "Error saving remapped gene: $@";
    }
}

sub hum_seq_from_contig {
    my( $ctg ) = @_;

    my $seq = Hum::Sequence::DNA->new;
    $seq->sequence_string($ctg->seq);
    $seq->name($ctg->name);
    return $seq;
}

sub hum_seq_from_exon {
    my( $exon ) = @_;
    
    my $seq = Hum::Sequence::DNA->new;
    $seq->sequence_string($exon->seq->seq);
    $seq->name($exon->stable_id);
    return $seq;
}

sub remap_ens_Exons {
    my( $finder, $exons, $dest_ctg ) = @_;

    # Make a Hum::Sequence object for each exon
    my $exon_seq = [];
    for (my $i = 0; $i < @$exons; $i++) {
        push(@$exon_seq, hum_seq_from_exon($exons->[$i]));
    }

    # Find the exons (with cross_match)
    my $fs = $finder->find_best_Feature_set($exon_seq);
    
    # Give Exons new coords
    my $sub_strand = undef;
    my $all_found = 1;
    for (my $i = 0; $i < @$exons; $i++) {
        my $exon  = $exons->[$i];
        my $name  = $exon->stable_id;
        my $e_len = $exon->length;
        if (my $feat = $fs->[$i]) {
            my $start  = $feat->seq_start;
            my $end    = $feat->seq_end;
            my $strand = $feat->seq_strand;
            my $h_len  = $feat->seq_length;

            if ($sub_strand and $strand != $sub_strand) {
                # Should trap this in ExonLocator
                warn "Exons on different strands from same feature set\n";
            } else {
                $sub_strand = $strand;
            }

            if ($h_len != $e_len) {
                printf STDERR "Incomplete ($h_len of $e_len) to %10s %d %d %d\n",
                    $name, $start, $end, $strand;
            }
            else {
                printf STDERR "Found %10s %d %d %d\n",
                    $name, $start, $end, $strand;
            }
            $exon->start($start);
            $exon->end($end);
            $exon->strand($strand);
            $exon->contig($dest_ctg);
        } else {
            printf STDERR "Failed to find %d bp exon '%s'\n",
                $exon->length,
                $exon->stable_id;
            $all_found = 0;
        }
    }
    return $all_found;
}


__END__

=head1 NAME - realign_missing_genes

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

