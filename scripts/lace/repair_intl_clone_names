#!/usr/local/bin/perl -w

use strict;
use Carp;
use Getopt::Long 'GetOptions';
use Hum::Tracking;
use Bio::Otter::Lace::PipelineDB;
use Bio::Otter::Lace::Defaults;

sub get_attrib_id_by_name {
    my ($pipe_db, $name) = @_;

    my $query = $pipe_db->prepare(qq{
        SELECT attrib_type_id FROM attrib_type WHERE code = '$name'
    });
    $query->execute;
    return $query->fetchrow;
}

{
    my $dataset_name = undef;
    my $all_flag    = 0;    # Re-scan the names even if they are already in the database
    my $head_flag   = 0;    # Whether it is a new or old schema database
    my $otter_flag  = 0;    # Whether we should patch the otter database itself
    my $change_flag = 0;    # Whether we should change or just show the stats
    Bio::Otter::Lace::Defaults::do_getopt(
					  'dataset=s'   => \$dataset_name,
					  'all!'        => \$all_flag,
                      'head!'       => \$head_flag,
                      'otter!'      => \$otter_flag,
                      'change!'     => \$change_flag,
					  ) || die "No arguments - don't know what to do";
    die "I need a dataset name, is that too much to ask?\n" unless $dataset_name;
    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);
    # Make a connection to the otter database

    my ($intl_attrib, $acc_attrib, $op_update_pipe_query,
        $np_select_srid_and_old_by_acc, $np_insert_pipe_query, $np_update_pipe_query,
        $pipe_db, $pipedb_options);

    my $otter_db = $ds->get_cached_DBAdaptor;

    if($otter_flag) {
        $pipe_db = $otter_db;
    } else {
        my $pipekey = $head_flag ? 'pipeline_db_rw_head' : 'pipeline_db_rw';

        ($pipe_db, $pipedb_options) =
            Bio::Otter::Lace::SatelliteDB::_get_DBAdaptor_and_options(
                $otter_db,
                $pipekey,
        );
    }

    if($head_flag) {
        $intl_attrib = get_attrib_id_by_name($pipe_db, 'intl_clone_name');
        $acc_attrib  = get_attrib_id_by_name($pipe_db, 'embl_accession');
    }

        # find the clones that need their international name to be updated:
    my $clones_acc_query = $pipe_db->prepare(
      $head_flag
    ? qq{
        SELECT a_acc.value, a_ver.value, a_icn.value
        FROM seq_region s,
	     seq_region_attrib a_acc,
	     seq_region_attrib a_ver
        LEFT JOIN seq_region_attrib a_icn
          ON  s.seq_region_id = a_icn.seq_region_id
         AND  a_icn.attrib_type_id = $intl_attrib
        WHERE s.coord_system_id = (SELECT coord_system_id FROM coord_system WHERE name = 'clone')
        }.( $all_flag
            ? ''
            : ' AND a_icn.value is NULL '
        ).qq{
          AND s.seq_region_id = a_acc.seq_region_id
          AND a_acc.attrib_type_id = $acc_attrib
          AND s.seq_region_id = a_ver.seq_region_id
          AND a_ver.attrib_type_id = (SELECT attrib_type_id FROM attrib_type WHERE code = 'embl_version')
        }
    : qq{
        SELECT embl_acc, embl_version, name
        FROM clone
        }.( $all_flag
            ? ''
            : " WHERE name = concat(embl_acc, '.', embl_version) "
        )
    );
    $clones_acc_query->execute;


    if($head_flag) {
            # find srid and old value via accession only:
        $np_select_srid_and_old_by_acc = $pipe_db->prepare(qq{
            SELECT a_acc.seq_region_id, a_icn.value
            FROM seq_region_attrib a_acc
            LEFT JOIN seq_region_attrib a_icn
              ON  a_acc.seq_region_id = a_icn.seq_region_id
             AND  a_icn.attrib_type_id = $intl_attrib
            WHERE a_acc.attrib_type_id = $acc_attrib
              AND a_acc.value = ?
        });

            # insert a *new* intl_clone_name in the new schema (one by one):
        $np_insert_pipe_query = $pipe_db->prepare(qq{
            INSERT INTO seq_region_attrib
            (value, seq_region_id, attrib_type_id)
            VALUES (?, ?, $intl_attrib)
        });

            # update an intl_clone_name in the new schema
        $np_update_pipe_query = $pipe_db->prepare(qq{
            UPDATE seq_region_attrib
            SET value = ?
            WHERE seq_region_id = ?
              AND attrib_type_id = $intl_attrib
        });
    } else {
        $op_update_pipe_query = $pipe_db->prepare(q{
            UPDATE clone
            SET name = ?
            WHERE embl_acc = ?
              AND embl_version = ?
        });
    }
    

        # the actual update loop:
    my $scanned_count = 0;
    my $done_count    = 0;
    my $diff_changed_count = 0;
    my $diff_chback_count  = 0;

    while (my ($acc, $ver, $old_intl) = $clones_acc_query->fetchrow) {
        $old_intl ||= '';
        my $new_intl = get_international_clone_name($acc) || '';

        $scanned_count++;

        my $changed_delim = '....';

        if( ($new_intl ne $old_intl) && ($head_flag || $new_intl) ) {

                # some stats about the discrepancy:
            if($new_intl) {
                $diff_changed_count++;
            } elsif($old_intl=~/^\w+\-\w+/) {
                $diff_chback_count++;
            }

            if($change_flag) { # be a man, change the world!
                if($head_flag) {
                    $np_select_srid_and_old_by_acc->execute($acc);
                    while (my ($srid, $old) = $np_select_srid_and_old_by_acc->fetchrow) {
                        if($old) {
                            $np_update_pipe_query->execute($new_intl, $srid) || die $np_update_pipe_query->errstr;
                        } else {
                            $np_insert_pipe_query->execute($new_intl, $srid) || die $np_insert_pipe_query->errstr;
                        }
                        $done_count++;
                    }
                } else {
                    $op_update_pipe_query->execute($new_intl, $acc, $ver);
                    $done_count++;
                }
                $changed_delim = '--->';
            }
        }
        $old_intl ||= '(unknown)';
        $new_intl ||= '(unknown)';
        print "$scanned_count:\t$acc.$ver\t$old_intl $changed_delim $new_intl\n";
    }

    print STDERR "\n---------- Summary: ----------\n";
    print STDERR "$scanned_count clones were scanned\n";
    print STDERR "$diff_changed_count clones were found to have new names in ORACLE db\n";
    if($all_flag) {
        print STDERR "$diff_chback_count clones' names were found to have disappeared from ORACLE db\n";
    }
    print STDERR "$done_count names were actually changed\n";
}


{
    my( $sth );

    sub get_international_clone_name {
        my( $acc ) = @_;

        $sth ||= Hum::Tracking::prepare_track_statement(q{
            SELECT c.clonename
              , l.internal_prefix
              , l.external_prefix
            FROM sequence s
              , clone_sequence cs
              , clone c
              , library l
            WHERE s.id_sequence = cs.id_sequence
              AND cs.clonename = c.clonename
              AND c.libraryname = l.libraryname
              AND s.accession = ?
              AND cs.is_current = 1
            });
        $sth->execute($acc);
        
        my ($clone, $int_pre, $ext_pre) = $sth->fetchrow;
        $sth->finish;
        
        return unless $clone;
        
        my $intl = uc $clone;
        $int_pre ||= '';
        $ext_pre ||= 'XX';
        if ($ext_pre =~ /^XX/) {
            $intl = "$ext_pre-$intl";
        } else {
            if (substr($intl, 0, length($int_pre)) eq uc $int_pre) {
                substr($intl, 0, length($int_pre)) = "$ext_pre-";
            } else {
                warn "clone '$clone' does not begin with internal prefix '$int_pre'";
                $intl = "$ext_pre-$intl";
            }
        }
        return $intl;
    }
}

__END__

=head1 NAME - repair_intl_clone_names

=head1 SYNOPSIS

  repair_intl_clone_names -dataset <DATASET_NAME> [ -otter | -head ]

=head DESCRIPTION

Fills in the international clone names for EITHER
otter database itself (use with -otter) OR
old schema pipeline database (default behaviour) OR
new schema pipeline database (use with -head).

It uses the tracking database to find the int. clone name
for those clones  that have name = embl_acc.embl_version. 
Connection details come from $OTTER_HOME/.otter_config or
~/.otter_config or command line in a similar manner
to the rest of the scripts in this directory.

=head1 USAGE

Just give it a dataset name that occurs in the db
you want to "fix". eg: "human" or "zebrafish"

=head1 AUTHORS

James Gilbert B<email> jgrg@sanger.ac.uk (original code)

Leo Gordon B<email> lg4@sanger.ac.uk (adaptation for the new schema)

