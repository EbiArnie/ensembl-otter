#!/usr/local/bin/perl -w

use strict;
use Carp;
use Getopt::Long 'GetOptions';
use Hum::Tracking;
use Bio::Otter::Lace::PipelineDB;
use Bio::Otter::Lace::Defaults;

{
    my $dataset_name = undef;
    my $which_db    = 'all'; # possible values: 'otter', 'oldpipe', 'newpipe', 'all'
    my $rescan_flag = 0;     # Re-scan the names even if they are already in the database
    my $change_flag = 0;     # Whether we should change or just show the stats
    Bio::Otter::Lace::Defaults::do_getopt(
					  'dataset=s'   => \$dataset_name,
                      'which=s'     => \$which_db,
					  'rescan!'     => \$rescan_flag,
                      'change!'     => \$change_flag,
					  ) || die "No arguments - don't know what to do";

    my $cl = Bio::Otter::Lace::Defaults::make_Client();

    my @datasets;

    if($dataset_name) {
        push @datasets, $cl->get_DataSet_by_name($dataset_name);
    } else {
        @datasets = $cl->get_all_DataSets();
    }

    for my $ds (@datasets) {

        $dataset_name = $ds->name();
        
        print STDERR "\n=================== $dataset_name ===============\n";

        # Make a connection to the otter database
        my $otter_db = $ds->get_cached_DBAdaptor;

        if(($which_db eq 'otter')
         ||($which_db eq 'all') ) {
            repair_one_db($otter_db, 0, $rescan_flag, $change_flag, $dataset_name, 'otter');
        }

        if(($which_db eq 'oldpipe')
         ||($which_db eq 'all') ) {

            my ($oldpipe_db, $oldpipedb_options) =
                Bio::Otter::Lace::SatelliteDB::_get_DBAdaptor_and_options(
                    $otter_db,
                    'pipeline_db_rw',
            );
            repair_one_db($oldpipe_db, 0, $rescan_flag, $change_flag, $dataset_name, 'oldpipe');
        }

        if(($which_db eq 'newpipe')
         ||($which_db eq 'all') ) {

            my ($newpipe_db, $newpipedb_options) =
                Bio::Otter::Lace::SatelliteDB::_get_DBAdaptor_and_options(
                    $otter_db,
                    'pipeline_db_rw_head',
            );
            repair_one_db($newpipe_db, 1, $rescan_flag, $change_flag, $dataset_name, 'newpipe');
        }
    }
}

# --------------------------------- main() ends here -----------------

sub get_attrib_id_by_name {
    my ($dbh, $name) = @_;

    my $query = $dbh->prepare(qq{
        SELECT attrib_type_id FROM attrib_type WHERE code = '$name'
    });
    $query->execute;
    return $query->fetchrow;
}

sub repair_one_db {

    my ($dbh, $head_flag, $rescan_flag, $change_flag, $dataset_name, $which_db) = @_;

    if(! $dbh) {
        print STDERR "\n***** '$which_db' database of '$dataset_name' species does not seem to exist\n";
        return;
    }

    print STDERR "\n***** Reparing '$which_db' database of '$dataset_name' species:\n";

    my ($intl_attrib, $acc_attrib, $op_update_pipe_query,
        $np_select_srid_and_old_by_acc, $np_insert_pipe_query, $np_update_pipe_query);

    if($head_flag) {
        $intl_attrib = get_attrib_id_by_name($dbh, 'intl_clone_name') || die "'intl_clone_name' attrib not defined";
        $acc_attrib  = get_attrib_id_by_name($dbh, 'embl_acc') || die "'embl_acc' attrib not defined";
    }

        # find the clones that need their international name to be updated:
    my $clones_acc_query = $dbh->prepare(
      $head_flag
    ? qq{
        SELECT a_acc.value, a_ver.value, a_icn.value
        FROM seq_region s,
	     seq_region_attrib a_acc,
	     seq_region_attrib a_ver
        LEFT JOIN seq_region_attrib a_icn
          ON  s.seq_region_id = a_icn.seq_region_id
         AND  a_icn.attrib_type_id = $intl_attrib
        WHERE s.coord_system_id = (SELECT coord_system_id FROM coord_system WHERE name = 'clone')
        }.( $rescan_flag
            ? ''
            : ' AND a_icn.value is NULL '
        ).qq{
          AND s.seq_region_id = a_acc.seq_region_id
          AND a_acc.attrib_type_id = $acc_attrib
          AND s.seq_region_id = a_ver.seq_region_id
          AND a_ver.attrib_type_id = (SELECT attrib_type_id FROM attrib_type WHERE code = 'embl_version')
        }
    : qq{
        SELECT embl_acc, embl_version, name
        FROM clone
        }.( $rescan_flag
            ? ''
            : " WHERE name = concat(embl_acc, '.', embl_version) "
        )
    );
    $clones_acc_query->execute;


    if($head_flag) {
            # find srid and old value via accession only:
        $np_select_srid_and_old_by_acc = $dbh->prepare(qq{
            SELECT a_acc.seq_region_id, a_icn.value
            FROM seq_region_attrib a_acc
            LEFT JOIN seq_region_attrib a_icn
              ON  a_acc.seq_region_id = a_icn.seq_region_id
             AND  a_icn.attrib_type_id = $intl_attrib
            WHERE a_acc.attrib_type_id = $acc_attrib
              AND a_acc.value = ?
        });

            # insert a *new* intl_clone_name in the new schema (one by one):
        $np_insert_pipe_query = $dbh->prepare(qq{
            INSERT INTO seq_region_attrib
            (value, seq_region_id, attrib_type_id)
            VALUES (?, ?, $intl_attrib)
        });

            # update an intl_clone_name in the new schema
        $np_update_pipe_query = $dbh->prepare(qq{
            UPDATE seq_region_attrib
            SET value = ?
            WHERE seq_region_id = ?
              AND attrib_type_id = $intl_attrib
        });
    } else {
        $op_update_pipe_query = $dbh->prepare(q{
            UPDATE clone
            SET name = ?
            WHERE embl_acc = ?
              AND embl_version = ?
        });
    }
    

        # the actual update loop:
    my $scanned_count = 0;
    my $done_count    = 0;
    my $diff_changed_count = 0;
    my $diff_chback_count  = 0;

    while (my ($acc, $ver, $old_intl) = $clones_acc_query->fetchrow) {
        $old_intl ||= '';
        my $new_intl = get_international_clone_name($acc) || '';

        $scanned_count++;

        my $changed_delim = '....';

        if( ($new_intl ne $old_intl) && ($head_flag || $new_intl) ) {

                # some stats about the discrepancy:
            if($new_intl) {
                $diff_changed_count++;
            } elsif($old_intl=~/^\w+\-\w+/) {
                $diff_chback_count++;
            }

            if($change_flag) { # be a man, change the world!
                if($head_flag) {
                    $np_select_srid_and_old_by_acc->execute($acc);
                    while (my ($srid, $old) = $np_select_srid_and_old_by_acc->fetchrow) {
                        if($old) {
                            $np_update_pipe_query->execute($new_intl, $srid) || die $np_update_pipe_query->errstr;
                        } else {
                            $np_insert_pipe_query->execute($new_intl, $srid) || die $np_insert_pipe_query->errstr;
                        }
                        $done_count++;
                    }
                } else {
                    $op_update_pipe_query->execute($new_intl, $acc, $ver);
                    $done_count++;
                }
                $changed_delim = '--->';
            }
            $old_intl ||= '(unknown)';
            $new_intl ||= '(unknown)';
            print STDERR "\t$acc.$ver\t$old_intl $changed_delim $new_intl\n";
        }
    }

    print STDERR "\n***** Summary ('$which_db' of '$dataset_name' species) :\n";
    print STDERR "$scanned_count clones were scanned\n";
    print STDERR "$diff_changed_count clones were found to have new names in ORACLE db\n";
    if($rescan_flag) {
        print STDERR "$diff_chback_count clones' names were found to have disappeared from ORACLE db\n";
    }
    print STDERR "$done_count names were actually changed\n";
}


{
    my( $sth );

    sub get_international_clone_name {
        my( $acc ) = @_;

        $sth ||= Hum::Tracking::prepare_track_statement(q{
            SELECT c.clonename
              , l.internal_prefix
              , l.external_prefix
            FROM sequence s
              , clone_sequence cs
              , clone c
              , library l
            WHERE s.id_sequence = cs.id_sequence
              AND cs.clonename = c.clonename
              AND c.libraryname = l.libraryname
              AND s.accession = ?
              AND cs.is_current = 1
            });
        $sth->execute($acc);
        
        my ($clone, $int_pre, $ext_pre) = $sth->fetchrow;
        $sth->finish;
        
        return unless $clone;
        
        my $intl = uc $clone;
        $int_pre ||= '';
        $ext_pre ||= 'XX';
        if ($ext_pre =~ /^XX/) {
            $intl = "$ext_pre-$intl";
        } else {
            if (substr($intl, 0, length($int_pre)) eq uc $int_pre) {
                substr($intl, 0, length($int_pre)) = "$ext_pre-";
            } else {
                warn "clone '$clone' does not begin with internal prefix '$int_pre'";
                $intl = "$ext_pre-$intl";
            }
        }
        return $intl;
    }
}

__END__

=head1 NAME - repair_intl_clone_names

=head1 SYNOPSIS

  repair_intl_clone_names -dataset <DATASET_NAME> [ -otter | -head ]

=head DESCRIPTION

Fills in the international clone names for EITHER
otter database itself (use with -otter) OR
old schema pipeline database (default behaviour) OR
new schema pipeline database (use with -head).

It uses the tracking database to find the int. clone name
for those clones  that have name = embl_acc.embl_version. 
Connection details come from $OTTER_HOME/.otter_config or
~/.otter_config or command line in a similar manner
to the rest of the scripts in this directory.

=head1 USAGE

Just give it a dataset name that occurs in the db
you want to "fix". eg: "human" or "zebrafish"

=head1 AUTHORS

James Gilbert B<email> jgrg@sanger.ac.uk (original code)

Leo Gordon B<email> lg4@sanger.ac.uk (adaptation for the new schema)

