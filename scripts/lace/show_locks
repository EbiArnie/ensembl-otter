#!/usr/bin/env perl

use warnings;


### show_locks

use strict;
use Getopt::Long 'GetOptions';
use Bio::Otter::Lace::Defaults;
use Bio::Otter::Lace::PipelineDB;

$| = 1;

{
    
    my $usage     = sub { exec('perldoc', $0) };
    my $dataset_name = undef;
    my $author    = undef;
    my $assembly  = undef;
    my $hostname  = undef;
    my $do_delete = 0;
    my @lock_id_range = ();
    my $range_parser = sub{
        my( $start, $end ) = $_[1] =~ /(\d+)(?:[^\d+](\d+))?/;
        if ($start and ! $end) {
            $end = $start;
        }
        if ($start and $end and $start <= $end) {
            @lock_id_range = ($start, $end);
        } else {
            $usage->();
        }
    };
    Bio::Otter::Lace::Defaults::do_getopt(
        'h|help!'       => $usage,
        'dataset=s'     => \$dataset_name,
        'annotator=s'   => \$author,
        'set=s'         => \$assembly,
        'machine=s'     => \$hostname,
        'delete!'       => \$do_delete,
        'range=s'       => $range_parser,
        ) or $usage->();
    $usage->() unless $dataset_name;

    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);
    my $otter_db = $ds->make_EnsEMBL_DBAdaptor;

    my $sql = q{
        SELECT l.clone_lock_id
          , l.hostname
          , au.author_name
          , c.name
          , c.embl_acc
          , a.type
        FROM author au
          , clone_lock l
          , clone c
          , contig g
          , assembly a
          , sequence_set ss
        WHERE au.author_id = l.author_id
          AND l.clone_id = c.clone_id
          AND c.clone_id = g.clone_id
          AND g.contig_id = a.contig_id
          AND a.type = ss.assembly_type
          AND ss.hide = 'N'
        };
    my( @param );
    if ($author) {
        $sql .= ' AND au.author_name = ? ';
        push(@param, $author);
    }
    if ($assembly) {
        $sql .= ' AND a.type = ? ';
        push(@param, $assembly);
    }
    if ($hostname) {
        $sql .= ' AND l.hostname = ? ';
        push(@param, $hostname);
    }
    if (@lock_id_range) {
        $sql .= ' AND l.clone_lock_id BETWEEN ? AND ? ';
        push(@param, @lock_id_range);
    }
    $sql .= ' ORDER BY l.clone_lock_id ASC ';
    my $sth = $otter_db->prepare($sql);
    $sth->execute(@param);
    
    my( %lock_id );
    while (my @row = $sth->fetchrow) {
        my ($lid, $host, $author, $clone, $acc, $type) = @row;
        if (my $info = $lock_id{$lid}) {
            push(@$info, $type);
        } else {
            $lock_id{$lid} = [$host, $author, $clone, $acc, $type];
        }
    }
    
    foreach my $lid (sort {$a <=> $b} keys %lock_id) {
        my $info = $lock_id{$lid};
        
        my $host   = shift @$info;
        my $author = shift @$info;
        my $clone  = shift @$info;
        my $acc    = shift @$info;
        my @type   = sort  @$info;
        
        printf  "  %6d  %12s  %-7s  %-12s  %-10s  %s\n",
            $lid, $host, $author, $clone, $acc, join(' ', @type);
    }
    if ($do_delete and scalar keys %lock_id) {
        print STDERR "Delete all these locks? [y|N] ";
        my $ans = <STDIN>;
        if ($ans =~ /^y/i) {
            my $del_sth = $otter_db->prepare(q{
                DELETE FROM clone_lock
                WHERE clone_lock_id = ?
                });
            my $count = 0;
            foreach my $lid (sort {$a <=> $b} keys %lock_id) {
                $del_sth->execute($lid);
                $count += $del_sth->rows;
            }
            print "Deleted $count locks\n";
        }
    }
}




__END__

=head1 NAME - show_locks

=head1 DESCRIPTION

Show and delete clone locks from an otter
database.  If locks need to be removed by hand
using this script it is because something has
gone wrong in the annotation system - which may
need to be fixed!

=head1 SYNOPSIS

  show_locks -dataset <DATASET_NAME> [-delete] [-annotator <UNAME>] \
    [-set <TYPE>] [-machine <HOSTNAME>] [-range <INT[-INT]>]

=head1 ARGUMENTS

=over 4

=item -dataset <DATASET_NAME>

The name of the dataset to search.  eg: B<human>

=item -delete

With this flag set, the script will show the list
of locks that match the search criteria followed
by a prompt which asks if all the locks in the
list should be deteleted.

=back

The rest of the arguments confine the list of
locks shown to:

=over 4

=item -set <TYPE>

Clones which are members of this sequence set. 
(Sequence sets are listed on the far right of the
output.)

=item -annotator <UNAME>

Those locked by this user name.

=item -machine <HOSTNAME>

Those that were locked from the named computer.

=item -range <INT[-INT]>

Those in this range (or this one if only one
number is given).  The two integers can be
separated by any non-integer non-whitespace
characers.

=back

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

