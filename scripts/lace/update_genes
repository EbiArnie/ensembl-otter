#!/usr/local/bin/perl -w

### update_genes

use strict;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotationBroker;

$| = 1;

{
  my( $dataset_name,
      $sequence_set,
      $chr_start_acc,
      $chr_end_acc,
      $gene_stable_id,
      );

  my $test_flag = 0;  # Don't write realigned genes to database
  my $test_file;
  my $merge;
  my $make_nmd;

  my $usage = sub { exec('perldoc', $0) };
  Bio::Otter::Lace::Defaults::do_getopt(
	'h|help!'               => $usage,
        'dataset=s'             => \$dataset_name,
        'chr|set=s'             => \$sequence_set,
        'start_acc=s'           => \$chr_start_acc,
        'end_acc=s'             => \$chr_end_acc,
	'gene_stable_id=s'      => \$gene_stable_id,
	'test!'                 => \$test_flag,
	'test_file:s'           => \$test_file,
	'merge'                 => \$merge,
        'make_nmd'              => \$make_nmd,

        ) or $usage->();
  $usage->() unless $dataset_name and $sequence_set;

  # Connect to Ensembl/Otter database and fetch adaptors
  my $client = Bio::Otter::Lace::Defaults::make_Client();
  my $dset = $client->get_DataSet_by_name($dataset_name);
  my $otter_db = $dset->get_cached_DBAdaptor;
  my $gene_aptr  = $otter_db->get_GeneAdaptor;
  my $slice_aptr = $otter_db->get_SliceAdaptor;

  $otter_db->assembly_type($sequence_set);
  my $ss = $dset->get_SequenceSet_by_name($sequence_set);
  $dset->selected_SequenceSet($ss);
  $dset->fetch_all_CloneSequences_for_SequenceSet($ss);

  # get a list of gene id's by various means
  my $gene_id_list;
  my $gene_merge;
  my $transcripts;
  if ($gene_stable_id) {
    my $gsi_list;
    my $n = 0;
    if (-e $gene_stable_id) {
      # 'gene_stable_id' is a file
      open(IN, $gene_stable_id) || die "cannot open $gene_stable_id";
      while (<IN>) {
	chomp;
	my @list=split(/\s+/,$_);
	my $first=shift @list;
	if(scalar(@list)){
	  $gene_merge->{$first}=[@list];
	}
	push(@$gsi_list,$first);
	$n++;
      }
      close(IN);
    }else{
      foreach my $gsi (split(/,/, $gene_stable_id)) {
	push(@$gsi_list,$gsi);
	$n++;
      }
    }
    print STDERR "checking $n gene_stable_ids only\n";
    foreach my $gsi (@$gsi_list){
      if ($gsi =~ /T\d+/) {
	my $g;
	eval{
	  $g=$gene_aptr->fetch_by_transcript_stable_id($gsi);
	};
	next if ($@ || !$g);
	# record transcript names for removal
	$transcripts->{$gsi}=1;
	if($gene_merge->{$gsi}){
	  foreach my $tsi (@{$gene_merge->{$gsi}}){
	    $transcripts->{$tsi}=1;
	  }
	}
	my $gsi2=$g->stable_id;
	print STDERR "$gsi -> $gsi2\n";
	$gsi=$gsi2;
      }
      eval{
	push(@$gene_id_list,
	     $gene_aptr->fetch_by_stable_id($gsi)->dbID);
      };
      next if ($@);
      $n++;
    }
  }elsif($sequence_set){
    if ($chr_start_acc or $chr_end_acc) {
      die sprintf(
		  "Need both start_acc (got '%s') and end_acc (got '%s')\n",
		  $chr_start_acc || 'NONE',
		  $chr_end_acc   || 'NONE',
		  )
	  unless $chr_start_acc
	  and $chr_end_acc;
      $ss->select_CloneSequences_by_start_end_accessions($chr_start_acc, $chr_end_acc);
    }else{
      $ss->selected_CloneSequences($ss->CloneSequence_list);
    }
    my ($chr, $chr_start, $chr_end) =
	$client->chr_start_end_from_contig($ss->selected_CloneSequences);
    my $slice =
	$slice_aptr->fetch_by_chr_start_end($chr, $chr_start, $chr_end);
    $gene_id_list = $gene_aptr->list_current_dbIDs_for_Slice($slice);
  }
  printf STDERR "Found %d current genes\n", scalar(@$gene_id_list);


  # loop over genes in list
  foreach my $gene_dbid (@$gene_id_list) {
    my $db_gene = $gene_aptr->fetch_by_dbID($gene_dbid);
    my $name=$db_gene->gene_info->name->name;
    my $stable_id=$db_gene->stable_id;
    if($db_gene->type eq 'obsolete'){
      print STDERR "$stable_id ($name) is obsolete - ignored\n";
      next;
    }

    # work out where this gene is/these genes are
    my $slice1;
    if($merge){
      my $err;
      ($err,$slice1)=&containing_slice($slice_aptr,
				       $stable_id,
				       @{$gene_merge->{$stable_id}});
      if($err){
	print STDERR "genes not all on same chromosome - ignored\n";
	next;
      }
    }else{
      $slice1=$slice_aptr->fetch_by_gene_stable_id($stable_id);
    }
    # assuming this is in correct order, can get first and last...
    my $acc_list = $gene_aptr->list_all_accessions_in_Slice($slice1);
    my $chr_start_acc=$acc_list->[0];
    my $chr_end_acc=$acc_list->[scalar(@$acc_list)-1];
    $ss->select_CloneSequences_by_start_end_accessions($chr_start_acc, 
						       $chr_end_acc);
    my ($chr, $chr_start, $chr_end) = $client->
	chr_start_end_from_contig($ss->selected_CloneSequences);
    my $slice = $slice_aptr->fetch_by_chr_start_end($chr, $chr_start, $chr_end);

    # test if gene is complete...probably not needed
    my $slice_gene = $db_gene->transform($slice);
    if(gene_is_truncated($slice_gene, $slice)) {
      print STDERR "Skipped offtrack gene '$name' ($stable_id)\n";
      next;
    }
    $slice_gene = undef;    # It has served its purpose

    # get ready for xml manipulation


    # action on gene:
    my $genes;
    if($merge){
      if(!$gene_merge->{$stable_id}){
	print STDERR "merge mode: no genes found to merge for $stable_id\n";
	next;
      }
      foreach my $m_gsi (@{$gene_merge->{$stable_id}}){

	# make original obsolete
	my $mo_gene=$gene_aptr->fetch_by_stable_id($m_gsi);
	# check if already obs
	if($mo_gene->type eq 'obsolete'){
	  my $name=$mo_gene->gene_info->name->name;
	  print STDERR "$m_gsi ($name) is obsolete - ignored\n";
	  next;
	}
	my $slice_gene = $mo_gene->transform($slice);
	$mo_gene->type('obsolete');
	push(@$genes,$mo_gene);

	# add transcripts of copy
	my $m_gene=$gene_aptr->fetch_by_stable_id($m_gsi);
	$slice_gene = $m_gene->transform($slice);
	foreach my $t (@{$m_gene->get_all_Transcripts}){
	  # fix transcript name
	  my $name=$t->transcript_info->name;
	  if($name=~/(.*)\-\d+(\-\d+)/){
	    my $nname=$1.$2;
	    $t->transcript_info->name($nname);
	    print "name changed from $name -> $nname\n";
	  }
	  $db_gene->add_Transcript($t);
	}
      }
      push(@$genes,$db_gene);
    }elsif($make_nmd){
      my $nrt=0;
      foreach my $t (@{$db_gene->get_all_Transcripts}){
	my $tsi=$t->stable_id;
	if($transcripts->{$tsi}){
	  $t->remove_translation;
	  $nrt++;
	}
      }
      if($nrt){
	push(@$genes,$db_gene);
      }else{
	print STDERR "make_nmd mode: no translations removed $stable_id\n";
	next;
      }
    }else{
      push(@$genes,$db_gene);
    }

    # stuff
    my $anal = $otter_db->get_AnalysisAdaptor->fetch_by_logic_name('otter');

    # Lock the slice so that we can safely write to it.
    my $lock_xml = $client->lock_region_for_contig_from_Dataset($ss->selected_CloneSequences, $dset);
    #my ($chr, $chr_start, $chr_end) = $client->chr_start_end_from_contig($ss->selected_CloneSequences);

    my $short_tiles = $slice->get_tiling_path;
        
    # otter > XML > otter

    my $temp = Bio::Otter::Lace::TempFile->new;
    $temp->name("update_genes.$$.xml");
    my $w_fh = $temp->write_file_handle;
    print $w_fh
	"<otter>\n<sequence_set>\n"
	, Bio::Otter::Converter::path_to_XML($chr, $chr_start, $chr_end, $sequence_set, $short_tiles);
    foreach my $gene (@$genes){
      print $w_fh $gene->toXMLString;
    }
    print $w_fh "</sequence_set>\n</otter>\n";
    my $r_fh = $temp->read_file_handle;
    if($test_file){
      open(OUT,">$test_file" || die "cannot open file");
      while(<$r_fh>){
	print OUT;
      }
      close(OUT);
    }else{
      my ($gene_list) = Bio::Otter::Converter::XML_to_otter($r_fh);
      foreach my $xml_gene (@$gene_list){
	my $ori_gene=shift @$genes;
	$xml_gene->analysis($anal);
	save_new_gene($otter_db, $gene_aptr, $ori_gene, $xml_gene, $slice, $test_flag);
      }
    }
    $client->unlock_otter_xml($lock_xml, $dset->name)
	if $lock_xml;
  }
}

sub save_new_gene {
    my( $otter_db, $gene_aptr, $db_gene, $xml_gene, $slice, $test_flag ) = @_;

    my $sida = $otter_db->get_StableIdAdaptor;
    $sida->fetch_new_stable_ids_for_Gene($xml_gene);

    my $broker = Bio::Otter::AnnotationBroker->new($otter_db);
    $broker->make_id_version_hash([$db_gene]);
    $broker->increment_versions_in_gene($xml_gene);
    $gene_aptr->attach_to_Slice($xml_gene, $slice);

    eval {
        $otter_db->begin_work;
        $xml_gene->detach_DBAdaptors;
        $gene_aptr->store($xml_gene);
    };
    if ($@) {
        $otter_db->rollback;
        warn "Error saving remapped gene: $@";
    }
    elsif ($test_flag) {
        warn "Test flag set - not saving\n";
        $otter_db->rollback;
    }
    else {
        $otter_db->commit;
    }
}

sub gene_is_truncated {
  my( $gene, $slice ) = @_;
  
  my $slice_length = $slice->length;
  foreach my $exon (@{$gene->get_all_Exons}) {
    if ($exon->contig != $slice or $exon->start < 1 or 
	$exon->end > $slice_length) {
      return 1;
    }
  }
  return 0;
}

sub containing_slice{
  my($slice_aptr,@gsi)=@_;
  my($chr,$st,$ed);
  foreach my $gsi (@gsi){
    my $slice=$slice_aptr->fetch_by_gene_stable_id($gsi);
    if($chr){
      if($slice->chr_name ne $chr){
	return 1;
      }else{
	my $st2=$slice->chr_start;
	my $ed2=$slice->chr_end;
	if($st2<$st){$st=$st2;}
	if($ed2>$ed){$ed=$ed2;}
	print "$chr:$st-$ed [$st2-$ed2]\n";
      }
    }else{
      $chr=$slice->chr_name;
      $st=$slice->chr_start;
      $ed=$slice->chr_end;
      print "$chr:$st-$ed\n";
    }
  }
  my $slice=$slice_aptr->fetch_by_chr_start_end($chr,$st,$ed);
  return 0,$slice
}


__END__

=head1 NAME - realign_offtrack_genes

=head1 SYNOPSIS

  realign_offtrack_genes -dataset <NAME> -set <NAME> -start_acc <ACCESSION> -end_acc <ACCESSION> -gene_stable_id <STABLE_ID>

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

=head2 Example from Liz

One for your 'greyed-out' list if you've got one
-  clone AL603882 has been put in chr1-07 
recently I think and contains evidence to extend
an existing locus, RP4-533D7.1, which is
unfortunately. greyed out - the objects
associated with RP4-533D7.1 continue all the way
down into AL358075/RP4-533D7 (481)).

Thanks very much 
Liz


  473  RP11-291L19   AL451136
  474  RP4-697E16    AL355480
  475  RP11-767N6    AL604028
GAP  50,000 bp
  476  XX-FW85598E4  BX664740

  477  RP11-630I5    AL603882
  478  RP11-397E14   AL772251
  479  RP11-735A5    AL603888
  480  RP11-386M16   AL645480
  481  RP4-533D7     AL358075
