#!/usr/local/bin/perl -w

### update_genes

use strict;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotationBroker;

$| = 1;

{
  my( $dataset_name,
      $sequence_set,
      $chr_start_acc,
      $chr_end_acc,
      $gene_stable_id,
      );

  my $test_flag = 0;  # Don't write realigned genes to database
  my $test_file;
  my $merge;
  my $make_nmd;
  my $rename;
  my $include_stop;

  my $usage = sub { exec('perldoc', $0) };
  Bio::Otter::Lace::Defaults::do_getopt(
	'h|help!'               => $usage,
        'dataset=s'             => \$dataset_name,
        'chr|set=s'             => \$sequence_set,
        'start_acc=s'           => \$chr_start_acc,
        'end_acc=s'             => \$chr_end_acc,
	'gene_stable_id=s'      => \$gene_stable_id,
	'test!'                 => \$test_flag,
	'test_file:s'           => \$test_file,
	'merge'                 => \$merge,
	'rename'                => \$rename,
        'make_nmd'              => \$make_nmd,
	'include_stop'          => \$include_stop,

        ) or $usage->();
  $usage->() unless $dataset_name and $sequence_set;

  # Connect to Ensembl/Otter database and fetch adaptors
  my $client = Bio::Otter::Lace::Defaults::make_Client();
  my $dset = $client->get_DataSet_by_name($dataset_name);
  my $otter_db = $dset->get_cached_DBAdaptor;
  my $gene_aptr  = $otter_db->get_GeneAdaptor;
  my $slice_aptr = $otter_db->get_SliceAdaptor;
  my $tc_aptr = $otter_db->get_TranscriptClassAdaptor;

  $otter_db->assembly_type($sequence_set);
  my $ss = $dset->get_SequenceSet_by_name($sequence_set);
  $dset->selected_SequenceSet($ss);
  $dset->fetch_all_CloneSequences_for_SequenceSet($ss);

  # get a list of gene id's by various means
  my $gene_id_list;
  my $gsi_associated_list;
  my $sids;
  if ($gene_stable_id) {
    my $gsi_list;
    my $n = 0;
    if (-e $gene_stable_id) {
      # 'gene_stable_id' is a file
      open(IN, $gene_stable_id) || die "cannot open $gene_stable_id";
      while (<IN>) {
	chomp;
	my @list=split(/\s+/,$_);
	my $first=shift @list;
	if(scalar(@list)){
	  $gsi_associated_list->{$first}=[@list];
	}
	push(@$gsi_list,$first);
	$n++;
      }
      close(IN);
    }else{
      foreach my $gsi (split(/,/, $gene_stable_id)) {
	push(@$gsi_list,$gsi);
	$n++;
      }

      # list of ids incompatible with various options that require parameters
      if($rename || $merge){
	print STDERR "-gene_stable_id requires file with ids and parameters\n";
	print STDERR "  for -rename or -merge options\n";
	exit 0;
      }

    }
    print STDERR "checking $n gene_stable_ids only\n";
    
    my %gsi2;
    foreach my $gsi (@$gsi_list){
      if ($gsi =~ /T\d+/) {
	my $g;
	eval{
	  $g=$gene_aptr->fetch_by_transcript_stable_id($gsi);
	};
	next if ($@ || !$g);
	# record original names, if conversion ok
	$sids->{$gsi}=1;
	my $gsi2=$g->stable_id;
	print STDERR "$gsi -> $gsi2\n";
	$gsi=$gsi2;
      }else{
	$sids->{$gsi}=1;
      }
      # ensure that if list of transcripts, don't end up with same gene
      # twice (would result in multiple edits)
      if($gsi2{$gsi}){
	print STDERR "$gsi duplicate in list\n";
	next;
      }else{
	$gsi2{$gsi}=1;
      }
      eval{
	push(@$gene_id_list,
	     $gene_aptr->fetch_by_stable_id($gsi)->dbID);
      };
      next if ($@);
      $n++;
    }
  }elsif($sequence_set){
    if ($chr_start_acc or $chr_end_acc) {
      die sprintf(
		  "Need both start_acc (got '%s') and end_acc (got '%s')\n",
		  $chr_start_acc || 'NONE',
		  $chr_end_acc   || 'NONE',
		  )
	  unless $chr_start_acc
	  and $chr_end_acc;
      $ss->select_CloneSequences_by_start_end_accessions($chr_start_acc, $chr_end_acc);
    }else{
      $ss->selected_CloneSequences($ss->CloneSequence_list);
    }
    my ($chr, $chr_start, $chr_end) =
	$client->chr_start_end_from_contig($ss->selected_CloneSequences);
    my $slice =
	$slice_aptr->fetch_by_chr_start_end($chr, $chr_start, $chr_end);
    $gene_id_list = $gene_aptr->list_current_dbIDs_for_Slice($slice);
  }
  printf STDERR "Found %d current genes\n", scalar(@$gene_id_list);

  # loop over genes in list
  foreach my $gene_dbid (@$gene_id_list) {
    my $db_gene = $gene_aptr->fetch_by_dbID($gene_dbid);
    my $name=$db_gene->gene_info->name->name;
    my $stable_id=$db_gene->stable_id;
    if($db_gene->type eq 'obsolete'){
      print STDERR "$stable_id ($name) is obsolete - ignored\n";
      next;
    }

    # work out where this gene is/these genes are:
    # special case for -merge, as there are multiple genes involved
    my $slice1;
    if($merge){

      # build appropriate gene list
      my $genes;
      if($merge){
	push(@$genes,$stable_id,@{$gsi_associated_list->{$stable_id}});
      }

      # get slice that covers all genes, checking on same chr
      my $err;
      ($err,$slice1)=&containing_slice($slice_aptr,@$genes);
      if($err){
	print STDERR "genes not all on same chromosome - ignored\n";
	next;
      }

    }else{
      $slice1=$slice_aptr->fetch_by_gene_stable_id($stable_id);
    }

    # assuming this is in correct order, can get first and last...
    my $acc_list = $gene_aptr->list_all_accessions_in_Slice($slice1);
    my $chr_start_acc=$acc_list->[0];
    my $chr_end_acc=$acc_list->[scalar(@$acc_list)-1];
    $ss->select_CloneSequences_by_start_end_accessions($chr_start_acc, 
						       $chr_end_acc);
    my ($chr, $chr_start, $chr_end) = $client->
	chr_start_end_from_contig($ss->selected_CloneSequences);
    my $slice = $slice_aptr->fetch_by_chr_start_end($chr, $chr_start, $chr_end);

    # test if gene is complete...probably not needed
    my $slice_gene = $db_gene->transform($slice);
    if(gene_is_truncated($slice_gene, $slice)) {
      print STDERR "Skipped offtrack gene '$name' ($stable_id)\n";
      next;
    }
    $slice_gene = undef;    # It has served its purpose

    # action on gene:
    my $genes;
    if($include_stop){

      # some transcripts are annotated 3 bp short, missing stop codon.
      # This option checks all transcripts and extends last exon of
      # translation if possible.

      my $flag=0;
      foreach my $t (@{$db_gene->get_all_Transcripts}){
	my $tsi=$t->stable_id;
	if($sids->{$tsi}){

	  # check substitution is possible/sensible
	  my $mrna=$t->seq->seq;
	  my $cdna=$t->translateable_seq;
	  $cdna=~s/^N+//;
	  my $utr5='';
	  my $utr3='';
	  if($mrna=~/(.*)$cdna(.*)/){
	    $utr5=$1;
	    $utr3=$2;
	  }else{
	    # should never get this error
	    print "ERROR: $tsi: cDNA not found in mRNA: $cdna, $mrna\n";
	    next;
	  }
	  if($cdna=~/(TAG|TGA|TAA)$/){
	    print "WARN: $tsi: translation already ends in valid stop - skipped\n";
	    next;
	  }elsif($utr3=~/^(TAG|TGA|TAA)/){
	    # ok - stop after current
	  }else{
	    print "WARN: $tsi: 3bp after translation end not a valid stop - skipped\n";
	    next;
	  }
	  
	  # make substitution - (some wierd situations not curently handeled)
	  my $tl=$t->translation;
	  my $ee=$tl->end_Exon;
	  my $eest=$ee->start;
	  my $eeed=$ee->end;
	  my $elen=$eeed-$eest+1;
	  my $tleee=$tl->end;
	  $tleee+=3;
	  if($tleee>$elen){
	    print STDERR "extending length of exon impossible: $tleee > $elen\n";
	  }else{
	    $tl->end($tleee);
	    $flag=1;
	  }
	}
      }
      if($flag){
	print STDERR "$gene_stable_id translation modified to include stop\n";
	push(@$genes,$db_gene);
      }else{
	print STDERR "failed to modify translation for $gene_stable_id\n";
      }

    }elsif($rename){

      # rename a gene or transcript

      my $oldname;
      my $newname;
      my $flag=0;
      if($sids->{$stable_id}){
	# target is gene
	if(!$gsi_associated_list->{$stable_id}){
	  print STDERR "rename mode: no replacement name found for $stable_id\n";
	  next;
	}
	($newname)=@{$gsi_associated_list->{$stable_id}};
	$oldname=$db_gene->gene_info->name->name;
	$db_gene->gene_info->name->name($newname);
	$db_gene->gene_info->synonym( new Bio::Otter::GeneSynonym(-name => $oldname) );
	my $rem="Annotation_remark- Name updated from $oldname to $newname";
	$db_gene->gene_info->remark( new Bio::Otter::GeneRemark(-remark => $rem) );
	$flag=1;
      }else{
	# target is transcript
	foreach my $t (@{$db_gene->get_all_Transcripts}){
	  # fix transcript name
	  my $tsi=$t->stable_id;
	  if($sids->{$tsi}){
	    if(!$gsi_associated_list->{$tsi}){
	      print STDERR "rename mode: no replacement name found for $tsi\n";
	      next;
	    }
	    ($newname)=@{$gsi_associated_list->{$tsi}};
	    $oldname=$t->transcript_info->name;
	    $t->transcript_info->name($newname);
	    $flag=1;
	  }
	}
      }
      if($flag){
	print STDERR "$gene_stable_id renamed from $oldname -> $newname\n";
	push(@$genes,$db_gene);
      }

    }elsif($merge){

      # for each gsi in list, merge any other gsi's on same line
      # (create an obs gene for each, then add transcripts to first gene)

      if(!$gsi_associated_list->{$stable_id}){
	print STDERR "merge mode: no genes found to merge for $stable_id\n";
	next;
      }
      foreach my $m_gsi (@{$gsi_associated_list->{$stable_id}}){

	# make original obsolete
	my $mo_gene=$gene_aptr->fetch_by_stable_id($m_gsi);
	# check if already obs
	if($mo_gene->type eq 'obsolete'){
	  my $name=$mo_gene->gene_info->name->name;
	  print STDERR "$m_gsi ($name) is obsolete - ignored\n";
	  next;
	}
	my $slice_gene = $mo_gene->transform($slice);
	$mo_gene->type('obsolete');
	push(@$genes,$mo_gene);

	# add transcripts of copy
	my $m_gene=$gene_aptr->fetch_by_stable_id($m_gsi);
	$slice_gene = $m_gene->transform($slice);
	foreach my $t (@{$m_gene->get_all_Transcripts}){
	  # fix transcript name
	  my $name=$t->transcript_info->name;
	  if($name=~/(.*)\-\d+(\-\d+)/){
	    my $nname=$1.$2;
	    $t->transcript_info->name($nname);
	    print "name changed from $name -> $nname\n";
	  }
	  $db_gene->add_Transcript($t);
	}
      }
      push(@$genes,$db_gene);

    }elsif($make_nmd){

      # orginal list should be transcripts
      # loop over list and remove transcripts and label as NMD

      my $nrt=0;
      foreach my $t (@{$db_gene->get_all_Transcripts}){
	my $tsi=$t->stable_id;
	if($sids->{$tsi}){
	  $t->remove_translation;
	  # add remark
	  my $rem="Annotation_remark- Translation removed and type set to NMD";
	  $t->transcript_info->remark( new Bio::Otter::TranscriptRemark(-remark => $rem) );
	  # change class
	  my $tc=$tc_aptr->fetch_by_name("Nonsense_mediated_decay");
	  $t->transcript_info->class($tc);
	  $nrt++;
	}
      }
      if($nrt){
	push(@$genes,$db_gene);
      }else{
	print STDERR "ERR: make_nmd mode: no translations removed for $stable_id\n";
	next;
      }
    }else{
      push(@$genes,$db_gene);
    }

    # stuff
    my $anal = $otter_db->get_AnalysisAdaptor->fetch_by_logic_name('otter');

    # Lock the slice so that we can safely write to it.
    my $lock_xml;
    eval{
      $lock_xml=$client->lock_region_for_contig_from_Dataset($ss->selected_CloneSequences, $dset);
    };
    if($@){
      print STDERR "WARN: Failed to lock region for $stable_id - next\n";
    }
    #my ($chr, $chr_start, $chr_end) = $client->chr_start_end_from_contig($ss->selected_CloneSequences);

    my $short_tiles = $slice->get_tiling_path;
        
    # otter > XML > otter

    my $temp = Bio::Otter::Lace::TempFile->new;
    $temp->name("update_genes.$$.xml");
    my $w_fh = $temp->write_file_handle;
    print $w_fh
	"<otter>\n<sequence_set>\n"
	, Bio::Otter::Converter::path_to_XML($chr, $chr_start, $chr_end, $sequence_set, $short_tiles);
    foreach my $gene (@$genes){
      print $w_fh $gene->toXMLString;
    }
    print $w_fh "</sequence_set>\n</otter>\n";
    my $r_fh = $temp->read_file_handle;
    if($test_file){
      open(OUT,">$test_file" || die "cannot open file");
      while(<$r_fh>){
	print OUT;
      }
      close(OUT);
    }else{
      my ($gene_list) = Bio::Otter::Converter::XML_to_otter($r_fh);
      foreach my $xml_gene (@$gene_list){
	my $ori_gene=shift @$genes;
	$xml_gene->analysis($anal);
	save_new_gene($otter_db, $gene_aptr, $ori_gene, $xml_gene, $slice, $test_flag);
      }
    }
    $client->unlock_otter_xml($lock_xml, $dset->name)
	if $lock_xml;
  }
}

sub save_new_gene {
    my( $otter_db, $gene_aptr, $db_gene, $xml_gene, $slice, $test_flag ) = @_;

    my $sida = $otter_db->get_StableIdAdaptor;
    $sida->fetch_new_stable_ids_for_Gene($xml_gene);

    my $broker = Bio::Otter::AnnotationBroker->new($otter_db);
    $broker->make_id_version_hash([$db_gene]);
    $broker->increment_versions_in_gene($xml_gene);
    $gene_aptr->attach_to_Slice($xml_gene, $slice);

    eval {
        $otter_db->begin_work;
        $xml_gene->detach_DBAdaptors;
        $gene_aptr->store($xml_gene);
    };
    if ($@) {
        $otter_db->rollback;
        warn "Error saving remapped gene: $@";
    }
    elsif ($test_flag) {
        warn "Test flag set - not saving\n";
        $otter_db->rollback;
    }
    else {
        $otter_db->commit;
    }
}

sub gene_is_truncated {
  my( $gene, $slice ) = @_;
  
  my $slice_length = $slice->length;
  foreach my $exon (@{$gene->get_all_Exons}) {
    if ($exon->contig != $slice or $exon->start < 1 or 
	$exon->end > $slice_length) {
      return 1;
    }
  }
  return 0;
}

sub containing_slice{
  my($slice_aptr,@gsi)=@_;
  my($chr,$st,$ed);
  foreach my $gsi (@gsi){
    my $slice=$slice_aptr->fetch_by_gene_stable_id($gsi);
    if($chr){
      if($slice->chr_name ne $chr){
	return 1;
      }else{
	my $st2=$slice->chr_start;
	my $ed2=$slice->chr_end;
	if($st2<$st){$st=$st2;}
	if($ed2>$ed){$ed=$ed2;}
	print "$chr:$st-$ed [$st2-$ed2]\n";
      }
    }else{
      $chr=$slice->chr_name;
      $st=$slice->chr_start;
      $ed=$slice->chr_end;
      print "$chr:$st-$ed\n";
    }
  }
  my $slice=$slice_aptr->fetch_by_chr_start_end($chr,$st,$ed);
  return 0,$slice
}


__END__

=head1 NAME - update_genes

=head1 SYNOPSIS

  update_genes -dataset <NAME> -set <NAME> -gene_stable_id <STABLE_ID> -option

=head1 AUTHOR

Tim Hubbard B<email> th@sanger.ac.uk
(read/save based on James realign_offtrack_genes script)

=head2 SUMMARY

Container script for any arbitary change that needs to be made to
gene(s) in otter such that a new version of the gene is saved,
preserving the old version.  Although this creates extra versions in
the database, its good practices for annotation changes, as it means a
record is kept of what was done and when.

-merge

uses -gene_stable_id to read list of gene_stable_ids from a file.
Multiple ids on a line are merged with first entry (i.e. gene is made
obsolete, but transcripts are copied to first gene).

-make_nmd

uses -gene_stable_id to specify list of transcript_stable_ids to have
their translation removed and become labelled as transcript_class
'Nonsense_mediated_decay'

-rename

uses -gene_stable_id to read list of stable_ids (can be gene or
transcript) from a file.  Second parameter on each line is used as new
name.

-include_stop

uses -gene_stable_id to read list of stable_ids (can be gene or transcript).

