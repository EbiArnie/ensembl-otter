#!/usr/bin/env perl

### patch_nmd_genes

use strict;
use warnings;
use Net::Domain qw{ hostname };

use Bio::Otter::Lace::Defaults;
use Bio::Vega::DBSQL::DBAdaptor;
use Bio::Vega::ContigLockBroker;
use Bio::Vega::Utils::XML qw{ freeze_thaw_gene };

use Bio::SeqIO;

my $pep_out = Bio::SeqIO->new(
    -FORMAT => 'fasta',
    -FH     => \*STDOUT,
    );

my $time_now = time();

{
    my $dsname;

    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s'     => \$dsname,
    );
    
    unless ($dsname) {
        Bio::Otter::Lace::Defaults::show_help();
    }

    my $cl = Bio::Otter::Lace::Defaults::make_Client();

    # For testing, so that we see restricted datasets
    $0 = 'otterlace';

    my $ds = $cl->get_DataSet_by_name($dsname);
    my $dba = $ds->get_cached_DBAdaptor;
    
    my $list_nmd = $dba->dbc->prepare(q{
        SELECT DISTINCT g.gene_id
        FROM gene g
          , transcript t
        WHERE g.gene_id = t.gene_id
          AND t.biotype = 'nonsense_mediated_decay'
          AND g.is_current = 1
    });
    $list_nmd->execute;
    my $gene_count = $list_nmd->rows;

    my $latest_with_translation = $dba->dbc->prepare(q{
        SELECT t.transcript_id
        FROM gene_stable_id gsid
          , transcript t
          , translation tsl
          , transcript_stable_id tsid
        WHERE gsid.gene_id = t.gene_id
          AND t.transcript_id = tsid.transcript_id
          AND t.transcript_id = tsl.transcript_id
          AND tsid.stable_id = ?
        ORDER BY gsid.modified_date DESC limit 1
    });
    
    my $locker = Bio::Vega::ContigLockBroker->new(
        -HOSTNAME   => hostname(),
        );
    my $author = Bio::Vega::Author->new(
        -NAME       => $cl->author,
        -EMAIL      => $cl->email,
        );

    my $recovered = 0;
    my $not_recov = 0;
    while (my ($g_dbID) = $list_nmd->fetchrow) {
        if (my $count = recover_coding_region($g_dbID, $dba, $latest_with_translation, $locker, $author)) {
            $recovered += $count;
        } else {
            $not_recov++;
        }
    }
    print STDERR "Found $gene_count Genes with nonsense_mediated_decay Transcripts\n",
      "Found or recovered Translation for $recovered nonsense_mediated_decay Transcripts\n",
      "Leaves $not_recov Genes with 1 or more nonsense_mediated_decay Transcripts missing Translation\n";
}

sub recover_coding_region {
    my ($g_dbID, $dba, $latest_with_translation, $locker, $author) = @_;
    
    my $gene_aptr  = $dba->get_GeneAdaptor;
    my $tsct_aptr  = $dba->get_TranscriptAdaptor;

    # my $gene = $gene_aptr->fetch_by_dbID($g_dbID);
    my $gene = freeze_thaw_gene($gene_aptr->fetch_by_dbID($g_dbID));

    ### Make XML gene here
    # 
    # # Need to make a fresh transcript array because the old one
    # # is cached inside the TranscriptAdaptor.
    # my $tsct_list = [ @{$gene->get_all_Transcripts} ];
    # $gene->{'_transcript_array'} = $tsct_list;
    my $tsct_list = $gene->get_all_Transcripts;
    
    my $found_tsl = 0;
    my $already_tsl = 0;
    for (my $i = 0; $i < @$tsct_list; $i++) {
        my $tsct = $tsct_list->[$i];
        next unless $tsct->biotype eq 'nonsense_mediated_decay';
        if ($tsct->translation) {
            printf STDERR "Transcript %s already has translation\n", $tsct->stable_id;
            print_translation($tsct, $gene->stable_id . "." . $gene->version);
            $already_tsl++;
            next;
        }
        $latest_with_translation->execute($tsct->stable_id);
        
        my ($tsct_dbID) = $latest_with_translation->fetchrow;
        unless ($tsct_dbID) {
            printf STDERR "No previous version of Transcript %s with translation\n", $tsct->stable_id;
            next;
        }
        my $tsct_tsl = $tsct_aptr->fetch_by_dbID($tsct_dbID);
        # print_translation($tsct_tsl);
        my $tsl = $tsct_tsl->translation;
        
        # Check exon coords are the same
        my $tsct_exons = $tsct->get_all_Exons;
        my $tsct_tsl_exons = $tsct_tsl->get_all_Exons;
        my $match = @$tsct_exons == @$tsct_tsl_exons ? 1 : 0;
        unless ($match) {
            printf STDERR "Most recent previous version of Transcript %s with translation has different number of exons (%d not %d)\n",
                $tsct->stable_id, scalar(@$tsct_tsl_exons), scalar(@$tsct_exons);
            next;
        }
        my $found_start_exon = 0;
        my $found_end_exon = 0;
        for (my $i = 0; $i < @$tsct_exons; $i++) {
            my $ex1 = $tsct_exons->[$i];
            my $ex2 = $tsct_tsl_exons->[$i];
            if ($ex1->seq->seq ne $ex2->seq->seq) {
                $match = 0;
                last;
            }
            if ($ex2 == $tsl->start_Exon) {
                $ex1->phase($ex2->phase);
                $tsl->start_Exon($ex1);
                $found_start_exon = 1;
            }
            if ($ex2 == $tsl->end_Exon) {
                $tsl->end_Exon($ex1);
                $found_end_exon = 1;
            }
        }
        if ($match) {
            printf STDERR "Found matching translation for Transcript %s\n", $tsct->stable_id;
            if ($found_start_exon and $found_end_exon) {
                $found_tsl++;
                
                # Dissociate translation from database
                $tsl->dbID(undef);
                $tsl->adaptor(undef);
                
                $tsct->translation($tsl);
                print_translation($tsct, $gene->stable_id);
            } else {
                print STDERR " ... but failed to find start and end exons\n";
            }
        } else {
            printf STDERR "No matching translation for Transcript %s\n", $tsct->stable_id;
        }
    }

    return $found_tsl + $already_tsl;

    if ($found_tsl) {
        $dba->begin_work;
        eval {
            $locker->lock_by_object($gene, $author);
            ### Test translation for stops
            $gene_aptr->store($gene, $time_now);
            $locker->remove_by_object($gene, $author);
        };
        if ($@) {
            my $err = $@;
            $dba->rollback;
            die $err;
        } else {
            $dba->rollback;
        }    
    }
    return $found_tsl + $already_tsl;
}

sub print_translation {
    my ($tsct, $desc) = @_;

    # my $desc = join(' | ', @ele);
    # $pep->id($t_name);
    # $pep->desc($desc);
    # $pep_out->write_seq($pep);

    my $tsl = $tsct->translation;
    my $tsl_pat = sprintf "%s(%d)  %s(%d)",
        $tsl->start_Exon->stable_id, $tsl->start,
        $tsl->end_Exon->stable_id, $tsl->end;
    
    my $pep = $tsct->translate;
    $pep->id($tsct->stable_id);
    $pep->desc($desc);
    $pep_out->write_seq($pep);
}



__END__

=head1 NAME - patch_nmd_genes

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

