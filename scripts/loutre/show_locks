#!/usr/bin/env perl

### show_locks

use strict;

use Getopt::Long 'GetOptions';
use List::Util 'max';
use Try::Tiny;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::Lace::PipelineDB;

use Bio::Vega::ContigLockBroker;
use Bio::Vega::SliceLockBroker;

$| = 1;

sub main {
    $0 = 'otterlace';
    my $dataset_name = undef;
    my $author    = undef;
    my $assembly  = undef;
    my $hostname  = undef;
    my $do_delete = 0;
    my ($do_interrupt, $do_expire) = (0, 0);
    my @lock_id_range = ();
    my $range_parser = sub{
        my( $start, $end ) = $_[1] =~ /(\d+)(?:[^\d+](\d+))?/;
        if ($start and ! $end) {
            $end = $start;
        }
        if ($start and $end and $start <= $end) {
            @lock_id_range = ($start, $end);
        } else {
            die "Bad lock id range ($start, $end)";
        }
    };
    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s'     => \$dataset_name,
        'annotator=s'   => \$author,
        'set=s'         => \$assembly,
        'machine=s'     => \$hostname,
        'delete!'       => \$do_delete,
        'interrupt!'    => \$do_interrupt,
        'expire!'       => \$do_expire,
        'range=s'       => $range_parser,
        # -h | --help : implicit in do_getopt
        ) or die "Bad options";
    die "No dataset name given" unless $dataset_name;
    die "Did not understand extra argv (@ARGV)" if @ARGV;
    die "Can only perform on of < -delete | -expire | -interrupt >"
      if (!!$do_delete + !!$do_expire + !!$do_interrupt) > 1;

    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);
    my $otter_db = $ds->get_cached_DBAdaptor;

    my $exit = 0;

    if (Bio::Vega::ContigLockBroker->supported($ds)) {
        $exit |= process_contig_locks
          ($otter_db, $author, $hostname, $assembly,
           $do_delete, @lock_id_range)
            if !$do_interrupt && !$do_expire;
    } else {
        warn "CONTIG_LOCKs not supported in dataset $dataset_name\n";
        $exit |= $do_delete ? 8 : 0;
    }

    if (Bio::Vega::SliceLockBroker->supported($ds)) {
        $exit |= process_slice_locks
          ($otter_db, $author, $hostname, $assembly,
           $do_interrupt, $do_expire, @lock_id_range)
            if !$do_delete;
    } else {
        warn "SLICE_LOCKs not supported in dataset $dataset_name\n";
        $exit |= $do_interrupt || $do_expire ? 8 : 0;
    }

    return $exit;
}

sub process_slice_locks {
    my ($otter_db, $author_name, $hostname, $assembly,
        $do_interrupt, $do_expire, @lock_id_range) = @_;

    warn "Processing SLICE_LOCKs\n";
    my $SLdba = $otter_db->get_SliceLockAdaptor;

    my $author;
    if (defined $author_name) {
        $author = $otter_db->get_AuthorAdaptor->fetch_by_name($author_name);
        if (!$author) {
            warn "  Could not find author_name='$author_name' - doing nothing\n";
            return 4;
        }
    }

    # Fetch & filter
    my $locks;
    # later: options to fetch the pre/free locks, by various criteria?
    if ($author) {
        $locks = $SLdba->fetch_by_author($author, 1);
    } elsif (@lock_id_range && $lock_id_range[0] == $lock_id_range[1]) {
        $locks=[ $SLdba->fetch_by_dbID($lock_id_range[0]) ];
    } else {
        $locks = $SLdba->fetch_by_active('held');
    }

    $locks = [ grep { $hostname eq $_->hostname } @$locks ]
      if defined $hostname;

    $locks = [ grep { $assembly eq $_->slice->seq_region_name } @$locks ]
      if defined $assembly;

    $locks = [ grep {( $_->dbID >= $lock_id_range[0] &&
                       $_->dbID <= $lock_id_range[1] )} @$locks ]
      if @lock_id_range;

    # Show
    my $len_host = max(10, map { length($_->hostname) } @$locks);
    my $len_auth = max(7, map { length($_->describe_author) } @$locks);
    my $lock_to_row = sub {
        my ($L) = @_;
        return ($L->dbID, $L->active, $L->hostname, $L->describe_author,
                $L->describe_slice, $L->iso8601_ts_activity);
    };
    my $row_pattern = "%6s %-4s  %-${len_host}s  %-${len_auth}s  %-40s  %-23s\n";
    printf STDERR $row_pattern, qw( # actv host author slice activity );
    printf STDERR $row_pattern, map { "-" x $_ } (4, 4, $len_host, $len_auth, 40, 23);
    foreach my $L (sort { $a->ts_activity <=> $b->ts_activity || $a->dbID <=> $b->dbID }
                   @$locks) {
        printf $row_pattern, $lock_to_row->($L);
    }

    # Unlock
    my ($op, $freed);
    ($op, $freed) = qw( expire    expired     ) if $do_expire;
    ($op, $freed) = qw( interrupt interrupted ) if $do_interrupt;
    if ($op && @$locks && q_del($op)) {
        my $me = getpwuid($<);
        my $unlocker = $otter_db->get_AuthorAdaptor->fetch_by_email($me)
          or die "Could not find unlock author_email=$me";
        my $count = 0;
        foreach my $L (@$locks) {
            try {
                $L->adaptor->unlock($L, $unlocker, $freed);
                $count ++;
            } catch {
                my $id = $L->dbID;
                warn "Unlock #$id failed: $_";
            };
        }
        print "\u$freed $count locks\n";
    }

    return 0;
    # Early return for error conditions
}

sub process_contig_locks {
    my ($otter_db, $author, $hostname, $assembly,
        $do_delete, @lock_id_range) = @_;

    warn "Processing CONTIG_LOCKs\n";

    my $sql = q{
        SELECT l.contig_lock_id
          , l.hostname
          , au.author_name
          , clone.name
          , intl.value
          , l.timestamp
          , ss.name
        FROM (author au
              , contig_lock l
              , seq_region contig
              , seq_region ss
              , seq_region clone
              , assembly ss_asm
              , assembly clone_asm)
        LEFT JOIN seq_region_attrib hidden
          ON ss.seq_region_id = hidden.seq_region_id
          AND hidden.attrib_type_id =
        (SELECT attrib_type_id
            FROM attrib_type
            WHERE code = 'hidden')
        LEFT JOIN seq_region_attrib intl
          ON clone.seq_region_id = intl.seq_region_id
          AND intl.attrib_type_id =
        (SELECT attrib_type_id
            FROM attrib_type
            WHERE code = 'intl_clone_name')
        WHERE au.author_id = l.author_id
          AND l.seq_region_id = contig.seq_region_id
          AND contig.seq_region_id = ss_asm.cmp_seq_region_id
          AND ss_asm.asm_seq_region_id = ss.seq_region_id
          AND ss.coord_system_id =
        (SELECT coord_system_id
            FROM coord_system
            WHERE name = 'chromosome'
              AND version = 'Otter')
          AND contig.seq_region_id = clone_asm.cmp_seq_region_id
          AND clone_asm.asm_seq_region_id = clone.seq_region_id
          AND clone.coord_system_id =
        (SELECT coord_system_id
            FROM coord_system
            WHERE name = 'clone')
          AND hidden.value != 1
        };
    my( @param );
    if ($author) {
        $sql .= ' AND au.author_name = ? ';
        push(@param, $author);
    }
    if ($assembly) {
        $sql .= ' AND ss.name = ? ';
        push(@param, $assembly);
    }
    if ($hostname) {
        $sql .= ' AND l.hostname = ? ';
        push(@param, $hostname);
    }
    if (@lock_id_range) {
        $sql .= ' AND l.contig_lock_id BETWEEN ? AND ? ';
        push(@param, @lock_id_range);
    }
    $sql .= ' ORDER BY l.contig_lock_id ASC ';

    # warn "Preparing SQL $sql";
    my $sth = $otter_db->dbc->prepare($sql);
    # warn "Executing SQL";
    $sth->execute(@param);
    
    my( %lock_id );
    while (my @row = $sth->fetchrow) {
        my ($lid, $host, $author, $acc_sv, $intl, $date, $type, $start, $end) = @row;
        if (my $info = $lock_id{$lid}) {
            push(@$info, $type);
        } else {
            $lock_id{$lid} = [$host, $author, $acc_sv, $intl, $date, $type, $start, $end];
        }
    }

    my $ditto = '';
    my $last_set = '';
    my $row_pattern = "  %6d  %-20s  %7s  %-12s  %15s  %19s  %10s\n";
    foreach my $lid (sort {$a <=> $b} keys %lock_id) {
        my $info = $lock_id{$lid};
        
        my $host   = shift @$info;
        my $author = shift @$info;
        my $acc_sv = shift @$info;
        my $intl   = shift @$info || '';    # From left join
        my $date   = shift @$info;
        # my $type   = join ' ', sort  @$info;
        my $type   = shift @$info;
        
        my $this_set = join(' ', $host, $author, $date, $type);
        
        # Make output easier to read by using ditto marks where
        # columns are the same in a locked set of clones
        if ($this_set eq $last_set) {
            printf  $row_pattern,
              $lid, $ditto,  $ditto, $acc_sv, $intl, $ditto, $ditto;
        } else {
            print "\n";
            printf  $row_pattern,
              $lid,  $host, $author, $acc_sv, $intl,  $date,  $type;
        }
        $last_set = $this_set;
    }
    print "\n";
    
    my $lock_count = scalar keys %lock_id;

    if ($do_delete and scalar keys %lock_id) {
        if (q_del("delete")) {
            my $del_sth = $otter_db->dbc->prepare(q{
                DELETE FROM contig_lock
                WHERE contig_lock_id = ?
                });
            my $count = 0;
            foreach my $lid (sort {$a <=> $b} keys %lock_id) {
                $del_sth->execute($lid);
                $count += $del_sth->rows;
            }
            print "Deleted $count locks\n";
        }
    }
    return 0;
}

sub q_del {
    my ($op) = @_;
    print STDERR "\u$op all these locks? [y|N] ";
    my $ans = <STDIN>;
    return ($ans =~ /^y/i);
}

exit main();

__END__


=head1 NAME - show_locks

=head1 DESCRIPTION

Show and delete locks from an otter database.

If locks need to be removed by hand it is because something has gone
wrong in the annotation system - which may need to be fixed!

=head1 SYNOPSIS

  show_locks -dataset <DATASET_NAME> [-delete | -interrupt | -expire ] \
    [-annotator <UNAME>] [-set <TYPE>] [-machine <HOSTNAME>] [-range <INT[-INT]>]

=head1 ARGUMENTS

=over 4

=item -dataset <DATASET_NAME>

The name of the dataset to search.  eg: B<human>

=item -delete | -interrupt | -expire

With one of these flags set, the script will show the list of locks
that match the search criteria followed by a prompt which asks if all
the locks in the list should be cancelled.

"Delete" is for the old contig locks.  "Expire" is for SliceLocks
which have been unused for long enough to be considered stale.
"Interrupt" is for SliceLocks when the need to interrupt a region of
work justifies preventing its owner saving.

=back

The rest of the arguments confine the list of
locks shown to:

=over 4

=item -set <TYPE>

Clones which are members of this sequence set. 
(Sequence sets are listed on the far right of the
output.)

=item -annotator <UNAME>

Those locked by this user name.

=item -machine <HOSTNAME>

Those that were locked from the named computer.

=item -range <INT[-INT]>

Those in this range (or this one if only one
number is given).  The two integers can be
separated by any non-integer non-whitespace
characers.

=back

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk


