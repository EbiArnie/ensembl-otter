#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;

$| = 1;

my $DEBUG=0;

my $sq = Bio::Otter::ServerQuery->new('dataset','qnames','type','maxpipehits','unhide');
set_nph($sq);

# This is a 3-level hash:
# {query_name}{type_of_query}{clones_found}
#
my $qnames = $sq->getarg('qnames') || error_exit($sq, "No 'qnames' argument entered");
my $qnames_types_clones  = { map {($_ => {})} split(',', $qnames) };
my $clone_name_set       = {};
my $clonename2assemblies = {};
my $filter_atype = $sq->getarg('type') || '';
my $unhide = $sq->getarg('unhide') || 0;
my $maxpipehits = $sq->getarg('maxpipehits');

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $pdba = odba_to_sdba($sq, $odba, $pipehead);
my $pdbc = $pipehead ? $pdba->dbc() : $pdba;

    # currently, since Otter is old schema and Pipe is new schema,
    # we can only provide Otter in case $pipehead==0
if(!$pipehead) {
    find_otter_clones_by_qnames($sq, $odba, $qnames_types_clones, $clone_name_set);
}

find_pipe_clones_by_qnames($sq, $pdbc, $qnames_types_clones, $clone_name_set, $pipehead, $maxpipehits);

my $assembly_dbc = $pipehead ? $pdbc : $odba;

$clonename2assemblies = find_assemblies_by_clone_names($sq, $assembly_dbc, $clone_name_set, $pipehead, $unhide);

my $output_string = generate_output($qnames_types_clones, $clonename2assemblies, $filter_atype);

send_response($sq, $output_string, 1);

1;

############## actual search subroutines: ################################
sub exons2clones {
    my ($qname, $type, $exons, $qnames_types_clones, $clone_name_set) = @_;

    server_log("'$qname' was found and contains ".scalar(@$exons)." exons.");
    foreach my $exon (@$exons) {
        my $clone = $exon->contig()->clone();
        my $clone_name = $clone->embl_id().'.'.$clone->embl_version();

        $qnames_types_clones->{$qname}{$type}{$clone_name}++;
        $clone_name_set->{$clone_name}++;
    }
}

sub find_pipe_clones_by_qnames {
    my ($sq, $dba, $qnames_types_clones, $clone_name_set, $pipehead, $maxpipehits) = @_;

    my $qnames_string = join(', ', map { "'$_'" } keys %$qnames_types_clones);

    for my $feature_table ('dna_align_feature', 'protein_align_feature') {

        my $sql = $pipehead
        ? qq{
            SELECT f.hit_name, f.score, cl.name
            FROM $feature_table f, assembly asm, seq_region cl, coord_system cs
            WHERE f.seq_region_id=asm.cmp_seq_region_id
              AND asm.asm_seq_region_id=cl.seq_region_id
              AND cl.coord_system_id=cs.coord_system_id
              AND cs.name='clone'
              AND f.hit_name in ($qnames_string)
         ORDER BY f.score desc
        }.($maxpipehits ? "LIMIT $maxpipehits" : '')
        : qq{
            SELECT f.hit_name, f.score, concat(cl.embl_acc,'.',cl.embl_version)
              FROM $feature_table f, contig co, clone cl
             WHERE f.contig_id=co.contig_id
               AND co.clone_id=cl.clone_id
               AND f.hit_name in ($qnames_string)
          ORDER BY f.score desc
        }.($maxpipehits ? "LIMIT $maxpipehits" : '')
        ;
        warn $sql if $DEBUG;
        my $sth = $dba->prepare($sql);
        $sth->execute;
        
        server_log("trying hits $qnames_string in $feature_table table");
        while (my ($hit_name, $score, $clone_name) = $sth->fetchrow) {
            $qnames_types_clones->{$hit_name}{$feature_table}{$clone_name}++;
            $clone_name_set->{$clone_name}++;
        }
    }
}

sub find_otter_clones_by_qnames {
    my ($sq, $dba, $qnames_types_clones, $clone_name_set) = @_;

    my $meta_con = $dba->get_MetaContainer();
    my $prefix_primary = $meta_con->get_primary_prefix() || error_exit($sq, "Missing prefix.primary in meta table");
    my $prefix_species = $meta_con->get_species_prefix() || error_exit($sq, "Missing prefix.species in meta table");

    my $gene_adaptor           = $dba->get_GeneAdaptor();
    my $genename_adaptor       = $dba->get_GeneNameAdaptor();
    my $genesyn_adaptor        = $dba->get_GeneSynonymAdaptor();
    my $geneinfo_adaptor       = $dba->get_GeneInfoAdaptor();
    my $transcript_adaptor     = $dba->get_TranscriptAdaptor();
    my $exon_adaptor           = $dba->get_ExonAdaptor();

    foreach my $qname (keys %$qnames_types_clones) {
        if(uc($qname) =~ /^$prefix_primary$prefix_species([TPGE])\d+/i){ # try stable_ids
            my $typeletter = $1;
            my $type;
            my $exons;

            eval {
                if($typeletter eq 'G') {
                    $type = 'gene_stable_id';
                    $exons = $gene_adaptor->fetch_by_stable_id($qname)->get_all_Exons();
                } elsif($typeletter eq 'T') {
                    $type = 'transcript_stable_id';
                    $exons = $transcript_adaptor->fetch_by_stable_id($qname)->get_all_Exons();
                } elsif($typeletter eq 'P') {
                    $type = 'translation_stable_id';
                    $exons = $transcript_adaptor->fetch_by_translation_stable_id($qname)->get_all_Exons();
                } elsif($typeletter eq 'E') {
                    $type = 'exon_stable_id';
                    $exons = [ $exon_adaptor->fetch_by_stable_id($qname) ];
                }
            };
                # Just imagine: they raise an EXCEPTION to indicate nothing was found. Terrific!
            if($@) {
                server_log("'$qname' looks like a stable id, but wasn't found.");
                server_log($@)if $DEBUG;
            } else {
                exons2clones($qname, $type, $exons, $qnames_types_clones, $clone_name_set);
            }
        }
        if($qname =~ /^(\w+)(?:\.(\d+))?$/) { # try clone accessions with & without version number
            my $wanted_acc = $1;
            my $wanted_version = $2;

            my $sql = qq{
                SELECT concat(embl_acc, '.', embl_version)
                FROM clone
                WHERE embl_acc = '$wanted_acc'
            }. (defined($wanted_version) ? qq{ AND embl_version = '$wanted_version' } : '');
            warn $sql if $DEBUG;
            my $sth = $dba->prepare($sql);
            $sth->execute;
            
            server_log("trying clone accession[.version] '$qname' ");
            while (my ($clone_name) = $sth->fetchrow) {
                $qnames_types_clones->{$qname}{clone_accession}{$clone_name}++;
                $clone_name_set->{$clone_name}++;
            }
        } elsif($qname =~ /^\w+\.\d+\.\d+\.\d+$/) { # try mapping contigs to clones
            my $sql = qq{
                SELECT concat(cl.embl_acc, '.', cl.embl_version)
                FROM clone cl, contig co
                WHERE co.name = '$qname'
                  AND cl.clone_id = co.clone_id
            };
            warn $sql if $DEBUG;
            my $sth = $dba->prepare($sql);
            $sth->execute;
            
            server_log("trying contig name '$qname' ");
            while (my ($clone_name) = $sth->fetchrow) {
                $qnames_types_clones->{$qname}{contig_name}{$clone_name}++;
                $clone_name_set->{$clone_name}++;
            }
        }

        { # try intl. clone names:
            my $sql = qq{
                SELECT concat(embl_acc, '.', embl_version)
                FROM clone
                WHERE name = '$qname'
            };
            warn $sql if $DEBUG;
            my $sth = $dba->prepare($sql);
            $sth->execute;
            
            server_log("trying intl. clone name '$qname' ");
            while (my ($clone_name) = $sth->fetchrow) {
                $qnames_types_clones->{$qname}{intl_clone_name}{$clone_name}++;
                $clone_name_set->{$clone_name}++;
            }
        }


        { # try gene name or synonym:
            my $exons;
            eval{
                server_log("trying gene name or synonym '$qname' ");
                my $geneNameObjList = $genename_adaptor->fetch_by_name($qname);
                my $geneSynObjList  = $genesyn_adaptor->fetch_by_name($qname);
                foreach my $geneNameObj (@$geneNameObjList, @$geneSynObjList){
                    my $geneInfoObj = $geneinfo_adaptor->fetch_by_dbID($geneNameObj->gene_info_id());    
                    $exons = $gene_adaptor->fetch_by_stable_id($geneInfoObj->gene_stable_id())->get_all_Exons();
                    exons2clones($qname, 'gene_name_or_synonym', $exons, $qnames_types_clones, $clone_name_set);
                }
            };
            if ($@){
                ## assume error was caused by not being able to create a $geneNameObjList -
                ## - as name didnt exist
                #
                server_log("no gene was found with name or synonym '$qname'"); 
                server_log($@)if $DEBUG;
            }
        }

    } # foreach $qname
}

sub find_assemblies_by_clone_names {
    my ($sq, $dba, $clone_name_set, $pipehead, $unhide) = @_;

    my $clonename2assemblies = {};

    # NB: for the pipeline we currently assume no SequenceSet is hidden!

    if(keys %$clone_name_set) {

        my $clones_string = join(', ', map { "'$_'" } keys %$clone_name_set);
        my $sql = $pipehead
        ? qq{
            SELECT ss.name, cl.name
            FROM seq_region   cl,
                 assembly     co2cl,
                 seq_region   co,
                 assembly     co2ss,
                 seq_region   ss
           WHERE cl.coord_system_id=(select coord_system_id from coord_system where name='clone')
             AND co2cl.cmp_seq_region_id=co.seq_region_id
             AND co2cl.asm_seq_region_id=cl.seq_region_id
             AND co.coord_system_id=(select coord_system_id from coord_system where name='contig')
             AND co2ss.cmp_seq_region_id=co.seq_region_id
             AND co2ss.asm_seq_region_id=ss.seq_region_id
             AND ss.coord_system_id=(select coord_system_id from coord_system where version='Otter')
             AND cl.name IN ($clones_string)
        }
        : qq{
            SELECT ss.assembly_type, concat(cl.embl_acc,'.',cl.embl_version), ss.hide
              FROM clone cl, contig co, assembly asm, sequence_set ss
             WHERE concat(cl.embl_acc,'.',cl.embl_version) IN ($clones_string)
               AND co.clone_id=cl.clone_id
               AND asm.contig_id=co.contig_id
               AND ss.assembly_type=asm.type
        }.($unhide ? '' : "       AND ss.hide='N' ");
        warn $sql if $DEBUG;
        my $sth = $dba->prepare($sql);
        $sth->execute;
        
        server_log("finding assemblies for clone names");
        while (my ($atype, $clone_name, $hide) = $sth->fetchrow) {
            $clonename2assemblies->{$clone_name} ||= {};
            $clonename2assemblies->{$clone_name}{$atype}++;
        }
    }

    return $clonename2assemblies;
}

sub generate_output {
    my ($qnames_types_clones, $clonename2assemblies, $filter_atype) = @_;

    my $output_string = '';

    for my $qname (sort keys %$qnames_types_clones) {
        my $types_set = $qnames_types_clones->{$qname};
        if(keys %$types_set) {
            for my $type (keys %$types_set) {
                my $clones = $types_set->{$type};

                my %asm2clonenames = ();

                    # inversion and partial grouping:
                for my $clone_name (keys %$clones) {
                    for my $asm (keys %{$clonename2assemblies->{$clone_name}}) {
                        $asm2clonenames{$asm}{$clone_name}++;
                    }
                }

                if(keys %asm2clonenames) {
                    for my $asm (keys %asm2clonenames) {
                        if(!$filter_atype || ($filter_atype eq $asm)) {
                            $output_string .= join("\t", $qname, $type,
                                join(',', keys %{$asm2clonenames{$asm}}),
                                $asm)."\n";
                        }
                    }
                } else {
                    $output_string .= "$qname\n";
                    server_log("$qname found on some clone, but its assembly is hidden or inexistent");
                }
            }
        } else {
            $output_string .= "$qname\n";
            server_log("$qname not found on any clone");
        }
    }

    return $output_string;
}

