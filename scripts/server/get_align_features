#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;
use Bio::Otter::Lace::ViaText ('%OrderOfOptions');
use Bio::Otter::DBSQL::SimpleBindingAdaptor;
use Bio::Otter::HitDescription;

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'cs','csver','name','type','start','end','strand',
    'kind','metakey','analysis');
set_nph($sq);

my $analysis = $sq->getarg('analysis');
my $metakey  = $sq->getarg('metakey') || ''; # defaults to pipeline

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $sdba = odba_to_sdba($sq, $odba, $pipehead, $metakey);
pre_remapping($sq, $odba, $sdba, $pipehead);
my $satellite_slice = get_slice($sq, $sdba, $pipehead);

my $sdbc = $pipehead ? $sdba->dbc() : $sdba; # needed for SimpleBindingAdaptor

if(!defined($satellite_slice)) {
    error_exit($sq, "Satellite slice undefined!");
}

my @af_optnames = @{ $OrderOfOptions{AlignFeature} };
my @hd_optnames = @{ $OrderOfOptions{HitDescription} };

my $kind     = $sq->getarg('kind');
my $method = {
    'dafs' => 'get_all_DnaAlignFeatures',
    'pafs' => 'get_all_ProteinAlignFeatures',
}->{$kind};

my $afs = $satellite_slice->$method($analysis);

$analysis ||= '(any analysis)';
server_log("Total of ".scalar(@$afs)." $kind:$analysis features found");

    # Put the names into the hit_description hash:
my %hd_hash = ();
foreach my $af (@$afs) {
    $hd_hash{$af->hseqname()} = '';
}

    # Fetch the hit descriptions:
my $hd_adaptor = Bio::Otter::DBSQL::SimpleBindingAdaptor->new( $sdbc );
$hd_adaptor->fetch_into_hash(
    'hit_description',
    'hit_name',
    { qw(
        hit_length _hit_length
        hit_description _description
        hit_taxon _taxon_id
        hit_db _db_name
    )},
    'Bio::Otter::HitDescription',
    \%hd_hash,
);

my $output_string = '';

    # Stringify only the simple fields:
my %hit_seen = (); # collect the seen hit names here
foreach my $af (@$afs) {
    my $hit_name = $af->hseqname();
    my $hd = $hd_hash{$hit_name};
    if($hd) {
        if(!exists($hit_seen{$hit_name})) { # a new one

                # output a HitDescription line
            my @hd_optvalues = ('HitDescription', $hit_name);
            for my $opt (@hd_optnames) {
                push @hd_optvalues, $hd->$opt();
            }
            $output_string .= join("\t", @hd_optvalues)."\n";

            $hit_seen{$hit_name} = 1;
        }
    }
    
        # output an AlignFeature line
    my @af_optvalues = ('AlignFeature');
    for my $opt (@af_optnames) {
        push @af_optvalues, $af->$opt();
    }
    push @af_optvalues, $af->cigar_string();

    push @af_optvalues, $af->analysis()->logic_name();

    $output_string .= join("\t", @af_optvalues)."\n";
}

send_response($sq, $output_string, 1);

