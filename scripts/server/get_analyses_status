#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;

my $ana_root = 'SubmitContig';

sub get_possible_analyses {
    my $pdbc = shift @_;

    my %rule = ();
    my $sth = $pdbc->prepare(qq{
        SELECT rc.rule_condition
             , a.logic_name
        FROM analysis a
           , rule_goal rg
           , rule_conditions rc
        WHERE a.analysis_id = rg.goal
          AND rg.rule_id = rc.rule_id
        });
    $sth->execute;
    while (my ($condition, $logic_name) = $sth->fetchrow) {
        push @{$rule{$condition}}, $logic_name;
    }

    # saturate the dependency relation:
    my @possible_analyses = ();
    my $current_rules = [ $ana_root ];
    while (scalar(@$current_rules)) {
        my @dependent_rules = ();
        foreach my $curr (@$current_rules) {
            push @dependent_rules, @{$rule{$curr} || []};
        }
        push @possible_analyses, @dependent_rules;
        $current_rules = \@dependent_rules;
    }

    return @possible_analyses;
}

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset','type');
set_nph($sq);

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);

my $pdba = odba_to_sdba($sq, $odba, $pipehead);
my $pdbc = $pipehead ? $pdba->dbc() : $pdba;

my $assembly = $sq->getarg('type') || error_exit($sq, "Please define the assembly type");

my @input_ids = ();

if($pipehead) {

    my $component_cs = 'contig';

    my $sth = $pdbc->prepare(qq{
        SELECT cmp.name
        FROM coord_system cs
          , seq_region cmp
          , assembly a
          , seq_region asm
        WHERE asm.name = '$assembly'
          AND asm.seq_region_id = a.asm_seq_region_id
          AND a.cmp_seq_region_id = cmp.seq_region_id
          AND cmp.coord_system_id = cs.coord_system_id
          AND cs.name = '$component_cs'
    });
    $sth->execute();

    while (my ($cmp_name) = $sth->fetchrow) {
        my @syll = split(/\./, $cmp_name);
        my $to = pop @syll;
        my $from = pop @syll;
        push @input_ids, join(':', $component_cs, '', $cmp_name, $from, $to, 1);
    }

} else {

    my $sth = $pdbc->prepare(qq{
        SELECT c.name
        FROM assembly a
          , contig c
        WHERE a.type = '$assembly'
          AND a.contig_id = c.contig_id
    });
    $sth->execute();

    while (my ($cmp_name) = $sth->fetchrow) {
        push @input_ids, $cmp_name;
    }
}

my %skeleton_hash = map { ($_ => []) } get_possible_analyses($pdbc);
my %result_hash   = ();

# If there are no input IDs - just peacefully return an empty list:
if(! @input_ids) {
    server_log('No input IDs');
    send_response($sq, '', 1);
    exit(0);
}

my $input_id_str = join(', ', map "'$_'", @input_ids);
my $sql_statement = qq{
        SELECT i.input_id
          , a.logic_name
          , i.created
          , i.db_version
        FROM analysis a
          , input_id_analysis i
        WHERE a.analysis_id = i.analysis_id
          AND i.input_id IN ($input_id_str)
        };
my $sth = $pdbc->prepare($sql_statement);
$sth->execute();

while(my ($input_id, $logic_name, $created, $db_version) = $sth->fetchrow_array) {
    $input_id=~s/^contig::([^:]+):.*$/$1/;

    if(!exists($result_hash{$input_id})) {
        %{$result_hash{$input_id}} = %skeleton_hash;
    }
    $result_hash{$input_id}{$logic_name} = [$created, $db_version];
}

    # output the results:
my $output_string = '';
for my $input_id (sort keys %result_hash) {
    for my $logic_name (sort {
            ($a eq $ana_root) ? -1 : ($b eq $ana_root) ? 1 : ($a cmp $b)
        } keys %{$result_hash{$input_id}}) {
            $output_string .= join("\t", $input_id, $logic_name, @{$result_hash{$input_id}{$logic_name}})."\n";
    }
}
send_response($sq, $output_string, 1);

