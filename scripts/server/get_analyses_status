#!/usr/local/bin/perl5.8.0 -w

my $enshead = $ENV{ENSHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use CGI;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;

my $ana_root = 'SubmitContig';

sub get_possible_analyses {
    my $dbh = shift @_;

    my %rule = ();
    my $namepairs = $dbh->selectall_arrayref(
          'SELECT rc.condition, a.logic_name FROM '
         .'analysis a, rule_goal rg, rule_conditions rc '
         .'WHERE a.analysis_id = rg.goal AND rg.rule_id = rc.rule_id');
    while( my $pair = shift @$namepairs) {
        push @{$rule{$pair->[0]}}, $pair->[1];
    }

        # saturate the dependency relation:
    my @possible_analyses = ();
    my $current_rules = [ $ana_root ];
    while (scalar(@$current_rules)) {
        my @dependent_rules = ();
        foreach my $curr (@$current_rules) {
            push @dependent_rules, @{$rule{$curr} || []};
        }
        push @possible_analyses, @dependent_rules;
        $current_rules = \@dependent_rules;
    }

    return @possible_analyses;
}

$| = 1;

my $cgi = new CGI;
set_nph($cgi);
my %cgi_args = $cgi->Vars;

my $odb = get_DBAdaptor_from_CGI_species($cgi, $OTTER_SPECIES, $enshead);

my $dbh = get_connected_pipeline_dbhandle($cgi, $odb, $enshead);

my $assembly = $cgi_args{type};

my @input_ids;

if($enshead) {

    my $component_cs = 'contig';

    my $contigvecs = $dbh->selectall_arrayref(
        "SELECT cmp.name ".
        "FROM coord_system cs, seq_region cmp, assembly a, seq_region asm ".
        "WHERE asm.name = '$assembly' ".
        "AND asm.seq_region_id = a.asm_seq_region_id ".
        "AND a.cmp_seq_region_id = cmp.seq_region_id ".
        "AND cmp.coord_system_id = cs.coord_system_id ".
        "AND cs.name='$component_cs'");

    @input_ids = map {
        my $name = $_->[0];
        my @syll = split(/\./, $name);
        "'".join(':', $component_cs, '', $name, $syll[2], $syll[3], 1)."'";
    } @$contigvecs;

} else {

    @input_ids = map {
        "'".$_->[0]."'";
    } @{ $dbh->selectall_arrayref(
        "SELECT c.name ".
        "FROM assembly a, contig c ".
        "WHERE a.type='$assembly' ".
        "AND a.contig_id = c.contig_id") };

}

my %skeleton_hash = map { ($_ => []) } get_possible_analyses($dbh);
my %result_hash   = ();

my $sql_statement =
        "SELECT i.input_id, a.logic_name, i.created, i.db_version ".
        "FROM analysis a, input_id_analysis i ".
        "WHERE a.analysis_id = i.analysis_id AND i.input_id IN (".
        join(', ', @input_ids).
        ')';
my $sth = $dbh->prepare($sql_statement);
$sth->execute();

while(my ($input_id, $logic_name, $created, $db_version) = $sth->fetchrow_array) {
    $input_id=~s/^contig::([^:]+):.*$/$1/;

    if(!exists($result_hash{$input_id})) {
        %{$result_hash{$input_id}} = %skeleton_hash;
    }
    $result_hash{$input_id}{$logic_name} = [$created, $db_version];
}

    # output the results:
my $output_string = '';
for my $input_id (sort keys %result_hash) {
    for my $logic_name (sort {
            ($a eq $ana_root) ? -1 : ($b eq $ana_root) ? 1 : ($a cmp $b)
        } keys %{$result_hash{$input_id}}) {
            $output_string .= join("\t", $input_id, $logic_name, @{$result_hash{$input_id}{$logic_name}})."\n";
    }
}
send_response($cgi, $output_string, 1);

