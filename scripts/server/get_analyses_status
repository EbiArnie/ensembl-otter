#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use CGI;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;

my $ana_root = 'SubmitContig';

sub get_possible_analyses {
    my $dbh = shift @_;

    my %rule = ();
    my $sth = $dbh->prepare(qq{
        SELECT rc.condition
             , a.logic_name
        FROM analysis a
           , rule_goal rg
           , rule_conditions rc
        WHERE a.analysis_id = rg.goal
          AND rg.rule_id = rc.rule_id
        });
    $sth->execute;
    while (my ($condition, $logic_name) = $sth->fetchrow) {
        push @{$rule{$condition}}, $logic_name;
    }

    # saturate the dependency relation:
    my @possible_analyses = ();
    my $current_rules = [ $ana_root ];
    while (scalar(@$current_rules)) {
        my @dependent_rules = ();
        foreach my $curr (@$current_rules) {
            push @dependent_rules, @{$rule{$curr} || []};
        }
        push @possible_analyses, @dependent_rules;
        $current_rules = \@dependent_rules;
    }

    return @possible_analyses;
}

$| = 1;

my $cgi = new CGI;
set_nph($cgi);
my %cgi_args = $cgi->Vars;

my $odb = get_DBAdaptor_from_CGI_species($cgi, $OTTER_SPECIES, $pipehead);

my $dbh = get_connected_pipeline_dbhandle($cgi, $odb, $pipehead);

my $assembly = $cgi_args{type};

my @input_ids;

if($pipehead) {

    my $component_cs = 'contig';

    my $contigvecs = $dbh->selectall_arrayref(qq{
        SELECT cmp.name
        FROM coord_system cs
          , seq_region cmp
          , assembly a
          , seq_region asm
        WHERE asm.name = '$assembly'
          AND asm.seq_region_id = a.asm_seq_region_id
          AND a.cmp_seq_region_id = cmp.seq_region_id
          AND cmp.coord_system_id = cs.coord_system_id
          AND cs.name = '$component_cs'
        });

    @input_ids = map {
        my $name = $_->[0];
        my @syll = split(/\./, $name);
        my $to = pop @syll;
        my $from = pop @syll;
        join(':', $component_cs, '', $name, $from, $to, 1);
    } @$contigvecs;

} else {

    @input_ids = map $_->[0], @{
      $dbh->selectall_arrayref(qq{
        SELECT c.name
        FROM assembly a
          , contig c
        WHERE a.type = '$assembly'
          AND a.contig_id = c.contig_id
        })
      };
}

my %skeleton_hash = map { ($_ => []) } get_possible_analyses($dbh);
my %result_hash   = ();

### Will this die produce a sensible error message?
# die "No input IDs" unless @input_ids;
if(! @input_ids) {
    # error_exit($cgi, 'No input IDs');
    send_response($cgi, '');
    exit(0);
}

my $input_id_str = join(', ', map "'$_'", @input_ids);
my $sql_statement = qq{
        SELECT i.input_id
          , a.logic_name
          , i.created
          , i.db_version
        FROM analysis a
          , input_id_analysis i
        WHERE a.analysis_id = i.analysis_id
          AND i.input_id IN ($input_id_str)
        };
my $sth = $dbh->prepare($sql_statement);
$sth->execute();

while(my ($input_id, $logic_name, $created, $db_version) = $sth->fetchrow_array) {
    $input_id=~s/^contig::([^:]+):.*$/$1/;

    if(!exists($result_hash{$input_id})) {
        %{$result_hash{$input_id}} = %skeleton_hash;
    }
    $result_hash{$input_id}{$logic_name} = [$created, $db_version];
}

    # output the results:
my $output_string = '';
for my $input_id (sort keys %result_hash) {
    for my $logic_name (sort {
            ($a eq $ana_root) ? -1 : ($b eq $ana_root) ? 1 : ($a cmp $b)
        } keys %{$result_hash{$input_id}}) {
            $output_string .= join("\t", $input_id, $logic_name, @{$result_hash{$input_id}{$logic_name}})."\n";
    }
}
send_response($cgi, $output_string, 1);

