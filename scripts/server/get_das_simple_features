#!/usr/local/bin/perl -w

my $http_proxy = $ENV{http_proxy};

use strict;
use Bio::Das;
use Bio::EnsEMBL::SimpleFeature;
use Bio::Otter::ServerScriptSupport;
use Bio::Otter::Lace::ViaText ('%OrderOfOptions');

sub Bio::EnsEMBL::Slice::get_all_DasFeatures {
    my ($slice, $server, $das, $chr_name, $analysis) = @_;

    my $chr_start = $slice->start();
    my $chr_end   = $slice->end();
    my $segment_name  = "$chr_name:$chr_start,$chr_end";

    $server->log( sprintf ("GET  %s/features?segment=%s%s\n",
                            $das->default_url, $segment_name,
                            $analysis ? ";type=$analysis" : '') );

    my $segment = $das->segment($chr_name, $chr_start, $chr_end);
    unless($segment) {
        $server->log( "DAS source refused to serve the segment={$segment_name}");
        return [];
    }

    my @feature_type  = $analysis ? ('-type' => $analysis) : ();
    my $iterator = $segment->features(-iterator => 1, @feature_type);

    my @dsfs = ();
    while (my $das_feature = $iterator->next_seq) {
        my $simple_feature = Bio::EnsEMBL::SimpleFeature->new();
        $simple_feature->slice(   $slice );
        $simple_feature->start(   $das_feature->start() - $chr_start + 1 );
        $simple_feature->end(     $das_feature->stop()  - $chr_start + 1 );
        $simple_feature->strand( ($das_feature->orientation() eq '-') ? -1 : 1 );
        $simple_feature->score(  ($das_feature->score() eq '-') ? 100 : $das_feature->score() );
        $simple_feature->display_label( $das_feature->id() );

        push @dsfs, $simple_feature;
    }

    return \@dsfs;
}


my $server = Bio::Otter::ServerScriptSupport->new('dataset',
    'cs','csver','name','type','start','end','strand','metakey',
    'source', 'dsn','analysis');

if(!$server->running_headcode()) {
    $server->error_exit("This kind of data can only be fetched in pipehead==1 mode");
}

my $chr_name = $server->getarg('name');  ## Since in our new schema name is substituted for type,
                                     ## we need it clean for outer sources

my $source   = $server->require_argument('source');
my $dsn      = $server->require_argument('dsn');
my $analysis = $server->getarg('analysis'); # defaults to *everything*

my $das = Bio::Das->new(
    -source => $source,
    -dsn    => $dsn,
);
$das->proxy($http_proxy) if $http_proxy;

my $dsfs = $server->fetch_mapped_features('das_simple_feature', 
            ['get_all_DasFeatures', $server, $das, $chr_name, $analysis] );

my @sf_optnames = @{ $OrderOfOptions{SimpleFeature} };
my $output_string = '';

foreach my $sf (@$dsfs) {
        # output a SimpleFeature line
    my @sf_optvalues = ('SimpleFeature');
    for my $opt (@sf_optnames) {
        push @sf_optvalues, $sf->$opt();
    }

    $output_string .= join("\t", @sf_optvalues)."\n";
}

$server->send_response($output_string, 1);

1;

