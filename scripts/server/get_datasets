#!/usr/local/bin/perl -w

use OtterDefs;
use strict;

use CGI;

use HTTPD::Authen;
use Bio::Otter::Version;
use Bio::Otter::ServerSide (':all');

$|             = 1;
my $DEBUG      = 0;
my $ALLOW_ALL  = 0;
my $ERROR_AUTH = 'unknown user or incorrect password';

my $cgi        = new CGI;
set_nph($cgi);

my %cgi_args   = $cgi->Vars;
my $user       = $cgi_args{'author'} || '**NOT Using Authorization**';

my $groupAd;

if($ENV{AUTHUSERFILE} && $ENV{AUTHGROUPFILE}){
    ($groupAd,$user) = check_authorisation();
}else{
    $ALLOW_ALL = 1;
}

# This is a check so that $groupAd->exists won't die if
# ALLOW_ALL is false when no authentication was passed
error_exit($cgi, $ERROR_AUTH) unless $groupAd || $ALLOW_ALL;

# find the ones they're allowed
my @allowed_to_see = ();

foreach my $dataset (keys %$OTTER_SPECIES) {
  next if ($dataset =~ /defaults/);
  server_log("Testing user '$user' in dataset '$dataset'") if $DEBUG;
  # This "next unless" uses perl's clever "or" checking where it 
  # won't bother checking the second for truth if the first is true.
  next unless $ALLOW_ALL || $groupAd->exists($dataset, $user);
  server_log("Allowing user '$user' access to dataset '$dataset'") if $DEBUG;
  push(@allowed_to_see, $dataset);
}


# I'd like to use xml::writer here, but it won't do output to string
# Also it's probably a bit heavyweight just to concatenate a few strings together.
my $xml   .= qq`  <datasets>\n`;
# return the ones user is allowed to see.
foreach my $dataset(@allowed_to_see){
    $xml .= qq`    <dataset name="$dataset">\n`;
    foreach my $key (keys %{$OTTER_SPECIES->{$dataset}}) {
        $xml .= qq`      <` . lc $key . qq`>`;
        $xml .= $OTTER_SPECIES->{$dataset}->{$key};
        $xml .= qq`</` . lc $key . qq`>\n`;
    }
    $xml .= qq`    </dataset>\n`;
}
$xml .= qq`  </datasets>\n`;

send_response($cgi, $xml, 1);

1;

######################################################################
#End main
######################################################################

sub check_authorisation{
    my ($groupAdminObj, $authinfo, $authen);

    $authinfo = $ENV{'HTTP_AUTHORIZATION'} || 'Basic xxxxxxx';
    $authen = HTTPD::Authen->new(DB     => $ENV{AUTHUSERFILE},
                                 DBType => 'Text',
                                 Server => 'Apache');
    server_log("AUTH was '$authinfo'") if $DEBUG;

    my $authtype      = $authen->type($authinfo);
    my ($user, $pass) = ('ERROR') x 2;
    ($user, $pass)    = $authtype->parse($authinfo);

    server_log("Got info ['$user', '$pass']") if $DEBUG;

    if( my $ok = $authen->check($user, $pass) ){
        server_log("user '$user', was AUTHENTICATED") if $DEBUG;
        $groupAdminObj = $authen->{USER}->group($user);
        $groupAdminObj->db($ENV{'AUTHGROUPFILE'});
        if($DEBUG){
            # this gets all the groups in the .htgroups file
            foreach my $groupname($groupAdminObj->list()){
                if($groupAdminObj->exists($groupname, $user)){
                    server_log("User: '$user' is part of group: '$groupname'");
                }else{
                    server_log("User: '$user' is *NOT* part of group: '$groupname'");
                }
            }
        }
    }else{
        server_log("user was NOT AUTHENTICATED") if $DEBUG;
        error_exit($cgi, $ERROR_AUTH);
    }
    return $groupAdminObj, $user;

}

=pod

=head1 get_datasets

=head1 DESCRIPTION

Returns a list of datasets to the Client.
Will only return the list the user has access to see
if the server has been setup (see ../../conf/README.user.pod).

=cut
