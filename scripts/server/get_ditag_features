#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::ViaText ('%OrderOfOptions');

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'cs','csver','name','type','start','end','strand',
    'metakey','analysis');
set_nph($sq);

if(!$pipehead) {
    error_exit($sq, "This kind of data is only available from new API databases. Set pipehead to 1");
}

my $cs       = $sq->getarg('cs')      || 'chromosome';
my $csver    = $sq->getarg('csver')   || undef;
my $analysis = $sq->getarg('analysis');
my $metakey  = $sq->getarg('metakey') || ''; # defaults to pipeline

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $sdba = odba_to_sdba($sq, $odba, $pipehead, $metakey);

my ($mdba, $sdba_asm) = get_mapper_dba($sq, $odba, $sdba, $pipehead);

server_log(' ** sdba_asm: "'.$sdba_asm.'"');

my $dfs = [];
my $dfa = $sdba->get_DitagFeatureAdaptor();

if($mdba) {
    my $original_slice_on_mapper = get_slice($sq, $mdba, $pipehead);
    my $proj_segments_on_mapper = $original_slice_on_mapper->project( $cs, $sdba_asm );

    my $sa_on_target = $sdba->get_SliceAdaptor();

    foreach my $segment (@$proj_segments_on_mapper) {
        my $projected_slice_on_mapper = $segment->to_Slice();

        my $target_slice_on_target = $sa_on_target->fetch_by_region(
            $projected_slice_on_mapper->coord_system()->name(),
            $projected_slice_on_mapper->seq_region_name(),
            $projected_slice_on_mapper->start(),
            $projected_slice_on_mapper->end(),
            $projected_slice_on_mapper->strand(),
            $projected_slice_on_mapper->coord_system()->version(),
        );

        my $target_dfs_on_target_segment =
            # $dfa->fetch_all_by_Slice($target_slice_on_target, undef, $analysis) || [];
            $dfa->fetch_all_by_Slice($target_slice_on_target) || [];

        server_log('***** : '.scalar(@$target_dfs_on_target_segment).' found on the slice'
                    .$target_slice_on_target->name());

        foreach my $target_df (@$target_dfs_on_target_segment) {
            $target_df->slice($projected_slice_on_mapper);
            push @$dfs, $target_df->transform($cs, $csver);
        }
    }

} else {
    my $original_slice = get_slice($sq, $sdba, $pipehead);

    # $dfs = $dfa->fetch_all_by_Slice($original_slice, undef, $analysis) || [];
    $dfs = $dfa->fetch_all_by_Slice($original_slice) || [];
}

server_log("Total of ".scalar(@$dfs).($analysis ? " $analysis":'')." ditag features found");

my @df_optnames = @{ $OrderOfOptions{DitagFeature} };
my @do_optnames = @{ $OrderOfOptions{DitagObject} };
my $output_string = '';

    # Stringify only the simple fields:
my %do_seen = (); # collect the seen ditag object ids here
foreach my $df (@$dfs) {
    my $do = $df->fetch_ditag(); # object
    my $do_id = $do->dbID();

    if(!exists($do_seen{$do_id})) { # a new one

            # output a ditag object line:
        my @do_optvalues = ('DitagObject');
        for my $opt (@do_optnames) {
            push @do_optvalues, $do->$opt() || 0;
        }
        $output_string .= join("\t", @do_optvalues)."\n";

        $do_seen{$do_id}++;
    }
    
        # output a ditag feature line:
    my @df_optvalues = ('DitagFeature');
    for my $opt (@df_optnames) {
        push @df_optvalues, $df->$opt();
    }
    push @df_optvalues, $do_id;

    $output_string .= join("\t", @df_optvalues)."\n";
}

send_response($sq, $output_string, 1);

