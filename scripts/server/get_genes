#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;
use Bio::Otter::ToXML;

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'cs','csver','name','type','start','end','strand',
    'metakey','analysis','transcript_analyses');
set_nph($sq);

my $cs       = $sq->getarg('cs')      || 'chromosome';
my $csver    = $sq->getarg('csver')   || undef;
my $analysis = $sq->getarg('analysis');
my $metakey  = $sq->getarg('metakey') || ''; # defaults to pipeline
my $transcript_analyses = $sq->getarg('transcript_analyses') || '';

my $allowed_transcript_analyses_hash = $transcript_analyses
    ? { map { $_ => 1 } split(/,/, $transcript_analyses) }
    : '';

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $sdba = odba_to_sdba($sq, $odba, $pipehead, $metakey);

my ($mdba, $sdba_asm) = get_mapper_dba($sq, $odba, $sdba, $pipehead);

my $genes = [];

if($mdba) {
#    server_log("Assembly mapping not implemented yet");
#    send_response($sq, '', 1);
#    exit(0);

    my $original_slice_on_mapper = get_slice($sq, $mdba, $pipehead);
    my $proj_segments_on_mapper = $original_slice_on_mapper->project( $cs, $sdba_asm );

    my $sa_on_target = $sdba->get_SliceAdaptor();

    foreach my $segment (@$proj_segments_on_mapper) {
        my $projected_slice = $segment->to_Slice();

        my $target_slice_on_target = $sa_on_target->fetch_by_region(
            $projected_slice->coord_system()->name(),
            $projected_slice->seq_region_name(),
            $projected_slice->start(),
            $projected_slice->end(),
            $projected_slice->strand(),
            $projected_slice->coord_system()->version(),
        );

            # third parameter of $slice->get_all_Genes() helps preventing lazy-loading of transcripts
        my $target_genes_on_target_segment = $target_slice_on_target->get_all_Genes($analysis, undef, 1);
        server_log('***** : '.scalar(@$target_genes_on_target_segment).' found on a slice');

        foreach my $target_gene (@$target_genes_on_target_segment) {
            $target_gene->adaptor($mdba);
            push @$genes, $target_gene->transform($cs, $csver);
        }
    }

} else {
    my $original_slice = get_slice($sq, $sdba, $pipehead);
    $genes = $original_slice->get_all_Genes($analysis);
}

server_log("Total of ".scalar(@$genes)." '$analysis' genes sent");

my $output_string = '';

foreach my $gene (@$genes) {
    $output_string .= $gene->toXMLstring($allowed_transcript_analyses_hash);
}

send_response($sq, $output_string, 1);

