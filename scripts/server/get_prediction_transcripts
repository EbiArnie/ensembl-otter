#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;
use Bio::Otter::Lace::ViaText ('%OrderOfOptions');

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'cs','csver','name','type','start','end','strand',
    'analysis');
set_nph($sq);

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $pdba = odba_to_pdba($sq, $odba, $pipehead);
my $pipeline_slice = get_slice($sq, $pdba, $pipehead);

my @pt_optnames = @{ $OrderOfOptions{PredictionTranscript} };
my @pe_optnames = @{ $OrderOfOptions{PredictionExon} };

my $analysis = $sq->getarg('analysis');
my $pts = $pipeline_slice->get_all_PredictionTranscripts($analysis, 1);
    # last_arg=1 means "fetch all exons now"

server_log("Total of ".scalar(@$pts)." $analysis prediction transcripts found");

my $output_string = '';

foreach my $pt (@$pts) {

        # output a predictioin transcipt line:
    my @pt_optvalues = ('PredictionTranscript');
    for my $opt (@pt_optnames) {
        push @pt_optvalues, $pt->$opt();
    }
    $output_string .= join("\t", @pt_optvalues)."\n";

    my $pt_id = $pt->dbID();

    for my $pe (@{$pt->get_all_Exons}) {
            # output an exon line
        my @pe_optvalues = ('PredictionExon');
        for my $opt (@pe_optnames) {
            push @pe_optvalues, $pe->$opt || 0;
        }
        push @pe_optvalues, $pt_id;

        $output_string .= join("\t", @pe_optvalues)."\n";
    }
}

send_response($sq, $output_string, 1);

