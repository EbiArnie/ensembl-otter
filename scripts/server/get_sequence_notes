#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request
# but probably not needed now since we do not work with pipeline

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::DBSQL::DBAdaptor;

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'contig', 'type', 'author');
set_nph($sq);

my $odb = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);

my $asm_type = $sq->getarg('type');
my $aut_name = $sq->getarg('author');
my $ctg_name = $sq->getarg('contig');

my $sth = $odb->prepare(qq{
    SELECT ctg.name,
           aut.author_name,
           s.is_current,
           s.note_time,
           UNIX_TIMESTAMP(s.note_time) as ts,
           s.note
      FROM }
.($asm_type ? qq{ assembly asm, } : '' )
.qq{       sequence_note s,
           contig ctg,
           author aut
     WHERE }
.($ctg_name ? qq{ ctg.name = "$ctg_name" AND } : '' )
.($asm_type ? qq{ asm.type = "$asm_type" AND asm.contig_id = ctg.contig_id AND } : '' )
.qq{       s.contig_id = ctg.contig_id }
.($aut_name ? qq{ AND aut.author_name = "$aut_name" } : '')
.qq{   AND s.author_id = aut.author_id
  ORDER BY ctg.name, s.note_time DESC
});
$sth->execute();

my $output_string = '';
while (my (@columns) = $sth->fetchrow()) {
    $columns[scalar(@columns)-1]=~s/\n/\ /g;
    $output_string .= join("\t", @columns)."\n";
}

send_response($sq, $output_string, 1);

