#!/usr/local/bin/perl -w

# TODO: currently this script uses old API's mechanism
# for slice->[tiles*] decomposition.
# We may need another (new API) solution for pipehead=1 case
# (will make a smoother transition) - probably through new pipeline_db.

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'cs','csver','name','type','start','end','strand',
    'dnawanted', 'metakey');
set_nph($sq);

my $metakey  = $sq->getarg('metakey') || ''; # defaults to pipeline
my $dna_wanted = $sq->getarg('dnawanted') || 0;

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $sdba = odba_to_sdba($sq, $odba, $pipehead, $metakey);
my $slice = get_slice($sq, $sdba, $pipehead);

my $output_string = '';

if($pipehead) {
    foreach my $tile (@{ $slice->project('clone') }) {

        my $proj_slice = $tile->to_Slice();
        my $underlying_slice = $proj_slice->seq_region_Slice();

        $output_string .= join("\t",
            $proj_slice->seq_region_name(),
            $proj_slice->name(),

            $tile->from_start(),
            $tile->from_end(),

            $proj_slice->start(),
            $proj_slice->end(),
            $proj_slice->strand(),

            $underlying_slice->length(),
            $underlying_slice->seq(),
            "\n"
        );
    }
} else {
    foreach my $tile (@{ $slice->get_tiling_path }) {
        if(my $clone = $tile->component_Seq->clone) {
            $output_string .= join("\t",
                $clone->embl_id(),
                $clone->embl_version(),
                $clone->id(), # international clone name
                $tile->component_Seq()->name(), # contig name

                $tile->assembled_Seq()->chr_name(),
                $tile->assembled_Seq()->assembly_type(),
                $tile->assembled_start(),
                $tile->assembled_end(),

                $tile->component_start(),
                $tile->component_end(),
                $tile->component_ori(),
                length($tile->component_Seq()->seq()),

                $dna_wanted ? ($tile->component_Seq()->seq()) : (),
                "\n"
            );
        }
    } # foreach $tile
} # if($pipehead) else...

send_response($sq, $output_string, 1);

