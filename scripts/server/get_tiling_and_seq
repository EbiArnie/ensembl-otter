#!/usr/local/bin/perl -w

# TODO: currently this script uses old API's mechanism
# for slice->[tiles*] decomposition.
# We may need another (new API) solution for pipehead=1 case
# (will make a smoother transition) - probably through new pipeline_db.

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET request

use strict;
use OtterDefs;
use Bio::Otter::ServerQuery;
use Bio::Otter::ServerSide (':all');
use Bio::Otter::Lace::PipelineDB;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::Otter::DBSQL::DBAdaptor;

$| = 1;

my $sq = Bio::Otter::ServerQuery->new('dataset',
    'cs','csver','name','type','start','end','strand',
    'dnawanted');
set_nph($sq);

my $dna_wanted = $sq->getarg('dnawanted') || 0;

my $odba = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES, $pipehead);
my $slice = get_slice($sq, $odba, 0); # temporarily we only support old schema

my $tp = $slice->get_tiling_path;

my $output_string = '';

foreach my $tile (@{ $slice->get_tiling_path }) {
    if(my $clone = $tile->component_Seq->clone) {
        $output_string .= join("\t",
            $clone->embl_id(),
            $clone->embl_version(),
            $clone->id(), # international clone name
            $tile->component_Seq()->name(), # contig name

            $tile->assembled_Seq()->chr_name(),
            $tile->assembled_Seq()->assembly_type(),
            $tile->assembled_start(),
            $tile->assembled_end(),

            $tile->component_start(),
            $tile->component_end(),
            $tile->component_ori(),
            length($tile->component_Seq()->seq()),

            $dna_wanted ? ($tile->component_Seq()->seq()) : (),
            "\n"
        );
    }
}

send_response($sq, $output_string, 1);

