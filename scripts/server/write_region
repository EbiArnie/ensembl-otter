#!/usr/local/bin/perl -w

use OtterDefs;
use strict;

use CGI;

use Bio::Otter::AnnotationBroker;
use Bio::Otter::Converter;
use Bio::Otter::Lace::TempFile;
use Bio::Otter::CloneLockBroker;

use Bio::Otter::ServerSide qw(:all);

####################################################################
################ COMMON POST CGI SCRIPT BEGIN ######################
####################################################################

local $| = 1;

my $cgi = new CGI;
set_nph($cgi);

server_log("******* Starting to write region *********");

my $odb    = get_DBAdaptor_from_CGI_species($cgi, $OTTER_SPECIES);
my $author = get_Author_from_CGI($cgi);

####################################################################
####################################################################
####################################################################

# Get all the params in nice variables

my %cgi_args = $cgi->Vars;

my $xml_data  = $cgi_args{'data'} || error_exit($cgi, "No xml data entered. Can't write region");
delete $cgi_args{'data'};
server_log("Length of data " . length($xml_data) );

my $auth_name = $author->name();
my $tmp_xml = Bio::Otter::Lace::TempFile->new;

$tmp_xml->root('/tmp');
$tmp_xml->name(qq`write_region_${auth_name}.xml`);
my $tmp_xml_name = $tmp_xml->full_name();

server_log("Writing xml to tmp file [$tmp_xml_name]");

my $xml_fh = eval{
  $tmp_xml->write_file_handle();
} || error_exit($cgi, "Can't write to '$tmp_xml_name' : $!");

print $xml_fh $xml_data;

# Save a bit of memory
$xml_data = undef;

server_log("Converting xml to otter...");
my $fh = $tmp_xml->read_file_handle();

####################################################################
################ COMMON POST CGI SCRIPT _END_ ######################
####################################################################

my( $genes, 
    $slice,			# The slice is fetched from the database by XML_to_otter
    $path,
    $new_feature_set,		# Arrayref of SimpleFeature objects
    $new_assembly_tag_set,	# Arrayref of AssemblyTag objects
    $chrname, $chrstart, $chrend,
  );

my $path_as_XML;

eval {
  my( $seqstr );		# Don't need outside block
  ($genes, $slice, $seqstr, $path, $new_feature_set, $new_assembly_tag_set) =
    Bio::Otter::Converter::XML_to_otter($fh, $odb);

  error_exit($cgi, "no path from XML")    unless  $path;
  error_exit($cgi, "empty path from XML") unless @$path;

  $chrname  = $slice->chr_name;
  $chrstart = $slice->chr_start;
  $chrend   = $slice->chr_end;

  $path_as_XML = Bio::Otter::Converter::path_to_XML($chrname, $chrstart, $chrend, $slice->assembly_type, $slice->get_tiling_path);

  server_log("Processed incoming xml file with slice: [$chrname] [$chrstart] [$chrend]"); 
};

if ($@) {
  error_exit($cgi, "Failed converting XML [$genes,$chrname,$chrstart,$chrend] to otter [$@]");
}

server_log("Done converting.");
server_log("Found ". scalar(@$genes) ." genes on slice [$chrname] [$chrstart] [$chrend]");


my $cb = new Bio::Otter::CloneLockBroker($odb);

server_log("Checking region is locked...");
eval {
  $cb->check_locks_exist_by_slice($slice, $author);
};

error_exit($cgi, "Failed checking locks [$@]") if $@;
server_log("Done checking region is locked.");

strip_incomplete_genes($genes);

# Get stable IDs for any genes, transcripts, translations and exons that don't have them
my $sida = $odb->get_StableIdAdaptor();
foreach my $gene (@$genes) {
    $sida->fetch_new_stable_ids_for_Gene($gene);
}

my $ab = new Bio::Otter::AnnotationBroker($odb);
$ab->current_author($author);

my $oaga = $odb->get_GeneAdaptor();
$odb->assembly_type($slice->assembly_type);

my $anal;

eval {
  $anal = $odb->get_AnalysisAdaptor()->fetch_by_logic_name('otter');
};

if ($@) {
  error_exit($cgi, "Failed fetching analysis [$@]");
}

if (!defined($anal)) {
  error_exit($cgi, "No analysis object associated with otter");
}

my $dbgenes;

server_log("Fetching database genes for comparison...");
eval {
  $dbgenes = $oaga->fetch_by_Slice($slice);
  strip_incomplete_genes($dbgenes);
};

if ($@) {
  error_exit($cgi, "Failed fetching genes [$@]");
}
server_log("Done fetching database genes.");

foreach my $gene (@$genes) {
  $gene->analysis($anal);
}


# These lines force loads from the database to stop attempted lazy
# loading during the write

eval {
  foreach my $gene (@$dbgenes) {

    my $transcripts = $gene->get_all_Transcripts;

    foreach my $tran (@$transcripts) {
      $tran->translation;
      if ($tran->translation) {
	$tran->translation->stable_id;
      }
      $tran->stable_id;

      my $exons =  $tran->get_all_Exons;
      foreach my $exon (@$exons) {
        $exon->stable_id;
      }
    }
  }
};

if ($@) {
  error_exit($cgi, "Failed fully loading genes before write [$@]");
}

my( @gene_events, @changed_clones );

server_log("Comparing ". scalar(@$dbgenes) ." old to ". scalar(@$genes) ." new gene(s)... ");

my( $del_sf, $save_sf, $del_at, $save_at );

eval {
  server_log("New clones");
  my $new_clones = clones_from_path($path);

  server_log("Old clones");
  my $old_clones = clones_from_path($slice->get_tiling_path);

  @gene_events = $ab->compare_genes($dbgenes, $genes);
  @changed_clones = $ab->compare_clones($old_clones, $new_clones);

  # $slice was fetched from the database by XML_to_otter, so we can simply:
  my $old_feature_set = $slice->get_all_SimpleFeatures;
  ($del_sf, $save_sf) = $ab->compare_feature_sets($old_feature_set, $new_feature_set);

  my $atag_Ad = $odb->get_AssemblyTagAdaptor;

  # $atags_Ad in inherits from Bio::EnsEMBL::DBSQL::BaseFeatureAdaptor,
  # which inherits from Bio::EnsEMBL::DBSQL:BaseAdaptor
  # This also allows fetching AssemblyTag features by passing a RowContig obj

  my $old_assembly_tag_set = $atag_Ad->fetch_all_by_Slice($slice);

  ($del_at, $save_at) = $ab->compare_assembly_tag_sets($old_assembly_tag_set, $new_assembly_tag_set);
};

if ($@) {
  error_exit($cgi, "Failed comparing annotations [$@]");
}
server_log("Done compating old genes to new ones.");

# the magic happens!

my ($outputstr, $output_xml);

eval {
  $odb->begin_work();

  server_log("Found ". scalar(@gene_events) ." changed gene annotations");

  foreach my $event ( @gene_events ) {
    $outputstr .= $event->to_string;
    server_log($event->to_string);

    my $gene;

    if ($event->type eq 'deleted') {
      $gene = $event->old_gene;
    } else {
      $gene = $event->new_gene;
    }

    # attach_to_Slice transforms exons to contig coordinates.
    # Need to save the original coordinates for the response XML.
    my( %exon_start_end_strand );
    foreach my $exon (@{$gene->get_all_Exons}) {
        my $stable = $exon->stable_id or error_exit($cgi, "Missing exon stable ID");
        $exon_start_end_strand{$stable} = [$exon->start, $exon->end, $exon->strand];
    }
    server_log("Attaching gene to slice ". $gene->stable_id ." ". $gene->version );
    $oaga->attach_to_Slice($gene,$slice);
    $gene->detach_DBAdaptors;
    server_log("Done attaching");

    $oaga->store($gene);
    
    # Restore the pre-transform exon coordinates
    foreach my $exon (@{$gene->get_all_Exons}) {
        my $stable = $exon->stable_id or error_exit($cgi, "Missing exon stable ID");
        my $ses = $exon_start_end_strand{$stable}
            or error_exit($cgi, "Couldn't get pre-transformed coordinates for exon '$stable'");
        my ($start, $end, $strand) = @$ses;
        $exon->start($start);
        $exon->end($end);
        $exon->strand($strand);
    }
    
    $output_xml .= $gene->toXMLString() unless $event->type eq 'deleted';
    server_log("Stored gene");
    $outputstr .= " " . $gene->version . " " . $gene->gene_info->name->name . "";
  }

  my $oaca = $odb->get_CloneAdaptor;
  foreach my $clone (@changed_clones) {

    my $acc = $clone->embl_id;
    my $sv  = $clone->embl_version;
    server_log("Storing new version of clone '$acc.$sv'");

    my $db_clone = $oaca->fetch_by_accession_version($acc, $sv);
    $db_clone->clone_info($clone->clone_info);
    $oaca->store($db_clone);
  }

  # Store SimpleFeature changes
  my $sfa = $odb->get_SimpleFeatureAdaptor;
  if (@$del_sf) {
    foreach my $sf (@$del_sf) {
      $sfa->remove($sf);
    }
    server_log("Deleting ".scalar(@$del_sf)." SimpleFeatures") unless $@;
  }
  if (@$save_sf) {
    attach_analysis_objects_and_transform_to_slice($odb, $slice, $save_sf);
    $sfa->store(@$save_sf);
    server_log("Saving ".scalar(@$save_sf)." SimpleFeatures") unless $@;
  }

  # Store Assembly_tags changes
  my $atag_Ad = $odb->get_AssemblyTagAdaptor;

  if (@$del_at) {
    $atag_Ad->remove($del_at);
    server_log("Deleting ".scalar(@$del_at)." AssemblyTags") unless $@;
  }

  if (@$save_at) {

    my $c_save = transform_assembly_tag_coordinates($slice, $save_at);
    $atag_Ad->store($c_save);
    server_log("Saving ".scalar(@$c_save)." AssemblyTags") unless $@;
  }

  $odb->commit();
};

if ($@) {
  error_exit($cgi, "Failed writing annotations [$@]");
}

$outputstr ||= "No changes to annotations";

$output_xml = $path_as_XML . $output_xml ;
send_response($cgi, $output_xml, 1);

     #-------------------------------------------
     #          S U B R O U T I N E S
     #-------------------------------------------


sub clones_from_path {
  my( $path ) = @_;

  my $clones = [];
  foreach my $rawcontig (map $_->component_Seq, @$path) {
    my $clone = $rawcontig->clone;
    unless ($clone) {
      server_log("No clone attached to '". $rawcontig->idi ."'");
      next;
    }
    push(@$clones, $clone);
  }
  return $clones;
}

sub attach_analysis_objects_and_transform_to_slice {
  my( $dba, $slice, $sf_list ) = @_;

  my $analysis_adaptor = $dba->get_AnalysisAdaptor;

  my( %logic_ana );

  for (my $i = 0; $i < @$sf_list; $i++) {

    my $sf = $sf_list->[$i];
    my $class = ref($sf);
    my $logic_name = $sf->analysis->logic_name;

    my $ana = $logic_ana{$logic_name}
      ||= $analysis_adaptor->fetch_by_logic_name($logic_name);

    $sf->analysis($ana);
    $sf->contig($slice);

    my @mapped = $sf->transform;

    if (@mapped == 1) {
      unless ($mapped[0]->isa($class)) {
        error_exit($cgi, "Error, got '$mapped[0]' from transform");
      }
      $sf_list->[$i] = $mapped[0];
    }
    else {
      error_exit($cgi, "transform returned ".scalar(@mapped)." features: (@mapped)");
    }
  }
}

sub transform_assembly_tag_coordinates {
  my ($slice, $sets) = @_;

  my $new_sets = [];

  foreach my $at ( @$sets ) {

    $at->contig($slice);
    my @mapped = $at->transform;

    if ( @mapped == 1 ) {
      unless ( $mapped[0]->isa(ref($at)) ) {
	    error_exit($cgi, "Error, got '$mapped[0]' from transform, which is not a ".ref($at));
      }

      # $mapped[0]->{_seqname} is contig_id,    # $mapped[0]->seqname : contig_name

      $at->contig_id($mapped[0]->{_seqname});
      $at->tag_info ($mapped[0]->tag_info);
      $at->tag_type ($mapped[0]->tag_type);
      push(@$new_sets, $at);
    }
    else {
      # can't deal with assembly tags mapped to > 1 contig
      error_exit($cgi, "transform returned ".scalar(@mapped)." AssemblyTag: (@mapped)");
    }
  }
  return $new_sets;
}

sub strip_incomplete_genes {
  my( $gene_list ) = @_;

  for (my $i = 0; $i < @$gene_list;) {
    my $gene = $gene_list->[$i];
    if ($gene->gene_info->truncated_flag) {
      server_log("Splicing out incomplete gene '". $gene->gene_info->name->name ."'");
      splice(@$gene_list, $i, 1);
      next;
    } else {
      $i++;
    }
  }
}

__END__

