#!/usr/local/bin/perl -w

use strict;
use Bio::Otter::ServerScriptSupport;
use Bio::Otter::AnnotationBroker;
use Bio::Otter::Converter;
use Bio::Otter::CloneLockBroker;
use Bio::Vega::Transform::Otter;
use Bio::Vega::Transform::XML;
use Bio::Vega::ContigLockBroker;

my $server = Bio::Otter::ServerScriptSupport->new('dataset', 'data', 'author', 'email');

my $odba       = $server->otter_dba();
my $author_obj = $server->make_Author_obj();

if ($odba->isa('Bio::Otter::DBSQL::DBAdaptor')) {

    my $output_xml = '';

    my (
        $xml_genes,
        $slice,             # The slice is fetched from the database by XML_to_otter
        $path,
        $xml_simple_features,   # Arrayref of SimpleFeature objects
        $xml_assembly_tags,    # Arrayref of AssemblyTag objects
        $chrname, $chrstart, $chrend,
    );

    eval {
        my $input_stream = $server->tempfile_from_argument('data')->read_file_handle();

        my ($seqstr);    # Not used outside block

        ( $xml_genes, $slice, $seqstr, $path, $xml_simple_features, $xml_assembly_tags)
              = Bio::Otter::Converter::XML_to_otter($input_stream, $odba);

        $server->error_exit("no path from XML")    unless $path;
        $server->error_exit("empty path from XML") unless @$path;
        $chrname     = $slice->chr_name;
        $chrstart    = $slice->chr_start;
        $chrend      = $slice->chr_end;

        $output_xml .= Bio::Otter::Converter::path_to_XML(
            $chrname, $chrstart, $chrend, $slice->assembly_type, $slice->get_tiling_path);

        $server->log( "Processed incoming xml file with slice: [$chrname] [$chrstart] [$chrend]");
    };

    if ($@) {
        $server->error_exit( "Failed converting XML [$xml_genes,$chrname,$chrstart,$chrend] to otter [$@]");
    }

    $server->log("Done converting.");
    $server->log("Found " . scalar(@$xml_genes) . " genes on slice [$chrname] [$chrstart] [$chrend]");

    my $cb = new Bio::Otter::CloneLockBroker($odba);
    $server->log("Checking region is locked...");
    eval { $cb->check_locks_exist_by_slice($slice, $author_obj); };
    $server->error_exit("Failed checking locks [$@]") if $@;
    $server->log("Done checking region is locked.");

    strip_incomplete_genes($xml_genes);

        # Get stable IDs for any genes, transcripts, translations and exons that don't have them:
    my $sida = $odba->get_StableIdAdaptor();
    foreach my $gene (@$xml_genes) {
        $sida->fetch_new_stable_ids_for_Gene($gene);
    }

    my $ab = new Bio::Otter::AnnotationBroker($odba);
    $ab->current_author($author_obj);

    $odba->assembly_type($slice->assembly_type);

    my $anal;
    eval { $anal = $odba->get_AnalysisAdaptor()->fetch_by_logic_name('otter'); };
    if ($@) {
        $server->error_exit("Failed fetching analysis [$@]");
    }
    if (!defined($anal)) {
        $server->error_exit("No analysis object associated with otter");
    }
    foreach my $gene (@$xml_genes) {
        $gene->analysis($anal);
    }

    my $oaga = $odba->get_GeneAdaptor();
    my $db_genes;
    $server->log("Fetching database genes for comparison...");
    eval {
        $db_genes = $oaga->fetch_by_Slice($slice);
        strip_incomplete_genes($db_genes);
    };
    if ($@) {
        $server->error_exit("Failed fetching genes [$@]");
    }
    $server->log("Done fetching database genes.");

    # These lines force loads from the database to stop attempted lazy
    # loading during the write
    eval {
        foreach my $dbgene (@$db_genes) {
            foreach my $tran (@{ $dbgene->get_all_Transcripts() }) {
                $tran->translation;
                if ($tran->translation) {
                    $tran->translation->stable_id;
                }
                $tran->stable_id;
                foreach my $exon (@{ $tran->get_all_Exons() }) {
                    $exon->stable_id;
                }
            }
        }
    };
    if ($@) {
        $server->error_exit("Failed fully loading genes before write [$@]");
    }

    $server->log("Comparing " . scalar(@$db_genes) . " old to " . scalar(@$xml_genes) . " new gene(s)... ");

    my ($gene_events, $changed_clones, $delete_sf, $save_sf, $delete_at, $save_at);
    eval {
        $gene_events    = $ab->compare_genes($db_genes,   $xml_genes);

        $server->log("New clones");
        my $xml_clones = clones_from_path($path);
        $server->log("Old clones");
        my $db_clones = clones_from_path($slice->get_tiling_path);

        $changed_clones = $ab->compare_clones($db_clones, $xml_clones);

            # $slice was fetched from the database by XML_to_otter, so we can simply:
        my $db_simple_features = $slice->get_all_SimpleFeatures;
        ($delete_sf, $save_sf) = $ab->compare_feature_sets($db_simple_features, $xml_simple_features);

        my $atag_Ad = $odba->get_AssemblyTagAdaptor;
            # $atags_Ad inherits from Bio::EnsEMBL::DBSQL::BaseFeatureAdaptor,
            # which inherits from Bio::EnsEMBL::DBSQL:BaseAdaptor
            # This also allows fetching AssemblyTag features by passing a RowContig obj
        my $db_assembly_tags = $atag_Ad->fetch_all_by_Slice($slice);
        ($delete_at, $save_at) = $ab->compare_assembly_tag_sets($db_assembly_tags, $xml_assembly_tags);
    };
    if ($@) {
        $server->error_exit("Failed comparing annotations [$@]");
    }
    $server->log("Done compating old genes to new ones.");

        # Now do the actual saving:
    my $outputstr = '';
    eval {
        $odba->begin_work();
        $server->log( "Found " . scalar(@$gene_events) . " changed gene annotations");

        foreach my $event (@$gene_events) {
            $outputstr .= $event->to_string;
            $server->log($event->to_string);

            my $gene;
            if ($event->type eq 'deleted') {
                $gene = $event->old_gene;
            } else {
                $gene = $event->new_gene;
            }

            # attach_to_Slice transforms exons to contig coordinates.
            # Need to save the original coordinates for the response XML.
            my %exon_start_end_strand = ();
            foreach my $exon (@{ $gene->get_all_Exons }) {
                my $stable = $exon->stable_id
                  || $server->error_exit("Missing exon stable ID");
                $exon_start_end_strand{$stable} =
                  [ $exon->start, $exon->end, $exon->strand ];
            }
            $server->log("Attaching gene to slice " . $gene->stable_id . " " . $gene->version);
            $oaga->attach_to_Slice($gene, $slice);
            $gene->detach_DBAdaptors;
            $server->log("Done attaching");
            $oaga->store($gene);

            # Restore the pre-transform exon coordinates
            foreach my $exon (@{ $gene->get_all_Exons }) {
                my $stable = $exon->stable_id
                  || $server->error_exit("Missing exon stable ID");
                my $ses = $exon_start_end_strand{$stable}
                  || $server->error_exit( "Couldn't get pre-transformed coordinates for exon '$stable'");

                my ($exon_start, $exon_end, $exon_strand) = @$ses;
                $exon->start($exon_start);
                $exon->end($exon_end);
                $exon->strand($exon_strand);
            }
            $output_xml .= $gene->toXMLString()
              unless $event->type eq 'deleted';
            $server->log("Stored gene");
            $outputstr .= ' ' . $gene->version . ' ' . $gene->gene_info->name->name ;
        }

        my $oaca = $odba->get_CloneAdaptor;
        foreach my $clone (@$changed_clones) {
            my $acc = $clone->embl_id;
            my $sv  = $clone->embl_version;
            $server->log("Storing new version of clone '$acc.$sv'");
            my $db_clone = $oaca->fetch_by_accession_version($acc, $sv);
            $db_clone->clone_info($clone->clone_info);
            $oaca->store($db_clone);
        }

        # Store SimpleFeature changes
        my $sfa = $odba->get_SimpleFeatureAdaptor;
        if (@$delete_sf) {
            foreach my $sf (@$delete_sf) {
                $sfa->remove($sf);
            }
            $server->log("Deleted " . scalar(@$delete_sf) . " SimpleFeatures") unless $@;
        }
        if (@$save_sf) {
            attach_analysis_objects_and_transform_to_slice($odba, $slice, $save_sf);
            $sfa->store(@$save_sf);
            $server->log("Saved " . scalar(@$save_sf) . " SimpleFeatures") unless $@;
        }

        # Store Assembly_tags changes
        my $atag_Ad = $odba->get_AssemblyTagAdaptor;
        if (@$delete_at) {
            $atag_Ad->remove($delete_at);
            $server->log("Deleted " . scalar(@$delete_at) . " AssemblyTags") unless $@;
        }
        if (@$save_at) {
            my $c_save = transform_assembly_tag_coordinates($slice, $save_at);
            $atag_Ad->store($c_save);
            $server->log("Saved " . scalar(@$c_save) . " AssemblyTags") unless $@;
        }
        $odba->commit();
    };
    if ($@) {
        $server->error_exit("Failed writing annotations [$@]");
    }
    $outputstr ||= "No changes to annotations";
    $server->send_response($output_xml, 1);

} elsif ($odba->isa('Bio::Vega::DBSQL::DBAdaptor')) {

    my $xml_string = $server->require_argument('data');

    my $parser = Bio::Vega::Transform::Otter->new;
    eval {
        $parser->parse($xml_string);
    };
    if ($@) {
        $server->error_exit("Failed converting XML to otter [$@]");
    }

    # check that the assembly is already loaded in the database and
    # is consistent with the current xml assembly

    my ($slice, $chr_ctg);
    my %xmlfrag = ();
    eval {
        my $cs           = 'chromosome';
        my $segment_name = $parser->get_AssemblyType->{'assembly_type'};
        my $chr_slice    = $parser->get_ChromosomeSlice;
        my $start        = $chr_slice->start;
        my $end          = $chr_slice->end;
        my $strand       = $chr_slice->strand;
        my $cs_version   = $parser->init_CoordSystem_Version;

        $slice = $odba->get_SliceAdaptor()->fetch_by_region(
                            $cs, $segment_name, $start, $end, $strand, $cs_version);

        $chr_ctg = $parser->get_AssemblySlices->{'chr_ctg'};

        foreach my $piece (@$chr_ctg) {
            my $xml_ctg_slice = $piece->[1];
            my $ctg_name      = $xml_ctg_slice->seq_region_name;
            my $ctg_start     = $xml_ctg_slice->start;
            my $ctg_end       = $xml_ctg_slice->end;
            $xmlfrag{$ctg_name}{start} = $ctg_start;
            $xmlfrag{$ctg_name}{end}   = $ctg_end;
        }
        my $slice_projection = $slice->project('contig');
        foreach my $seg (@$slice_projection) {
            my $contig_slice = $seg->to_Slice();
            my $contig_name  = $contig_slice->seq_region_name;
            my $contig_start = $contig_slice->start;
            my $contig_end   = $contig_slice->end;
            if ($xmlfrag{$contig_name}) {
                if (   ($xmlfrag{$contig_name}{start} != $contig_start)
                    || ($xmlfrag{$contig_name}{end} != $contig_end))
                {
                    $server->error_exit( "Assembly doesn't match for contig $contig_name");
                }
                $xmlfrag{$contig_name}{slice} = $contig_slice;
            } else {
                $server->error_exit( "Assembly doesn't match for contig $contig_name");
            }
        }
    };
    if ($@) {
        $server->error_exit("Failed at comparing xml assembly with database assembly [$@]");
    }
    my $output_xml;
    $odba->begin_work;

    eval {
        ##check if clones are locked or not
        my $cb = new Bio::Vega::ContigLockBroker;
        $server->log("Checking region is locked...");
        eval { $cb->check_locks_exist_by_slice($slice, $author_obj, $odba); };
        $server->error_exit("Failed checking locks [$@]") if $@;
        $server->log("Done checking region is locked.");
        ##update all contig_info and contig_info_attrib
        foreach my $piece (@$chr_ctg) {
            my $ctg_attrib_list = $piece->[2];
            my $cmp_slice       = $piece->[1];
            my $ctg_name        = $cmp_slice->seq_region_name;
            my $ctg_author      = $piece->[3];
            my $ctg_slice       = $xmlfrag{$ctg_name}{slice};

            insert_ContigInfo_Attributes($odba, $author_obj, $ctg_slice, $ctg_attrib_list);
            $server->log("Updating contig info-attrib for " . $ctg_slice->seq_region_name);
        }

        ## strip_incomplete_genes for the xml genes
        my $xml_genes = $parser->get_Genes || [];
        strip_incomplete_genes($xml_genes);

        ##fetch database genes and compare to find the new/modified/deleted genes
        $server->log("Fetching database genes for comparison...");
        my $db_genes = $slice->get_all_Genes || [];
        strip_incomplete_genes($db_genes);
        $server->log("Comparing " . scalar(@$db_genes) . " old to " . scalar(@$xml_genes) . " new gene(s)... ");

        my $gene_adaptor = $odba->get_GeneAdaptor;
        $server->log("Attaching gene to slice ");

        foreach my $gene (@$xml_genes) {
            ##attach gene and its components to the right slice
            $gene->slice($slice);
            ##update author in gene and transcript
            $gene->gene_author($author_obj);
            my $tref = $gene->get_all_Transcripts();
            foreach my $tran (@$tref) {
                $tran->slice($slice);
                $tran->transcript_author($author_obj);
                foreach my $exon (@{ $tran->get_all_Exons }) {
                    $exon->slice($slice);
                }
            }
            ##update all gene and its components in db (new/mod)
            $gene->is_current(1);
            $gene_adaptor->store($gene);
        }
        $server->log("Updated " . scalar(@$xml_genes) . " genes");
        
        my %stored_genes_hash = map {$_->stable_id, $_} @$xml_genes;
        
        my $del_count = 0;
        foreach my $dbgene (@$db_genes) {
            next if $stored_genes_hash{$dbgene->stable_id};

            ##attach gene and its components to the right slice
            $dbgene->slice($slice);
            ##update author in gene and transcript
            $dbgene->gene_author($author_obj);
            my $tref = $dbgene->get_all_Transcripts();
            foreach my $tran (@$tref) {
                $tran->slice($slice);
                $tran->transcript_author($author_obj);
                foreach my $exon (@{ $tran->get_all_Exons }) {
                    $exon->slice($slice);
                }
            }
            ##update all gene and its components in db (del)
            
            # Setting is_current to 0 will cause the store method to delete it.
            $dbgene->is_current(0);
            $gene_adaptor->store($dbgene);
            $del_count++;
            $server->log("Deleted gene " . $dbgene->stable_id);
        }
        $server->log("Deleted $del_count Genes") if ($del_count);

        my $ab = $odba->get_AnnotationBroker();

            # Because exons can be shared (potentially between genes!),
            # deleting them is a complex issue:
        $ab->hide_unused_exons($db_genes, $xml_genes);

        ##update feature_sets
        ##SimpleFeatures - deletes old features(features not in xml)
        ##and stores the current featues in databse(features in xml)
        my $xml_simple_features = $parser->get_SimpleFeatures;
        my $sfa                 = $odba->get_SimpleFeatureAdaptor;
        my $db_simple_features  = $sfa->fetch_all_by_Slice($slice);

        my ($delete_sf, $save_sf) = $ab->compare_feature_sets($db_simple_features, $xml_simple_features);
        foreach my $del_feat (@$delete_sf) {
            $sfa->remove($del_feat);
        }
        $server->log("Deleted " . scalar(@$delete_sf) . " SimpleFeatures") unless $@;
        foreach my $new_feat (@$save_sf) {
            $new_feat->slice($slice);
            $sfa->store($new_feat);
        }
        $server->log("Saved " . scalar(@$save_sf) . " SimpleFeatures") unless $@;

        ##assembly_tags are not taken into account here, as they are not part of annotation nor versioned ,
        ##but may be required in the future
        ##fetch a new slice, and convert this new_slice to xml so that
        ##the response xml has all the above changes done in this session

        ##pass on to the xml generator the current set of genes , simple features
        $output_xml =  Bio::Vega::Transform::XML->new->generate_OtterXML([$slice], $odba, 0, $xml_genes, $xml_simple_features);
    };
    if ($@) {
        $server->error_exit("Failed writing annotations [$@]");
        $odba->rollback;
    }
    else {
        $odba->commit;
    }
    ##send the response
    $server->send_response($output_xml);
}
else {
    $server->error_exit("Require an Otter DB Adaptor and not '$odba'");
}

#-------------------------------------------
#          S U B R O U T I N E S
#-------------------------------------------


sub insert_ContigInfo_Attributes {
    my ($db, $ctg_author, $ctg_slice, $ctg_attrib_list) = @_;
    my $contig_info =  Bio::Vega::ContigInfo->new(
                        -author     => $ctg_author,
                        -slice      => $ctg_slice,
                        -attributes => $ctg_attrib_list,
    );
    $db->get_ContigInfoAdaptor->store($contig_info);
}

sub clones_from_path {
    my ($path) = @_;

    my $clones = [];
    foreach my $rawcontig (map $_->component_Seq, @$path) {
        my $clone = $rawcontig->clone;
        unless ($clone) {
            $server->log("No clone attached to '" . $rawcontig->idi . "'");
            next;
        }
        push(@$clones, $clone);
    }
    return $clones;
}

sub attach_analysis_objects_and_transform_to_slice {
    my ($dba, $slice, $sf_list) = @_;

    my $analysis_adaptor = $dba->get_AnalysisAdaptor;

    my (%logic_ana);

    for (my $i = 0 ; $i < @$sf_list ; $i++) {

        my $sf         = $sf_list->[$i];
        my $class      = ref($sf);
        my $logic_name = $sf->analysis->logic_name;

        my $ana = $logic_ana{$logic_name} ||=
          $analysis_adaptor->fetch_by_logic_name($logic_name);

        $sf->analysis($ana);
        $sf->contig($slice);

        my @mapped = $sf->transform;

        if (@mapped == 1) {
            unless ($mapped[0]->isa($class)) {
                $server->error_exit("Error, got '$mapped[0]' from transform");
            }
            $sf_list->[$i] = $mapped[0];
        }
        else {
            $server->error_exit("transform returned " . scalar(@mapped) . " features: (@mapped)");
        }
    }
}

sub transform_assembly_tag_coordinates {
    my ($slice, $sets) = @_;

    my $new_sets = [];

    foreach my $at (@$sets) {

        $at->contig($slice);
        my @mapped = $at->transform;

        if (@mapped == 1) {
            unless ($mapped[0]->isa(ref($at))) {
                $server->error_exit( "Error, got '$mapped[0]' from transform, which is not a " . ref($at));
            }

   # $mapped[0]->{_seqname} is contig_id,    # $mapped[0]->seqname : contig_name

            $at->contig_id($mapped[0]->{_seqname});
            $at->tag_info($mapped[0]->tag_info);
            $at->tag_type($mapped[0]->tag_type);
            push(@$new_sets, $at);
        }
        else {

            # can't deal with assembly tags mapped to > 1 contig
            $server->error_exit("transform returned " . scalar(@mapped) . " AssemblyTag: (@mapped)");
        }
    }
    return $new_sets;
}

sub strip_incomplete_genes {
    my ($gene_list) = @_;
    my $truncated_flag;
    for (my $i = 0 ; $i < @$gene_list ;) {
        my $gene = $gene_list->[$i];
        my $gene_name;
        if ($odba->isa('Bio::Otter::DBSQL::DBAdaptor')) {
            $truncated_flag = $gene->gene_info->truncated_flag;
            $gene_name      = $gene->gene_info->name->name;
        }
        elsif ($odba->isa('Bio::Vega::DBSQL::DBAdaptor')) {
            $truncated_flag = $gene->truncated_flag;
            my $gene_name_att = $gene->get_all_Attributes('name');
            $gene_name = $gene_name_att->[0]->value;
        }
        if ($truncated_flag) {
            $server->log("Splicing out incomplete gene $gene_name");
            splice(@$gene_list, $i, 1);
            next;
        }
        else {
            $i++;
        }
    }
}

1;

