#!/usr/local/bin/perl -w

my $pipehead = $ENV{PIPEHEAD}; # is set by the server for any GET/POST request

use OtterDefs;
use strict;
use Bio::Otter::ServerQuery;
use Bio::Otter::AnnotationBroker;
use Bio::Otter::Converter;
use Bio::Otter::Lace::TempFile;
use Bio::Otter::CloneLockBroker;
use Bio::Vega::Transform::Otter;
use Bio::Otter::ServerSide qw(:all);
use Bio::Vega::Transform::XML;
use Bio::Vega::ContigLockBroker;
####################################################################
################ COMMON POST CGI SCRIPT BEGIN ######################
####################################################################

$| = 1;
my $sq = Bio::Otter::ServerQuery->new('dataset','data', 'author', 'email', 'unlock',);
set_nph($sq);
server_log("******* Starting to write region *********");

my $odb    = get_DBAdaptor_from_CGI_species($sq, $OTTER_SPECIES,$pipehead);
my $author = get_Author_from_CGI($sq,$pipehead);
my $auth_name = $author->name;

####################################################################

my $xml_data  = $sq->getarg('data') || error_exit($sq, "No xml data entered. Can't write region");

server_log("Length of data " . length($xml_data) );

my $tmp_xml = Bio::Otter::Lace::TempFile->new;

$tmp_xml->root('/tmp');
$tmp_xml->name(qq`write_region_${auth_name}.xml`);
my $tmp_xml_name = $tmp_xml->full_name();

server_log("Writing xml to tmp file [$tmp_xml_name]");

my $xml_fh = eval{
  $tmp_xml->write_file_handle();
} || error_exit($sq, "Can't write to '$tmp_xml_name' : $!");

print $xml_fh $xml_data;

# Save a bit of memory
$xml_data = undef;

server_log("Converting xml to otter...");
my $fh = $tmp_xml->read_file_handle();

####################################################################
################ COMMON POST CGI SCRIPT _END_ ######################
####################################################################


my( $genes,
    $slice,			# The slice is fetched from the database by XML_to_otter
    $path,
    $new_feature_set,		# Arrayref of SimpleFeature objects
    $new_assembly_tag_set,	# Arrayref of AssemblyTag objects
    $chrname, $chrstart, $chrend,
  );

my $path_as_XML;

if ($odb->isa('Bio::Otter::DBSQL::DBAdaptor')) {

eval {
  my( $seqstr );		# Don't need outside block
  ($genes, $slice, $seqstr, $path, $new_feature_set, $new_assembly_tag_set) =
    Bio::Otter::Converter::XML_to_otter($fh, $odb);
  error_exit($sq, "no path from XML")    unless  $path;
  error_exit($sq, "empty path from XML") unless @$path;
  $chrname  = $slice->chr_name;
  $chrstart = $slice->chr_start;
  $chrend   = $slice->chr_end;
  $path_as_XML = Bio::Otter::Converter::path_to_XML($chrname, $chrstart, $chrend, $slice->assembly_type, $slice->get_tiling_path);
  server_log("Processed incoming xml file with slice: [$chrname] [$chrstart] [$chrend]"); 
};

if ($@) {
  error_exit($sq, "Failed converting XML [$genes,$chrname,$chrstart,$chrend] to otter [$@]");
}

server_log("Done converting.");
server_log("Found ". scalar(@$genes) ." genes on slice [$chrname] [$chrstart] [$chrend]");
my $cb = new Bio::Otter::CloneLockBroker($odb);
server_log("Checking region is locked...");
eval {
  $cb->check_locks_exist_by_slice($slice, $author);
};
error_exit($sq, "Failed checking locks [$@]") if $@;
server_log("Done checking region is locked.");
strip_incomplete_genes($genes);

# Get stable IDs for any genes, transcripts, translations and exons that don't have them
my $sida = $odb->get_StableIdAdaptor();
foreach my $gene (@$genes) {
    $sida->fetch_new_stable_ids_for_Gene($gene);
}
my $ab = new Bio::Otter::AnnotationBroker($odb);
$ab->current_author($author);
my $oaga = $odb->get_GeneAdaptor();
$odb->assembly_type($slice->assembly_type);
my $anal;
eval {
  $anal = $odb->get_AnalysisAdaptor()->fetch_by_logic_name('otter');
};
if ($@) {
  error_exit($sq, "Failed fetching analysis [$@]");
}
if (!defined($anal)) {
  error_exit($sq, "No analysis object associated with otter");
}
my $dbgenes;
server_log("Fetching database genes for comparison...");
eval {
  $dbgenes = $oaga->fetch_by_Slice($slice);
  strip_incomplete_genes($dbgenes);
};
if ($@) {
  error_exit($sq, "Failed fetching genes [$@]");
}
server_log("Done fetching database genes.");
foreach my $gene (@$genes) {
  $gene->analysis($anal);
}
# These lines force loads from the database to stop attempted lazy
# loading during the write
eval {
  foreach my $gene (@$dbgenes) {
    my $transcripts = $gene->get_all_Transcripts;
    foreach my $tran (@$transcripts) {
      $tran->translation;
      if ($tran->translation) {
		  $tran->translation->stable_id;
      }
      $tran->stable_id;
      my $exons =  $tran->get_all_Exons;
      foreach my $exon (@$exons) {
        $exon->stable_id;
      }
    }
  }
};

if ($@) {
  error_exit($sq, "Failed fully loading genes before write [$@]");
}
my( @gene_events, @changed_clones );
server_log("Comparing ". scalar(@$dbgenes) ." old to ". scalar(@$genes) ." new gene(s)... ");
my( $del_sf, $save_sf, $del_at, $save_at );
eval {
  server_log("New clones");
  my $new_clones = clones_from_path($path);
  server_log("Old clones");
  my $old_clones = clones_from_path($slice->get_tiling_path);
  @gene_events = $ab->compare_genes($dbgenes, $genes);
  @changed_clones = $ab->compare_clones($old_clones, $new_clones);
  # $slice was fetched from the database by XML_to_otter, so we can simply:
  my $old_feature_set = $slice->get_all_SimpleFeatures;
  ($del_sf, $save_sf) = $ab->compare_feature_sets($old_feature_set, $new_feature_set);
  my $atag_Ad = $odb->get_AssemblyTagAdaptor;
  # $atags_Ad in inherits from Bio::EnsEMBL::DBSQL::BaseFeatureAdaptor,
  # which inherits from Bio::EnsEMBL::DBSQL:BaseAdaptor
  # This also allows fetching AssemblyTag features by passing a RowContig obj
  my $old_assembly_tag_set = $atag_Ad->fetch_all_by_Slice($slice);
  ($del_at, $save_at) = $ab->compare_assembly_tag_sets($old_assembly_tag_set, $new_assembly_tag_set);
};
if ($@) {
  error_exit($sq, "Failed comparing annotations [$@]");
}
server_log("Done compating old genes to new ones.");

# the magic happens!
my ($outputstr, $output_xml);
eval {
  $odb->begin_work();
  server_log("Found ". scalar(@gene_events) ." changed gene annotations");
  foreach my $event ( @gene_events ) {
    $outputstr .= $event->to_string;
    server_log($event->to_string);
    my $gene;
    if ($event->type eq 'deleted') {
      $gene = $event->old_gene;
    } else {
      $gene = $event->new_gene;
    }
    # attach_to_Slice transforms exons to contig coordinates.
    # Need to save the original coordinates for the response XML.
    my( %exon_start_end_strand );
    foreach my $exon (@{$gene->get_all_Exons}) {
        my $stable = $exon->stable_id || error_exit($sq, "Missing exon stable ID");
        $exon_start_end_strand{$stable} = [$exon->start, $exon->end, $exon->strand];
    }
    server_log("Attaching gene to slice ". $gene->stable_id ." ". $gene->version );
    $oaga->attach_to_Slice($gene,$slice);
    $gene->detach_DBAdaptors;
    server_log("Done attaching");
    $oaga->store($gene);
    # Restore the pre-transform exon coordinates
    foreach my $exon (@{$gene->get_all_Exons}) {
        my $stable = $exon->stable_id || error_exit($sq, "Missing exon stable ID");
        my $ses = $exon_start_end_strand{$stable}
            or error_exit($sq, "Couldn't get pre-transformed coordinates for exon '$stable'");
        my ($start, $end, $strand) = @$ses;
        $exon->start($start);
        $exon->end($end);
        $exon->strand($strand);
    }
    $output_xml .= $gene->toXMLString() unless $event->type eq 'deleted';
    server_log("Stored gene");
    $outputstr .= " " . $gene->version . " " . $gene->gene_info->name->name . "";
  }
  my $oaca = $odb->get_CloneAdaptor;
  foreach my $clone (@changed_clones) {
    my $acc = $clone->embl_id;
    my $sv  = $clone->embl_version;
    server_log("Storing new version of clone '$acc.$sv'");
    my $db_clone = $oaca->fetch_by_accession_version($acc, $sv);
    $db_clone->clone_info($clone->clone_info);
    $oaca->store($db_clone);
  }
  # Store SimpleFeature changes
  my $sfa = $odb->get_SimpleFeatureAdaptor;
  if (@$del_sf) {
    foreach my $sf (@$del_sf) {
      $sfa->remove($sf);
    }
    server_log("Deleting ".scalar(@$del_sf)." SimpleFeatures") unless $@;
  }
  if (@$save_sf) {
    attach_analysis_objects_and_transform_to_slice($odb, $slice, $save_sf);
    $sfa->store(@$save_sf);
    server_log("Saving ".scalar(@$save_sf)." SimpleFeatures") unless $@;
  }
  # Store Assembly_tags changes
  my $atag_Ad = $odb->get_AssemblyTagAdaptor;
  if (@$del_at) {
    $atag_Ad->remove($del_at);
    server_log("Deleting ".scalar(@$del_at)." AssemblyTags") unless $@;
  }
  if (@$save_at) {
    my $c_save = transform_assembly_tag_coordinates($slice, $save_at);
    $atag_Ad->store($c_save);
    server_log("Saving ".scalar(@$c_save)." AssemblyTags") unless $@;
  }
  $odb->commit();
};
if ($@) {
  error_exit($sq, "Failed writing annotations [$@]");
}
$outputstr ||= "No changes to annotations";
$output_xml = $path_as_XML . $output_xml ;
send_response($sq, $output_xml, 1);
}

elsif ($odb->isa('Bio::Vega::DBSQL::DBAdaptor')) {

  ##trying to store in a new Otter db
  ##Parse the xml file

  my $parser;
  eval {
	 $parser = Bio::Vega::Transform::Otter->new;
	 $parser->parsefile($tmp_xml_name);
  };
  if ($@){
	 error_exit($sq, "Failed converting XML to otter [$@]");
  }

  # check that the assembly is already loaded in the database and
  # is consistent with the current xml assembly

  my ($slice,$chr_ctg,$cs,$segment_name,$start,$end,$strand,$cs_version);
  my %xmlfrag;
  eval {
	 $cs='chromosome';
	 my $chr_slice=$parser->get_ChromosomeSlice;
	 $start=$chr_slice->start;
	 $end=$chr_slice->end;
	 $strand=$chr_slice->strand;
	 $cs_version=$parser->init_CoordSystem_Version;
	 $segment_name=$parser->get_AssemblyType->{'assembly_type'};
	 $slice =  $odb->get_SliceAdaptor()->fetch_by_region($cs,$segment_name,$start,$end,$strand,$cs_version);
	 my $slice_projection = $slice->project('contig');
	 my $xml_slice=$parser->get_AssemblySlices;
	 $chr_ctg = $xml_slice->{'chr_ctg'};

	 foreach my $piece (@$chr_ctg) {
		my $xml_ctg_slice = $piece->[1];
		my $ctg_name=$xml_ctg_slice->seq_region_name;
		my $ctg_start=$xml_ctg_slice->start;
		my $ctg_end=$xml_ctg_slice->end;
		$xmlfrag{$ctg_name}{start}=$ctg_start;
		$xmlfrag{$ctg_name}{end}=$ctg_end;
	 }
	 foreach my $seg (@$slice_projection) {
		my $contig_slice = $seg->to_Slice();
		my $contig_name=$contig_slice->seq_region_name;
		my $contig_start=$contig_slice->start;
		my $contig_end=$contig_slice->end;
		if ( $xmlfrag{$contig_name}){
		  if (($xmlfrag{$contig_name}{start} != $contig_start) || ($xmlfrag{$contig_name}{end} != $contig_end)){
			 error_exit($sq,"Assembly doesn't match for contig $contig_name\n");
		  }
		  $xmlfrag{$contig_name}{slice}=$contig_slice;
		}
		else {
		  error_exit($sq,"Assembly doesn't match for contig $contig_name\n");
		}
	 }
  };
  if ($@){
	 error_exit($sq,"Failed at comparing xml assembly with database assembly [$@]\n");
  }
  my $xmlstr;
  $odb->begin_work;
  eval {
	 ##check if clones are locked or not
	 my $cb = new Bio::Vega::ContigLockBroker;
	 server_log("Checking region is locked...");
	 eval {
		$cb->check_locks_exist_by_slice($slice, $author,$odb);
	 };
	 error_exit($sq, "Failed checking locks [$@]") if $@;
	 server_log("Done checking region is locked.");
	 ##update all contig_info and contig_info_attrib
	 foreach my $piece (@$chr_ctg) {
		my $ctg_attrib_list=$piece->[2];
		my $cmp_slice = $piece->[1];
		my $ctg_name=$cmp_slice->seq_region_name;
		my $ctg_author=$piece->[3];
		my $ctg_slice=$xmlfrag{$ctg_name}{slice};
		my $ctg_info_id = insert_ContigInfo_Attributes($odb,$author,$ctg_slice,$ctg_attrib_list);
		server_log("Updating contig info-attrib for ".$ctg_slice->seq_region_name);
	 }
	 ## strip_incomplete_genes for the xml genes
	 my $genes=$parser->get_Genes;
	 strip_incomplete_genes($genes);
	 ##fetch database genes and compare to find the new/modified/deleted genes
	 server_log("Fetching database genes for comparison...");
	 my $db_genes = $slice->get_all_Genes;
	 strip_incomplete_genes($db_genes);
	 server_log("Comparing ". scalar(@$db_genes) ." old to ". scalar(@$genes) ." new gene(s)... ");
	 my ($new_mod,$del) = compare_genes($db_genes,$genes);
	 my $gene_adaptor=$odb->get_GeneAdaptor;
	 server_log("Attaching gene to slice ");
	 foreach my $gene (@$new_mod){
		##attach gene and its components to the right slice
		$gene->slice($slice);
		##update author in gene and transcript
		$gene->gene_author($author);
		my $tref=$gene->get_all_Transcripts();
		foreach my $tran (@$tref) {
		  $tran->slice($slice);
		  $tran->transcript_author($author);
		  foreach my $exon (@{$tran->get_all_Exons}) {
			 $exon->slice($slice);
		  }
		}
		##update all gene and its components in db (new/mod)
		$gene_adaptor->store($gene);
	 }
	 server_log("Updated ".scalar(@$new_mod)." genes");
	 foreach my $gene (@$del){
		##attach gene and its components to the right slice
		$gene->slice($slice);
		##update author in gene and transcript
		$gene->gene_author($author);
		my $tref=$gene->get_all_Transcripts();
		foreach my $tran (@$tref) {
		  $tran->slice($slice);
		  $tran->transcript_author($author);
		  foreach my $exon (@{$tran->get_all_Exons}) {
			 $exon->slice($slice);
		  }
		}
		##update all gene and its components in db (del)
		$gene_adaptor->store($gene);
	 }
	 server_log("Deleted ".scalar(@$del)." Genes") if ($del);
	 ##update feature_sets
	 ##SimpleFeatures - deletes old features(features not in xml)
	 ##and stores the current featues in databse(features in xml)
	 my $simple_features=$parser->get_SimpleFeatures;
	 my $sfa=$odb->get_SimpleFeatureAdaptor;
	 my $db_features=$sfa->fetch_all_by_Slice($slice);
	 my ($delete,$save)=compare_feature_sets($db_features,$simple_features);
	 foreach my $del_feat (@$delete){
		$sfa->remove($del_feat);
	 }
	 server_log("Deleting ".scalar(@$delete)." SimpleFeatures") unless $@;
	 foreach my $new_feat (@$save){
		$new_feat->slice($slice);
		$sfa->store($new_feat);
	 }
	 server_log("Saving ".scalar(@$save)." SimpleFeatures") unless $@;

	 ##assembly_tags are not taken into account for here, as they are not part of annotation nor versioned ,
	 ##but may be required in the future
	 ##fetch a new slice, and convert this new_slice to xml so that
	 ##the response xml has all the above changes done in this session

	 my $new_slice =  $odb->get_SliceAdaptor()->fetch_by_region($cs,$segment_name,$start,$end,$strand,$cs_version);
	 my $slices=[];
	 push @$slices,$new_slice;
	 my $t=Bio::Vega::Transform::XML->new;
	 $xmlstr=$t->generate_OtterXML($slices,$odb,0);
  };
  if ($@){
	 error_exit($sq, "Failed writing annotations [$@]");
	 $odb->rollback;
  }
  else {
	 $odb->commit;
  }
  ##send the response
  send_response($sq,$xmlstr);
}
else {
  server_log("Require an Otter DB Adaptor and not:$odb");
}




     #-------------------------------------------
     #          S U B R O U T I N E S
     #-------------------------------------------

sub compare_feature_sets {
    my( $old_features, $new_features ) = @_;
    my %old = map {SimpleFeature_key($_), $_} @$old_features;
    my %new = map {SimpleFeature_key($_), $_} @$new_features;
    # Features that were in the old, but not the new, should be deleted
    my $delete = [];
    while (my ($key, $old_sf) = each %old) {
        unless ($new{$key}) {
            push(@$delete, $old_sf);
        }

    }
    # Features that are in the new but were not in the old should be saved
    my $save = [];
    while (my ($key, $new_sf) = each %new) {
        unless ($old{$key}) {
            push(@$save, $new_sf);
        }

    }
    return($delete, $save);
}

sub compare_genes {
  my( $old_genes, $new_genes ) = @_;
  my %old = map {$_->stable_id, $_} @$old_genes;
  my %new = map {$_->stable_id, $_} @$new_genes;
  # Genes that were in the old, but not the new, should be deleted, by setting artificially the gene type=obsolete, so that
  # the GeneAdaptor updates the database
  my $delete = [];
  my $new_mod = [];
  while (my ($key, $old_g) = each %old) {
	 #print STDERR "\noldgene:$key";
	 unless ($new{$key}) {
		$old_g->is_current(0);
		push(@$delete, $old_g);

	 }
  }
  while (my ($key, $new_g) = each %new) {
	# print STDERR "\nnewgene:$key";
	 $new_g->is_current(1);
	 push(@$new_mod,$new_g);
  }
#		die "\nTEST\n";
  return ($new_mod,$delete);
}

sub SimpleFeature_key {
    my( $sf ) = @_;
    return join('^',
        $sf->analysis->logic_name,
        $sf->start,
        $sf->end,
        $sf->strand,
        # sprintf ensures that 0.5 and 0.5000 become the same string
        sprintf('%g', $sf->score),
        $sf->display_label || '',
        );
}

sub insert_ContigInfo_Attributes {
  my ($db,$ctg_author,$ctg_slice,$ctg_attrib_list)=@_;
  my $dbc= $db->dbc();
  my $ca=$db->get_ContigInfoAdaptor();
  my $contig_info=make_ContigInfo($ctg_slice,$ctg_author,$ctg_attrib_list);
  $ca->store($contig_info);
}

sub make_ContigInfo{
  my ($ctg_slice,$author,$attributes) = @_;
  my $ctg_info = Bio::Vega::ContigInfo->new
	 (
	  -slice => $ctg_slice,
	  -author => $author,
	  -attributes => $attributes
	 );
  return $ctg_info;
}

sub clones_from_path {
  my( $path ) = @_;

  my $clones = [];
  foreach my $rawcontig (map $_->component_Seq, @$path) {
    my $clone = $rawcontig->clone;
    unless ($clone) {
      server_log("No clone attached to '". $rawcontig->idi ."'");
      next;
    }
    push(@$clones, $clone);
  }
  return $clones;
}

sub attach_analysis_objects_and_transform_to_slice {
  my( $dba, $slice, $sf_list ) = @_;

  my $analysis_adaptor = $dba->get_AnalysisAdaptor;

  my( %logic_ana );

  for (my $i = 0; $i < @$sf_list; $i++) {

    my $sf = $sf_list->[$i];
    my $class = ref($sf);
    my $logic_name = $sf->analysis->logic_name;

    my $ana = $logic_ana{$logic_name}
      ||= $analysis_adaptor->fetch_by_logic_name($logic_name);

    $sf->analysis($ana);
    $sf->contig($slice);

    my @mapped = $sf->transform;

    if (@mapped == 1) {
      unless ($mapped[0]->isa($class)) {
        error_exit($sq, "Error, got '$mapped[0]' from transform");
      }
      $sf_list->[$i] = $mapped[0];
    }
    else {
      error_exit($sq, "transform returned ".scalar(@mapped)." features: (@mapped)");
    }
  }
}

sub transform_assembly_tag_coordinates {
  my ($slice, $sets) = @_;

  my $new_sets = [];

  foreach my $at ( @$sets ) {

    $at->contig($slice);
    my @mapped = $at->transform;

    if ( @mapped == 1 ) {
      unless ( $mapped[0]->isa(ref($at)) ) {
	    error_exit($sq, "Error, got '$mapped[0]' from transform, which is not a ".ref($at));
      }

      # $mapped[0]->{_seqname} is contig_id,    # $mapped[0]->seqname : contig_name

      $at->contig_id($mapped[0]->{_seqname});
      $at->tag_info ($mapped[0]->tag_info);
      $at->tag_type ($mapped[0]->tag_type);
      push(@$new_sets, $at);
    }
    else {
      # can't deal with assembly tags mapped to > 1 contig
      error_exit($sq, "transform returned ".scalar(@mapped)." AssemblyTag: (@mapped)");
    }
  }
  return $new_sets;
}



sub strip_incomplete_genes {
  my( $gene_list ) = @_;
  my $truncated_flag;
  for (my $i = 0; $i < @$gene_list;) {
    my $gene = $gene_list->[$i];
	 my $gene_name;
	 if ($odb->isa('Bio::Otter::DBSQL::DBAdaptor')){
		$truncated_flag=$gene->gene_info->truncated_flag;
		$gene_name=$gene->gene_info->name->name;
	 }
	 elsif ($odb->isa('Bio::Vega::DBSQL::DBAdaptor')){
		$truncated_flag=$gene->truncated_flag;
		my $gene_name_att = $gene->get_all_Attributes('name') ;
		$gene_name=$gene_name_att->[0]->value;
	 }
    if ($truncated_flag) {
      server_log("Splicing out incomplete gene $gene_name");
      splice(@$gene_list, $i, 1);
      next;
    } else {
      $i++;
    }
  }
}

1;
__END__

