#!/usr/local/bin/perl -w

=head1 DESCRIPTION

test_vega_xml_parser -dbhost xxx -dbport xxx -dbname xxx -dbuser xxx -dbpass xxx -xml filename

=head1 OPTIONS

-dbhost database host

-dbport dataabse port

-dbname database name

-dbuser database user name

-dbpass database user password

-xml input otter xml file to be parsed

=cut

use strict;

use Bio::Vega::Transform::Otter;
use Bio::Vega::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Slice;
use Getopt::Long;
use Data::Dumper;


{
  my $dbhost;
  my $dbport;
  my $dbname;
  my $dbuser;
  my $dbpass;
  my $help;
  my $xmlfile;
  &GetOptions(
				  'dbhost=s'   => \$dbhost,
				  'dbport=n'   => \$dbport,
				  'dbname=s'   => \$dbname,
				  'dbuser=s'   => \$dbuser,
				  'dbpass=s'   => \$dbpass,
				  'h|help'     => \$help,
				  'xml=s'  => \$xmlfile,
				 ) or ($help = 1);
  if ($help || !defined ($dbhost) || !defined($dbport) || !defined($dbname) || !defined($dbuser) || !defined($dbpass) ||!defined($xmlfile) ) {
    exec('perldoc', $0);
  }
  my $parser = Bio::Vega::Transform::Otter->new;
  $parser->parsefile($xmlfile);
  my $db = Bio::Vega::DBSQL::DBAdaptor->new(
														  -dbname => $dbname,
														  -host   => $dbhost,
														  -user   => $dbuser,
														  -port   => $dbport,
														  -pass   => $dbpass,
														 );
  ##Let begin a transaction and do all the database changes within a trnsaction
  eval{
	 $db->begin_work();

	 ##Uncomment the following to load a new Assembly or to load into an empty database
	 ##This loads ContigInfo and its attributes.Takes care of is_current(loads a new contiginfo object and a set of attributes for the
	 ##new contiginfo, only if the contiginfo object has changed
	 $parser->LoadAssemblySlices($db);

	 ##Load genes,transcripts,translations,exons from XML - takes care of versioning
	 ##if there is a change in gene and its components then the version is incremented otherwise, not
	 my $genes=$parser->get_Genes;
	 my $gene_adaptor=$db->get_GeneAdaptor;
	 foreach my $gene (@$genes){
		$gene_adaptor->store($gene);
	 }

	 ##Load SimpleFeatures - deletes old features(features not in xml) and stores the current features in XML
	 my $simple_features=$parser->get_SimpleFeatures;
	 my $sfa=$db->get_SimpleFeatureAdaptor;
	 my $chr_slice=$parser->get_ChromosomeSlice;
	 my $new_slice=$parser->get_SliceId($chr_slice,$db);
	 my $db_features=$sfa->fetch_all_by_Slice($new_slice,'Otter');
	 my ($delete,$save)=compare_feature_sets($db_features,$simple_features);
	 foreach my $del_feat (@$delete){
		$sfa->remove($del_feat);
	 }
	 foreach my $new_feat (@$save){
		$new_feat->slice($new_slice);
		$sfa->store($new_feat);
	 }


=head2 COMMENT
	 ##Load AssemblyTag - deletes old tags(tags not in xml) and stores the current tags in the XML
	 my $assembly_tags = $parser->get_AssemblyTags;
	 my $ata=$db->get_AssemblyTagAdaptor;

	 foreach my $at (@$assembly_tags){
		my $slice;
		if ($at->contig_id) {
		  $slice=$at->slice_by_contig_id;
		}
		if ($at->contig_name){
		  $slice=$at->slice_by_contig_name;
		}
		unless($slice) {
		  print STDERR "assembly tag does not have a slice attached and hence not stored in db\n";
		  next;
		}
		$ata->store($at);
	 }


=cut
	 ##Create new XML and send as response

  };
  if ($@) {
	 $db->rollback;
	 print STDERR "\nError saving genes from file: Rolled back all data of this session - Please correct errors\n".$@;
  }
  else {
	 $db->commit;
	 print STDOUT "\nCommitted all session data from XML in database\n";
  }
  $parser->DESTROY;
}
warn "\nParser now out of scope\n";

sub compare_feature_sets {
    my( $old_features, $new_features ) = @_;

    my %old = map {SimpleFeature_key($_), $_} @$old_features;
    my %new = map {SimpleFeature_key($_), $_} @$new_features;

    # Features that were in the old, but not the new, should be deleted
    my $delete = [];
    while (my ($key, $old_sf) = each %old) {
        unless ($new{$key}) {
            push(@$delete, $old_sf);
        }
    }

    # Features that are in the new but were not in the old should be saved
    my $save = [];
    while (my ($key, $new_sf) = each %new) {
        unless ($old{$key}) {
            push(@$save, $new_sf);
        }
    }

    return($delete, $save);
}

sub SimpleFeature_key {
    my( $sf ) = @_;

    return join('^',
        $sf->analysis->logic_name,
        $sf->start,
        $sf->end,
        $sf->strand,
        # sprintf ensures that 0.5 and 0.5000 become the same string
        sprintf('%g', $sf->score),
        $sf->display_label || '',
        );
}




1;







__END__

=head1 NAME - test_vega_xml_parser

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

