#!/usr/local/bin/perl 

### otter

use strict;
use Carp;
use Hum::AnaStatus::Sequence;
use Hum::AnaStatus::EnsAnalysis;
use Bio::Otter::Lace::AceDatabase;
use Bio::Otter::Lace::Client;
use Getopt::Long 'GetOptions';
use Symbol 'gensym';

use Bio::EnsEMBL::Ace::DataFactory;
use Bio::EnsEMBL::Ace::Filter::RepeatMasker;
use Bio::EnsEMBL::Ace::Filter::CpG;
use Bio::EnsEMBL::Ace::Filter::DNA;
use Bio::EnsEMBL::Ace::Filter::TRF;
use Bio::EnsEMBL::Ace::Filter::Gene::Halfwise;
use Bio::EnsEMBL::Ace::Filter::Gene;
use Bio::EnsEMBL::Ace::Filter::Gene::Predicted;
use Bio::EnsEMBL::Ace::Filter::Similarity;
use Bio::EnsEMBL::Ace::Filter::Similarity::DnaSimilarity;
use Bio::EnsEMBL::Ace::Filter::Similarity::ProteinSimilarity;
use Bio::EnsEMBL::Ace::Filter::SimpleFeature;

use Hum::EnsCmdLineDB;

# for use of submissions database, link with ana_notes
use Hum::Submission qw{ acetime prepare_statement submission_disconnect submission_user};
use Hum::AnaStatus qw{ list_active_tasks annotator_full_name };
use Hum::AnaStatus::Sequence;
use Hum::AnaStatus::EnsAnalysis;
use Hum::AnaStatus::EnsAnalysisDB;
use Hum::SubmissionVersion;

# global flag for debug
my $opt_d;

{   
    my $usage = sub{ exec('perldoc', $0) };

    # connect to submissions database

    # get the machine/port for access to otter

    my $host = 'ecs1d';
    my $port = 39312;
    my $ace_tar = '/nfs/team71/analysis/jgrg/work/ace_skeleton/lace_acedb.tar';
    if($ENV{"LACE_LOCAL"}){
	$ace_tar=$ENV{"LACE_LOCAL"}."/lace_acedb.tar";
    }
    my $recover = '';
    my $write_flag  = 0;
    my $unlock_flag = 0;

    # parameters passed by ana_notes
    # user (to allow getpwuid to be overridden)
    my($user);
    # set_name (from ana_notes)
    my($set_name);
    my($path);
    my $open_spandit=1;
    my $multiple_slices=1;
    
    GetOptions(
        'view'      => sub{ $write_flag = 0 },
        'host=s'    => \$host,
        'port=i'    => \$port,
        'tar=s'     => \$ace_tar,
        'h|help'    => $usage,
        'write!'    => \$write_flag,
        'recover=s' => \$recover,
        'unlock!'   => \$unlock_flag,
	'user=s'    => \$user,
        'set=s'     => \$set_name,
	'path=s'    => \$path,
	'spandit!'  => \$open_spandit,
	'debug|d'   => \$opt_d,
         ) or $usage->();
    die "Can't specify both write and unlock\n"
        if $unlock_flag and $write_flag;

    # check global access to database
    exit 0 unless Hum::SubmissionVersion::check_version();
    
    # create closure containing user, referred to from Submission::get_user
    $user=submission_user($user);

    # create subroutine that call be called from anywhere to return
    # user
    #{
	#sub main_user {
	    #return $user;
	#}
    #}

    # from list of clones, create objects to get accessions, ensdb etc.
    my @accessions=@ARGV;
   
    # use submissions to get otterdb, host, port from set_name
    # needed even for a 'recover'
    my $otter_db_name;
    ($otter_db_name,$host,$port)=get_otter_db_name($set_name);

    my $cl = Bio::Otter::Lace::Client->new;
    $cl->host($host);
    $cl->port($port);
    $cl->write_access($write_flag);
    
    my $db = $cl->new_AceDatabase;
    $db->title('lace test');
    # set error flag - only gets removed if all goes well!
    $db->error_flag(1);
    $db->tar_file($ace_tar);

    if ($recover) {
        $db->home($recover);
        $db->recover_slice_dataset_hash;
    } else { 

        my $ds = $cl->get_DataSet_by_name($otter_db_name);
        
        my $cs_list = $ds->get_all_CloneSequences;

	# find extent of selected clones
	# (build a slice containing any unselected clones)
	my $ist=-1;
	my $ied=-1;
	my $first=0;
	my %accessions=map{$_,1}@accessions;
	for(my $i=0;$i<scalar(@$cs_list);$i++){
	    my $acc=$cs_list->[$i]->accession;
	    if($accessions{$acc}){
		unless($first){
		    $ist=$i;
		    $first=1;
		}
		$ied=$i;
	    }
	}
	die "None of accessions passed to otter found in slice" if $ist==-1 || $ied==-1;

        $ds->selected_CloneSequences([@$cs_list[$ist..$ied]]);
        #$ds->selected_CloneSequences([@$cs_list[3..4]]);
        #$ds->selected_CloneSequences([@$cs_list[6..6]]);

	# get ensdb database handle for slice, based on pipeline for each clone
	# checking that all clones point to same ensdb pipeline db
	my $ens_pipe_db;
	my @ens_gene_db;
	{

	    # get full list of accessions to define @prop
	    my @prop;
	    foreach my $cs (@$cs_list[$ist..$ied]){
		my $pr={};
		$pr->{'accession'}=$cs->accession;
		$pr->{'sv'}=$cs->sv;
		push(@prop,$pr);
	    }

	    my $ensdb_id;
	    my $acc_anaseq=get_anastatus_sequences(@prop);
	    foreach my $acc (keys %$acc_anaseq) {
		my $seq=$$acc_anaseq{$acc};
		my $name=$seq->full_sequence_name;
		my @ens_ana = Hum::AnaStatus::EnsAnalysis
		    ->fetch_all_complete_for_ana_seq_id($seq->ana_seq_id);
		print "WARN multiple pipeline entries for $name\n" if scalar(@ens_ana)>1;
		my $ensdb_id_new=$ens_ana[0]->ensembl_db_id;
		if($ensdb_id){
		    if($ensdb_id ne $ensdb_id_new){
			die "FATAL $acc connected to different ensembl database";
		    }
		}else{
		    $ensdb_id=$ensdb_id_new;
		    $ens_pipe_db = $ens_ana[0]->get_EnsAnalysisDB;
		    $ens_ana[0]->species_name($seq->species_name);
		    @ens_gene_db = $ens_ana[0]->get_SpeciesGeneBuildDB;
		}
		print "DEBUG: got $acc: $ensdb_id\n" if $opt_d;
	    }
	}
        
	print "DEBUG: $set_name: $otter_db_name, $host, $port\n" if $opt_d;
	print "DEBUG: ".join(',',@accessions)." $ist-$ied\n" if $opt_d;

	$db->make_database_directory;
        $db->write_otter_acefile;
        
	### Fetch data for CloneSequences
        fetch_sanger_data($ds, $db, $ens_pipe_db);
        #debug_print_sequence($ds, $db);

	### Fetch ensembl genes (may fail since db might not be there)
	eval{
	    fetch_ensembl_data($ds, $db, @ens_gene_db);
	};
	if($@){
	    print "Warn: could not connect to Ensembl gene prediction databases\n";
	    if($opt_d){
		print $@."\n";
	    }
	}

	### Use one of ensdbs to disconnect
	$ens_pipe_db->disconnect_all_ensembl_dbs;
	#exit 0;

        unless ($db->initialize_database) {
            die "Error initialzing database";
        }
    }
    
    if ($unlock_flag) {
        $db->unlock_all_slices;
    } else {

	### spandit - the new sequence coordinate editor
	fork_spandit($db->home) if $write_flag or $open_spandit;
	
	######### LAUNCH XACE ON DATABASE #########
        system('xace', $db->home);
    }

    if ($write_flag) {
        $db->save_all_slices;
    }

    #my $mw = CanvasWindow::MainWindow->new('Otter: datasets');
    #my $cw = CanvasWindow->new($mw, 400, 300);
    #
    #my $datasets = get_dataset_details($host, $port);
    #set_details($datasets);
    #show_dataset_list($cw, $datasets);
    #$cw->canvas->toplevel->bind( '<Return>', sub{ do_fetch($cw) } );
    #
    #$cw->fix_window_min_max_sizes;
    #Tk::MainLoop();
    
    $db->error_flag(0);     # OK to cleanup now
}


##  creates a data factory and adds all the appropriate filters to
##  it. It then produces a slice from the ensembl db (using the
##  $dataset coords) and produces output based on that slice in
##  ensembl.ace
sub fetch_ensembl_data{
    my($dataset,$acedb,@ensdb)=@_;

    # create file for output and add it to the acedb object
    my $ace_file = $acedb->home . "/rawdata/ensembl.ace";
    my $fh = gensym();
    open $fh, "> $ace_file" or confess "Can't write to '$ace_file' : $!";
    $acedb->add_acefile($ace_file);

    # loop over databases containing genes
    foreach my $ensdb (@ensdb){
	my $ens_db=$ensdb->db_adaptor;
	my $type=$ensdb->golden_path_type;
	# later on will have to get chromsome names...not proper way to do it
	my $ch=get_all_ensembl_chromosome_names($ens_db);

	my $factory = Bio::EnsEMBL::Ace::DataFactory->new;
	my $ana_adaptor = $ens_db->get_AnalysisAdaptor or die "analysis adaptor";
	## Gene_Builder
	my $ensembl = Bio::EnsEMBL::Ace::Filter::Gene->new;
	$ensembl->analysis_object( $ana_adaptor->fetch_by_logic_name('ensembl') );
	$factory->add_AceFilter($ensembl);
	## EST_GeneBuilder
	my $genomewise = Bio::EnsEMBL::Ace::Filter::Gene->new;
	$genomewise->analysis_object( $ana_adaptor->fetch_by_logic_name('genomewise') );
	$factory->add_AceFilter($genomewise);

	my $slice_adaptor = $ens_db->get_SliceAdaptor();

	my $sel = $dataset->selected_CloneSequences_as_contig_list;
	# unlike sanger (pipeline) databases, where data is clone based, 
	# in this case we need to deal with slice as a whole

	# Slightly smarter than rejecting entire slice if anything
	# different.  Is able to build a subslice if beginning or end
	# is incorrect, but can't build multiple subslices (all kinds
	# of duplicate partial gene problems could result in such
	# cases).

	# Since locally the agp could be correct, but globally wrong
	# has to deal with clone order walking in the wrong direction

	# Various patalogical cases are not dealt with optimally.  If
	# A matches; B doesn't but C, D, E and F match, will make a
	# subslice out of A.  Could be handelled, but would require a
	# double pass.

	foreach my $cs (@$sel) {

	    my $otter_slice_name;
	    {
		# need to get name of slice in otter space (fetch from ensembl
		# will be in a different coordinate space, but because of
		# checks they are guarenteed to be equivalent)
		
		my $first_ctg = $cs->[0];
		my $last_ctg = $cs->[$#$cs];
              
		my $chr = $first_ctg->chromosome->name;  
		my $chr_start = $first_ctg->chr_start;
		my $chr_end = $last_ctg->chr_end;
		$otter_slice_name="$chr.$chr_start-$chr_end";
	    }

	    # check if agp of this DB is in sync for the selected clones
	    # dump if in sync, else skip
	    my $off=0;
	    my $first=-1;
	    my $first_dir;
	    my $last;
	    my $last_edge;
	    my $nc=scalar(@$cs);
	    my $slice_start;
	    my $slice_end;
	    my $fail;
	    my $chr;
	    for(my $i=0;$i<$nc;$i++){
		my $ctg=$$cs[$i];
		
		my $ens_ctg_set=get_ensembl_contigs_by_sv($ens_db,$ch,
							  $ctg->accession,$ctg->sv,$type);
		my $pass=0;
		# should get only one match (present, but not unfinished)
		if(scalar(@$ens_ctg_set)==1){
		    my $ens_ctg=$ens_ctg_set->[0];
		    # check if same part of contig is part of external agp
		    if($ens_ctg->contig_start==$ctg->contig_start &&
		       $ens_ctg->contig_end==$ctg->contig_end
		       ){
			print "DEBUG: same contig used\n" if $opt_d;
			# if first clone, save; else check order is still ok
			if($first>-1){
			    $fail=1;
			    # check sequential
			    if($i=$last+1){
				# check consistent direction
				my $this_dir=-1;
				if($ens_ctg->contig_strand==$ctg->contig_strand){
				    $this_dir=1;
				}
				if($first_dir==$this_dir){
				    # check agp consecutive
				    if($first_dir==1 && $ens_ctg->chr_start==$last_edge+1){
					$last=$i;
					$last_edge=$ens_ctg->chr_end;
					$slice_end=$ens_ctg->chr_end;
					$fail=0;
				    }elsif($first_dir==-1 && $ens_ctg->chr_end==$last_edge-1){
					# -ve direction not handled...so
					confess "ERR: should never get here!!";
				    }
				}
			    }
			}else{
			    print "DEBUG: saved first $i\n" if $opt_d;
			    $first=$i;
			    $last=$i;
			    $chr=$ens_ctg->chromosome->name;  
			    if($ens_ctg->contig_strand==$ctg->contig_strand){
				# same direction
				$last_edge=$ens_ctg->chr_end;
				$slice_start=$ens_ctg->chr_start;
				$slice_end=$ens_ctg->chr_end;
				$first_dir=1;
			    }else{
				$last_edge=$ens_ctg->chr_start;
				$slice_start=$ens_ctg->chr_end;
				$slice_end=$ens_ctg->chr_start;
				$first_dir=-1;
				# reverse direction

				# FIXME temporary:
				print "WARN: agp is in reverse direction";
				print " - not currently handled\n";
				$first=-1;

			    }
			}
		    }
		}
		# right now, if $first not set for $i=0 can't continue
		if($i==0 && $first==-1){$fail=1;}
		# once started a slice with first, if fail then no point checking further
		last if $fail;
	    }
	    # if something was saved
	    if($first>-1){
		print "DEBUG: Fetching slice $first:$slice_start-$last:$slice_end\n" if $opt_d;
		my $slice = $slice_adaptor->fetch_by_chr_start_end($chr, $slice_start, $slice_end);
		$slice->name($otter_slice_name);
		print $fh $factory->ace_data_from_slice($slice);
	    }
	}
    }
    close $fh;
}

sub get_all_ensembl_chromosome_names{
    my($dba)=@_;
    my($ch);
    my $sth = $dba->prepare(q{
	SELECT chromosome_id
	    , name
	    , length
	FROM chromosome
	});
    $sth->execute;
    my( $chr_id, $name, $length );
    $sth->bind_columns(\$chr_id, \$name, \$length);
        
    while ($sth->fetch) {
	my $chr = Bio::Otter::Lace::Chromosome->new;
	$chr->chromosome_id($chr_id);
	$chr->name($name);
	$chr->length($length);
	push(@$ch, $chr);
    }
    return($ch);
}

# look for contigs for this sv
sub get_ensembl_contigs_by_sv{
    my($dba,$ch,$acc,$sv,$type)=@_;
    print "DEBUG: checking $acc,$sv,$type\n" if $opt_d;
    my %id_chr = map {$_->chromosome_id, $_} @$ch;
    my $sth = $dba->prepare(q{
        SELECT a.chromosome_id
          , a.chr_start
          , a.chr_end
          , a.contig_start
	  , a.contig_end
          , a.contig_ori
	FROM assembly a
	  , clone cl
	  , contig c
        WHERE cl.name= ?
          AND cl.embl_version= ?
	  AND cl.clone_id=c.clone_id
	  AND c.contig_id=a.contig_id
          AND a.type = ?
        });
    $sth->execute($acc,$sv,$type);
    my( $chr_id,
	$chr_start, $chr_end,
	$contig_start, $contig_end, $strand );
    $sth->bind_columns( \$chr_id,
			\$chr_start, \$chr_end,
			\$contig_start, \$contig_end, \$strand );
    my $cs;
    while ($sth->fetch) {
	my $cl=Bio::Otter::Lace::CloneSequence->new;
	#$cl->accession($acc);
	#$cl->sv($sv);
	#$cl->length($ctg_length);
	$cl->chromosome($id_chr{$chr_id});
	$cl->chr_start($chr_start);
	$cl->chr_end($chr_end);
	$cl->contig_start($contig_start);
	$cl->contig_end($contig_end);
	$cl->contig_strand($strand);
	#$cl->contig_name($ctg_name);
	push(@$cs, $cl);
	print "DEBUG: $chr_start-$chr_end; $contig_start-$contig_end\n" if $opt_d;
    }
    return $cs;
}

##  creates a data factory and adds all the appropriate filters to it. It then produces a slice from
##  the  ensembl db (using the $dataset coords) and produces output based on that slice in sanger.ace 
sub fetch_sanger_data {
    my( $dataset, $acedb, $ensdb ) = @_;

    my $percent_identity_cutoff = undef; ## change this if a cutoff value is reqired


    # create new datafactory object - cotains all ace filters and produces the data from these
    my $factory = Bio::EnsEMBL::Ace::DataFactory->new;       
   

   ##----------code to add all of the ace filters to data factory-----------------------------------
    my $ens_db=$ensdb->db_adaptor;

    ## get analysis adaptor
    my $ana_adaptor = $ens_db->get_AnalysisAdaptor or die "analysis adaptor";
    
    ##create and add a DNA filter
    my $DNAfilt = Bio::EnsEMBL::Ace::Filter::DNA->new;
    $DNAfilt->analysis_object($ana_adaptor->fetch_by_logic_name('SubmitContig'));
    $factory->add_AceFilter($DNAfilt);
    
    ##repeat masker
    my $repeat_masker = Bio::EnsEMBL::Ace::Filter::RepeatMasker->new;  
    $repeat_masker->analysis_object( $ana_adaptor->fetch_by_logic_name('RepeatMask'));
    $factory->add_AceFilter($repeat_masker);
    
    ##predicted  genscan
    my $genscan = Bio::EnsEMBL::Ace::Filter::Gene::Predicted->new;
    $genscan->analysis_object( $ana_adaptor->fetch_by_logic_name('genscan') );
    $factory->add_AceFilter($genscan);
    
    ##fgenesh
    my $fgenesh = Bio::EnsEMBL::Ace::Filter::Gene::Predicted->new;
    $fgenesh->analysis_object( $ana_adaptor->fetch_by_logic_name('Fgenesh') );
    $factory->add_AceFilter($fgenesh); 
    
    #halfwise
    my $halfwise = Bio::EnsEMBL::Ace::Filter::Gene::Halfwise->new;
    $halfwise->url_string('http\\:\\/\\/www.sanger.ac.uk\\/cgi-bin\\/Pfam\\/getacc?%s');   ##??is this still correct?
    $halfwise->analysis_object( $ana_adaptor->fetch_by_logic_name('Pfam'));
    $factory->add_AceFilter($halfwise);
    
    #CpG
    my $CpG_filter = Bio::EnsEMBL::Ace::Filter::CpG->new;
    $CpG_filter->analysis_object ($ana_adaptor->fetch_by_logic_name('CpG') ); 
    $factory->add_AceFilter($CpG_filter);
    
    #trf
    my $trf =Bio::EnsEMBL::Ace::Filter::TRF->new;
    $trf ->analysis_object ($ana_adaptor->fetch_by_logic_name('trf'));
    $factory->add_AceFilter($trf);
    

## big list for DNASimilarity / Protein_similarity

## note: most of the list here is taken from the previous version, 
## currently only the uncommented ones seem to be in the database   
    my %logic_tag_method = (
        'Est2Genome'        => [qw{             EST_homol  EST_eg           }],
#        'Est2Genome_human'  => [qw{             EST_homol  EST_eg-human     }],
#        'Est2Genome_mouse'  => [qw{             EST_homol  EST_eg-mouse     }],
#        'Est2Genome_other'  => [qw{             EST_homol  EST_eg           }],
#        'Full_dbGSS'        => [qw{             GSS_homol  GSS_eg           }],
#        'Full_dbSTS'        => [qw{             STS_homol  STS_eg           }],
#        'sccd'              => [qw{             EST_homol  egag             }],
#        'riken_mouse_cdnal' => [qw{             EST_homol  riken_mouse_cdna }],
#        'primer'            => [qw{             DNA_homol  primer           }],
        'vertrna'           => [qw{ vertebrate_mRNA_homol  vertebrate_mRNA  }],
        'Swall'             => [qw{             Pep_homol  BLASTX           }],
#        'zfishEST'          => [qw{             EST_homol  EST_eg-fish      }],
        );
        
    foreach my $logic_name (keys %logic_tag_method) {
        if (my ($ana) = $ana_adaptor->fetch_by_logic_name($logic_name)) {
            my( $tag, $meth ) = @{$logic_tag_method{$logic_name}};
            my $sim = Bio::EnsEMBL::Ace::Filter::Similarity::DnaSimilarity->new;
            $sim->analysis_object($ana);
            $sim->homol_tag($tag);
            $sim->method_tag($meth);
            $sim->hseq_prefix('Em:') unless $logic_name eq 'Swall';
            if ( defined($percent_identity_cutoff) ) {
                $sim->percent_identity_cutoff($percent_identity_cutoff);
            }
            $factory->add_AceFilter($sim);
#            warn 'logic_tag:' , $tag , "\n" ;
        }
        else{
            warn "problem with the DNA Similarity filter";
        }
    }
    
    
    ## protein similarity
    my $homol = 'swall';
     
    my $prot_sim = Bio::EnsEMBL::Ace::Filter::Similarity::ProteinSimilarity->new();
    $prot_sim->analysis_object($ana_adaptor->fetch_by_logic_name($homol));
    $prot_sim->homol_tag($homol);
    $prot_sim->method_tag('BLASTX');
    if( defined($percent_identity_cutoff)  ){
        $prot_sim->percent_identity_cutoff($percent_identity_cutoff);
    }
    $factory->add_AceFilter($prot_sim);    
   
    
   ##--------------------------------------------------------------------------------- 
    
    
    # create file for output and add it to the acedb object
    my $ace_file = $acedb->home . "/rawdata/sanger.ace";
    my $fh = gensym();
    open $fh, "> $ace_file" or confess "Can't write to '$ace_file' : $!";
    $acedb->add_acefile($ace_file);


    my $slice_adaptor = $ens_db->get_SliceAdaptor();
    
    # note: the next line returns a 2 dimensional array (not a one dimensional array)
    # each subarray contains a list of clones that are together on the golden path
    my $sel = $dataset->selected_CloneSequences_as_contig_list ;
    foreach my $cs (@$sel) {
        
        my $first_ctg = $cs->[0];
        my $last_ctg = $cs->[$#$cs];
              
        my $chr = $first_ctg->chromosome->name;  
        my $chr_start = $first_ctg->chr_start;
        my $chr_end = $last_ctg->chr_end;
        
        my $slice = $slice_adaptor->fetch_by_chr_start_end($chr, $chr_start , $chr_end);
        
        print $fh $factory->ace_data_from_slice($slice);# method will also accept another argument as a percent cuttoff value
    }
    close $fh;

}




sub debug_print_sequence {
    my( $dataset, $acedb ) = @_;
    
    my $sa = $dataset->get_cached_DBAdaptor->get_SliceAdaptor;
    foreach my $ctg (@{$dataset->selected_CloneSequences_as_contig_list}) {
        my $chr_name  = $ctg->[0]->chromosome->name;
        my $start     = $ctg->[0]->chr_start;
        my $end       = $ctg->[$#$ctg]->chr_end;
        
        my $slice = $sa->fetch_by_chr_start_end($chr_name, $start, $end);
        my $file = $acedb->home . "/" . $slice->display_id . ".ace";
        my $seqfh = gensym();
        open $seqfh, "> $file" or die;
        my $humseq = Hum::Sequence->new;
        $humseq->sequence_string($slice->seq);
        $humseq->name($slice->display_id);
        print $seqfh $humseq->ace_string;
        close $seqfh;
    }
}

sub do_fetch {
    my( $cw ) = @_;
    
    my $state = get_state();
    if ($state eq 'sequences') {
        run_lace($cw);
    }
    elsif ($state eq 'datasets') {
        my ($obj) = $cw->list_selected;
        warn "No obj" and return unless $obj;
        my $prop = get_canvas_object_properties($cw, $obj);
        if (my $name = $prop->{'name'}) {
            my $details = get_details($name)
                or confess "No details for '$name'";
            draw_sequence_list($cw, $name, $details);
        } else {
            warn "No name property";
        }
    }
    else {
        confess "Unknown state '$state'";
    }
}

{
    my( @cleanup );
    
    END {
        foreach my $thing (@cleanup) {
            if ( -d $thing ) {
                rmtree( $thing, 0 );
            } else {
                unlink($thing);
            }
        }
    }

    sub run_lace {
        my( $cw ) = @_;

        my @sel = $cw->list_selected
            or return;
        my $canvas = $cw->canvas;
        my( @prop );
        foreach my $obj (@sel) {
            push(@prop, get_canvas_object_properties($cw, $obj));
        }

        ### stick this in a subroutine
        my $ctg = [];
        my @contig_list = ($ctg);
        foreach my $this (sort {$a->{'chr_start'} <=> $b->{'chr_start'}} @prop) {
            my $last = $ctg->[$#$ctg];
            if ($last) {
                if ($last->{'chr_end'} + 1 == $this->{'chr_start'}) {
                    push(@$ctg, $this);
                } else {
                    $ctg = [$this];
                    push(@contig_list, $ctg);
                }
            } else {
                push(@$ctg, $this);
            }
        }

        my $home = "/var/tmp/lace.$$";
        warn "Making lace database in '$home'\n";
        mkdir( $home, 0777 ) or die "Can't mkdir('$home') : $!\n";
        chdir($home) or die "Can't chdir ('$home') : $!";

        # List of ace files
        my $lace_files = [];
       
        # Make an empty acedb database
        make_acedb_dir_structure($home, $lace_files, 'otter');
       
        # Get annotatons and dna from otter database.
        my $name_ctg = write_otter_data($cw, $lace_files, @contig_list);
        
        # Make AnaStatus::Sequence objects
        my $acc_anaseq = get_anastatus_sequences(@prop);
        fetch_pipeline_data($lace_files, values %$acc_anaseq);
        
        write_sMap_assembly_info($name_ctg, $lace_files, $acc_anaseq);
        
        # Parse all the acefiles into the database
        my $errors = initializeDatabase( 'tace', $home, $lace_files );
        if ($errors) {
            die "Error detected parsing ace files\n";
        }
        unless ( -e 'database/ACEDB.wrm' ) {
            die "Error: Local database creation failed\n";
        }

        ### launch XaceSeqChooser here ###
        launch_XaceSeqChooser($cw, $home);
        
        ### ace to otter:
        
        ## via acedb:
        # find GenomeSequence
        # show -a
        # follow SubSequence
        # show -a
        # follow Locus
        # show -a
        
        ## or via spandit:
        # express clone subseq fetch followed by ace_string
        
        ## or to xml from spandit?
        
        ### cf Fox::Session
    }
}


sub launch_XaceSeqChooser {
    my( $cw, $home ) = @_;
    
    my $top = $cw->canvas->toplevel->Toplevel(
        -title  => "lace $home",
        );
    my $xc = MenuCanvasWindow::XaceSeqChooser->new($top);
    my %methods_mutable = (
      # Method name            Mutable?
        supported           => 1,
        supported_CDS       => 1,
        supported_mRNA      => 1,
        GD_supported        => 1,
        GD_supported_mRNA   => 1,
        Pseudogene          => 1,
        fgenesh             => 0,
        FGENES              => 0,
        GENSCAN             => 0,
        HALFWISE            => 0,
        SPAN                => 0,
        EnsEMBL             => 0,
        genomewise          => 0,
        );
    $xc->ace_path($home);
    $xc->draw_clone_list;
    $xc->set_known_GeneMethods(%methods_mutable);
    $xc->save_command(\&otter_save);
    $xc->fix_window_min_max_sizes;
}

sub fetch_pipeline_data {
    my( $lace_files, @ana_seq ) = @_;
    
    my $ens_pipe_ace = 'rawdata/enspipe_data.ace';
    push(@$lace_files, $ens_pipe_ace);

    my( @seq_names );
    foreach my $seq (@ana_seq) {
        push(@seq_names, $seq->full_sequence_name);
    }
    
    # Expect to find fetch_old_pipeline_data
    # in same dir as this script.
    my $pipe_data_fetch = 'fetch_old_pipeline_data';
    my $fetch_cmd = "$pipe_data_fetch @seq_names > $ens_pipe_ace";
    warn $fetch_cmd;
    system($fetch_cmd) == 0
        or warn "Error from '$fetch_cmd' : exit($?)";
}

sub get_anastatus_sequences {
    my( @prop ) = @_;
    
    my $acc_anaseq = {};
    foreach my $pr (@prop) {
        my $acc = $pr->{'accession'};
        my $sv  = $pr->{'sv'};
        my $ana = Hum::AnaStatus::Sequence->new_from_accession($acc);
        ### Should check sv - do so when new ana_status db is implemented
        unless ($ana) {
            warn "No AnaStatus::Sequence for '$acc'\n";
            next;
        }
        $acc_anaseq->{$acc} = $ana;
    }
    return $acc_anaseq
}

sub write_otter_data {
    my( $cw, $lace_files, @contig_list ) = @_;
    
    my $ace_file = "rawdata/otter.ace";
    push(@$lace_files, $ace_file);

    local *OTTER_ACE;
    open OTTER_ACE, "> $ace_file"
        or confess "Can't write to '$ace_file' : $!";
    my $name_ctg = {};
    foreach my $ctg (@contig_list) {
        my $name = get_otter_ctg($cw, $ctg, \*OTTER_ACE);
        $name_ctg->{$name} = $ctg;
    }
    close OTTER_ACE or confess "Error writing to '$ace_file' : $!";
    return $name_ctg;
}

sub get_otter_ctg {
    my( $cw, $ctg, $fh ) = @_;
    
    my $chr_name  = $ctg->[0]{'chr_name'};
    my $start     = $ctg->[0]{'chr_start'};
    my $end       = $ctg->[$#$ctg]{'chr_end'};
    
    my $dba = current_dba();
    my $aa = $dba->get_SliceAdaptor;
    my $vc = $aa->fetch_by_chr_start_end($chr_name, $start, $end);
    my $genes = $vc->get_all_Genes;
    my $oaga = $dba->get_AnnotatedGeneAdaptor;
    foreach my $gene (@$genes) {
        $oaga->annotate_gene($gene);
    }

    my $name = "${chr_name}_$start-$end";
    $vc->display_id($name);
    print $fh Bio::Otter::Converter::otter_to_ace($vc, $genes,
        $vc->get_tiling_path, $vc->seq);
    return $vc->display_id;
}

sub old_get_otter_ctg {
    my( $cw, $ctg, $fh ) = @_;
    
    my $chr_name  = $ctg->[0]{'chr_name'};
    my $start     = $ctg->[0]{'chr_start'};
    my $end       = $ctg->[$#$ctg]{'chr_end'};
    
    my $dba = current_dba();
    my $aa = $dba->get_SliceAdaptor;
    my $vc = $aa->fetch_by_chr_start_end($chr_name, $start, $end);
    my $genes = $vc->get_all_Genes;
    my $oaga = $dba->get_AnnotatedGeneAdaptor;
    foreach my $gene (@$genes) {
        $oaga->annotate_gene($gene);
    }

    my $name = "${chr_name}_$start-$end";
    $vc->display_id($name);
    print $fh Bio::Otter::Converter::otter_to_ace($vc, $genes,
        $vc->get_tiling_path, $vc->seq);
    return $vc->display_id;
}

sub get_canvas_object_properties {
    my( $cw, $obj ) = @_;
    
    my $canvas = $cw->canvas;
    my $prop = {};
    foreach my $tag_val ($canvas->gettags($obj)) {
        my ($tag, $val) = split /=/, $tag_val, 2;
        next unless $tag and defined($val);
        $prop->{$tag} = $val;
    }
    return $prop;
}

sub show_dataset_list {
    my( $cw, $datasets ) = @_;
    
    my $canvas = $cw->canvas;
    $canvas->delete('all');
    my $font = $cw->font;
    my $size = $cw->font_size;
    my $x = $size;
    my $incr = $size + int($size / 6);
    my @sorted_name = sort keys %$datasets;
    for (my $i = 0; $i < @sorted_name; $i++) {
        my $name = $sorted_name[$i];
        my $details = $datasets->{$name};
        my $txt = $canvas->createText(
            $x, $i * $incr,
            -text   => $sorted_name[$i],
            -font   => [$font, $size, 'bold'],
            -anchor => 'nw',
            -tags   => ["name=$name"],
            );
        $canvas->bind($txt, '<Double-Button-1>', sub{ draw_sequence_list($cw, $name, $details) });
        $canvas->bind($txt, '<Button-1>', sub{
            $cw->deselect_all;
            $cw->highlight($txt)
            });
    }
    set_state('datasets');
}

{
    my( $current );
    
    sub current_dba {
        my( $dba ) = @_;
        
        if ($dba) {
            $current = $dba;
        }
        return $current;
    }
}

sub draw_sequence_list {
    my( $cw, $name, $details ) = @_;
    
    my $canvas = $cw->canvas;
    $canvas->delete('all');    
    $canvas->toplevel->configure(-title => "Otter: $name");
    my $dba = get_DBAdaptor_from_details($details);
    current_dba($dba);
    my $type = $dba->assembly_type;
    my $sth = $dba->prepare(q{
        SELECT c.embl_acc
          , c.embl_version
          , a.chromosome_id
          , a.chr_start
          , a.chr_end
          , a.contig_start
          , a.contig_end
          , a.contig_ori
        FROM assembly a
          , contig g
          , clone c
        WHERE a.contig_id = g.contig_id
          AND g.clone_id = c.clone_id
          AND a.type = ?
        ORDER BY a.chr_start
        });
    $sth->execute($type);
    my( $acc, $sv, $chr_id,
        $chr_start, $chr_end,
        $contig_start, $contig_end, $strand );
    $sth->bind_columns( \$acc, \$sv, \$chr_id,
        \$chr_start, \$chr_end,
        \$contig_start, \$contig_end, \$strand );

    my $font = $cw->font;
    my $size = $cw->font_size;
    my $x = $size;

    my $i = 0;
    my $last_end = 0;
    my( $chr_name );
    while ($sth->fetch) {
        unless ($chr_name) {
            $chr_name = getchr_name($dba, $chr_id);
        }
        if ($last_end + 1 != $chr_start) {
            #warn "$last_end + 1 != $chr_start\n";
            $i++;
        }
        my $contig_line = sprintf("%-10s  %2d", $acc, $sv);
        my $txt = $canvas->createText(
            $x, $i * (1.2 * $size),
            -text   => $contig_line,
            -font   => [$font, $size, 'bold'],
            -anchor => 'nw',
            -tags   => [
                "chr_start=$chr_start",
                "chr_end=$chr_end",
                "contig_start=$contig_start",
                "contig_end=$contig_end",
                "contig_ori=$strand",
                "accession=$acc",
                "sv=$sv",
                "chr_name=$chr_name",
                ],
            );
        $canvas->bind($txt, '<Button-1>', sub{
            $cw->deselect_all;
            $cw->highlight($txt)
            });
        $canvas->bind($txt, '<Control-Button-1>', sub{
            $cw->highlight($txt)
            });
        $canvas->bind($txt, '<Shift-Button-1>', sub{
            extend_highlighted_region($cw, $txt);
            });
        $canvas->bind($txt, '<Double-Button-1>', sub{ do_fetch($cw) });
        
        $last_end = $chr_end;
        $i++;
    }
    
    set_state('sequences');
    
    $cw->fix_window_min_max_sizes;
}

sub extend_highlighted_region {
    my( $cw, $txt ) = @_;
    
    # list_selected returns object indices sorted
    my @obj = $cw->list_selected;
    my %already_selected = map {$_, 1} @obj;
    
    # We assume that the object indices allocated by
    # the canvas get sequential numbers.
    my $closest = get_nearest($txt, @obj);
    
    my @range = $closest < $txt ? ($closest .. $txt) : ($txt .. $closest);
    foreach my $i (@range) {
        $cw->highlight($i) unless $already_selected{$i};
    }
}

sub get_nearest {
    my( $this, @list ) = @_;
    
    return $this unless @list;
    
    my( $closest, $close_distance );
    foreach my $i (@list) {
        my $distance = $i < $this ? $this - $i : $i - $this;
        if ($closest) {
            next unless $distance < $close_distance;
        }
        $closest = $i;
        $close_distance = $distance;
    }
    
    return $closest;
}

# get otter db details from submissions database (schema >0.21)
# from set_name 
sub get_otter_db_name{
    my($set_name)=@_;
    my $sth = prepare_statement(qq{
	SELECT d.db_name,d.host,d.port
	FROM ana_set a, ana_ensembl_db d
	WHERE a.set_name='$set_name'
	    and a.ensembl_db_id = d.ensembl_db_id
        });
    $sth->execute;
    my( @ret );
    my ($nam,$host,$port);
    my $n=0;
    while (@ret = $sth->fetchrow) {
	($nam,$host,$port)=@ret;
	$n++;
    }
    die "Set '$set_name' not found\n" if $n==0;
    die "ERROR: Set '$set_name' found multiple times\n" if $n>1;
    return $nam,$host,$port;
}

sub fork_spandit {
    my( $path ) = @_;
    
    if (my $pid = fork) {
        return;
    }
    elsif (defined $pid) {
        exec('spandit', '-path', $path);
    }
    else {
        warn "Unable to fork : $!";
    }
}

__END__

=head1 NAME - otter

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

